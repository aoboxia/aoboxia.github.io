<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客是作为一个程序猿的标配，由于工作的原因，我们记录笔记的方式早已不是高中阶段的在笔记本上用手抄的形式。作为一个计算机的从业者，我们后面会接触到很多新的知识点和技术。我们应当学会在互联网上记录自己这些心得笔记，所以搭建一个属于自己的个人博客就显得很有必要了。</p><p>首先要明确一点，就是我们的目的不仅仅是学会搭建博客，博客只是一个个人平台。更重要的是养成定期写博客，更新技术笔记的习惯。</p><a id="more"></a><p><strong>注意：比较心急的同学可跳过介绍部分，直接按如下步骤进行配置即可：</strong></p><p><a href="#a">1.安装Git</a></p><p><a href="#b">2.安装NodeJs</a></p><p><a href="#c">3.安装Hexo</a></p><p><a href="#d">4.创建Github仓库</a></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="1-Git"><a href="#1-Git" class="headerlink" title="1.Git"></a>1.Git</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Git是当下<strong>全球</strong>计算机从业者使用最多一个代码版本控制工具，也是我们<strong>必须</strong>要掌握并熟练使用的一个工具。我们能够使用它进行代码的备份，回退。并且在多人开发时，能够进行代码合并。通常，大型的项目开发都必须使用Git进行版本控制，开发人员负责提交代码，项目经理负责代码的合并，这一切都是采用Git来完成的。</p><h4 id="Git和Github"><a href="#Git和Github" class="headerlink" title="Git和Github"></a>Git和Github</h4><p>目前有很多同学都不清楚Git和Github之间的区别，认为Git就等同于Github。实际上两者是完全不同的，Github只是一个网站，一个专门用于存储Git上传的代码仓库。我们将本地的代码使用Git上传到Github上面托管，我们所有的数据都存储在上面，多人开发时，也是大家同时使用Github上面的同一个仓库进行代码管理。</p><p>所以，Git是一个工具，Github是当下全球最大的一个开源代码托管平台。全世界的程序员都将代码放到上面进行托管，各种开源的语言、库都可以在上面找到源代码。国内也有类似的代码网站，由于Github是一个国外的网站，</p><p>所以国内访问加载和上传速度都很慢，所以我们有时候采用国内的<a href="https://gitee.com" title="码云" target="_blank" rel="noopener">码云</a>。功能和使用方法都是一样的，只不过一个在国内一个在国外。</p><p><a id="a"></a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Git是一个开源的工具，可以直接在官网下载然后通过一键安装即可。这里我们选择一个Git Bash一键安装Git，如果电脑不是windows系统自行下载相应的系统的版本即可。</p><ul><li><a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git下载地址</a></li><li><strong>安装步骤</strong>: 直接运行exe文件，全部next，不用修改任何配置即可</li><li>安装完成，在任意文件夹下右键即会出现Git Bash选项，点击进入Git Bash界面，输入<code>git version</code>指令出现Git的版本信息则表示安装成功</li></ul><h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>node.js是运行在服务端的JavaScript，通常我们知道的CSS/HTML/JS是网页前端开发的标准三件套。HTML负责搭建网页的主体框架和布局，CSS负责跳转每个版块之间的间距，各种控件的颜色大小等等，JS则用于实现网页上的一些动态元素，例如一些动画效果，并接受一些动态的参数。通常JS作为一种胶水语言都是用于前端开发的。</p><p>但是node.js为js搭建了一个平台，使得js也能像Java/Python/PHP一样用于后台开发。由于我们使用的hexo框架是基于node.js实现的一个博客框架，所以我们首先要搭建一个服务端的JS环境。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><a id="b"></a></p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJs下载地址</a>(下载LTS版本)</li><li>下载好msi文件后，也是一键安装，不过记得在Custom Setup这一步双击下面的<code>Add To PATH</code>，把node添加到你电脑的环境变量中</li><li>在任意文件夹下打开Git bash，输入<code>node -v</code>出现了node的版本信息即为安装成功</li></ul><p>如果安装时忘记勾选<code>Add to PATH</code>，可以在电脑左下角搜索编辑系统环境变量，点击打开，点击环境变量，然后再用户配置或者系统配置中<code>Path</code>点击编辑，将你的node.js的bin文件目录添加进去即可。</p><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://hexo.io/zh-cn/docs/index.html" title="Hexo文档" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>简单来说，就是一个别人写好的博客网站模板，你直接下载下来试用就可以了。并且hexo支持便捷的更换网站主题，就像你的电脑更换壁纸一样，你可以在网上下载一个hexo主题，复制到相应的文件夹下就可以一键更换你整个网站的界面和功能了。</p><p><a id="c"></a></p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><ul><li>创建一个文件夹用于存放整个博客网站的文件</li><li>进入该文件夹右键进入Git bash界面</li><li>先使用<code>git --version</code>和<code>node -v</code>确认都能正常出现版本信息没有报错方可进入下一步<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/git-node-version.png" alt="版本信息"></li><li>输入<code>npm install -g hexo-cli</code>，安装hexo指令<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/npm.png" alt="npm"></li><li>输入<code>hexo -v</code>确认指令安装成功<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexo.png" alt="npm"></li><li>确认上一步没有报错后，使用<code>hexo init</code>进行hexo博客框架的初始，完成后，会出现如下文件夹<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexoinit2.png" alt="npm"></li><li>解释一下<ul><li>node_modules：是node.js的依赖包</li><li>public：存放的是生成的网页前端页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：存放你的markdown博客文件</li><li>themes：网站主题，可自行下载，默认是<code>landscape</code></li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li></ul><p>到此我们的博客就已经在本地搭建完成了，依次输入下面三个指令可以在本地预览博客的效果：</p><ul><li><code>hexo clean</code> 清空hexo缓存</li><li><code>hexo generate</code>根据markdown文件生成相应的资源文件</li><li><code>hexo server</code>在电脑本地运行hexo服务<br>看到如下信息，就代表你的hexo博客已经在本地运行起来了，可以在浏览器中打开<code>http://localhost:4000</code>进入博客，按<code>Ctrl+c</code>关闭服务。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexos.png" alt="本地运行Hexo"></li></ul><h3 id="4-连接Github"><a href="#4-连接Github" class="headerlink" title="4.连接Github"></a>4.连接Github</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Github是全面全球最大的一个代码托管平台，他是有许许多多的代码仓库构成，每个人都可以创建仓库，并且仓库的所有代码都是公开的，因此我们能在上面找到各种项目各种语言的源代码。今后我们学习和工作会与它密不可分。学习世界上最顶尖的大牛、最优秀的开源框架的代码也是一种极快提升我们视野和能力的途径。</p><p>刚才我们只是本地运行了Hexo博客，这里我们要做的是将我们本地的hexo博客的文件夹上传到Github的仓库当中，让所有人都能访问到我们的博客。Github为我们每个注册的用户免费提供了一个<code>https://yourname.github.io</code>的域名，因此我们可以将Github当成服务器运行我们博客网站。每次我们需要写博客就在本地写好之后同步提交到Github，然后我们的博客也能自动更新。</p><p><a id="d"></a></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>首先你需要到<a href="https://github.com" target="_blank" rel="noopener">Github</a>使用邮箱注册一个账号</li><li>然后创建一个repository(仓库)<br>仓库的名字一定要是<code>yourname.github.io</code><br><strong>例如:</strong> 我的用户名是<code>ctguqmx</code>然后我们仓库名就是<code>ctguqmx.github.io</code><br>因为Github只为我们提供这一个可以访问的域名<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/github.png" alt="创建仓库"></li></ul><h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><p>网上有很多方法是使用ssh连接Github，但是由于初学者难以理解，这里我们采用在url链接中直接使用账号密码的方式连接Github</p><ul><li>打开的hexo博客文件夹，建议把它和仓库一样命名为<code>yourname.github.io</code>，右键进入Git Bash</li><li>输入<code>git init</code>，该指令用于将该文件夹初始化为一个Git仓库，会生成一个<code>.git</code>文件用于存储该仓库的一些信息</li><li>输入<code>git remote add origin https://用户名:密码@github.com/xxx/xxx.git</code>该指令用于指定远程仓库的地址。仓库的最上方可以查看该网址，每个仓库都有两个网址作为该仓库的唯一标识，分别是<code>https://xxx</code>和<code>git@github:xxx</code><br>这里我们使用https的这个并在链接的中间加入自己的账号密码，<strong>注意修改成你自己的github账号密码和仓库地址</strong>。最后我们是通过这个链接中的账号密码来登录Github的。<br><strong>例如:</strong> 我的是<code>git remote add origin https://ctguqmx:mypassword@github.com/ctguqmx/ctguqmx.github.io.git</code></li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/giturl.png" alt="github仓库的连接"></p><ul><li>输入<code>git config --global user.name &quot;yourname&quot;</code>和<code>git config --global user.email &quot;youremail&quot;</code><br>设置你的用户名和注册邮箱地址</li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/gitconfig.png" alt="本地git的配置"></p><ul><li><p>修改hexo配置文件，打开博客根目录下的<code>_config.yml</code>文件，翻到最下面，按照如下方式修改，注意用你的自己的仓库链接，并且<code>:</code>后面有一个空格，多了或者少了都会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>最后使用<code>npm install hexo-deployer-git --save</code>安装一个插件，hexo3不自带Git上传功能。</p></li></ul><p><strong>常见错误:</strong> </p><ol><li><code>fatal: remote origin already exits.</code><br>原因：你已经绑定过了远程仓库的链接<br>解决办法：<code>git remote rm origin</code>删除链接，然后再用<code>git remote add http://xxx</code></li><li><code>fatal: Authentication failed for &#39;https://github.com/xxx/xxx.git&#39;</code><br>原因：账号或者密码错误<br>解决办法：<code>git remote -v</code>查看的你绑定的链接中的账号密码是否正确</li><li><code>Template render error: (unknown path)</code><br>原因：你写的Markdown博客文件语法错误，无法解析<br>解决办法: 找到相应的语法错误并修正</li></ol><h3 id="5-开始动手写一篇博客吧"><a href="#5-开始动手写一篇博客吧" class="headerlink" title="5.开始动手写一篇博客吧"></a>5.开始动手写一篇博客吧</h3><p>下面我将展示写一篇博客的常规操作</p><ul><li><code>hexo new &quot;my_first_blog&quot;</code></li><li>进入到博客文件夹的<code>source/_posts</code>目录下应该可以看一个<code>my_first_blog.md</code>的文件</li><li>你可以使用markdown的语法开始编写一篇博客了。具体语法可以参考<a href="http://xianbai.me/learn-md/index.html" target="_blank" rel="noopener">markdown语法</a></li><li><code>hexo g -d</code>是上<code>hexo generate</code>和<code>hexo deploy</code>的简写，直接一键发布，这时你的博客应该已经同步上传到了Github的仓库。打开Github应该可以看到和你本地一样的文件。</li><li>在浏览器中打开<code>https://yourname.github.io</code> ，看到界面就代表你成功了。</li></ul><h3 id="6-换一个更好看的主题"><a href="#6-换一个更好看的主题" class="headerlink" title="6.换一个更好看的主题"></a>6.换一个更好看的主题</h3><p>hexo默认为我们提供了一个网站的主题，实际上我们可以自己在github上下载更多更加好看，并且功能强大的主题来替换掉我们原有的主题，并且更换起来十分方便，基本上是一键切换。</p><p>我们可以自行在网上搜索<strong>hexo主题</strong>，便会出来很多供我们选择，配置起来也很简单。例如我的博客就是在<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的hexo主题 -知乎</a>上面找到的。下面我将以我们所用的主题为例，来实验一下如何切换hexo主题。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia.png" alt="yilia"></p><ol><li>首先选定一款hexo主题找到他的github仓库地址。例如我的是：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a><br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia_github.png" alt="yilia_github"></li><li>进入到你的博客文件夹下的themes文件夹，里面初始应该只有一个<code>landscape</code>主题，也就是你当前博客所使用的主题</li><li><p>打开Git Bash输入<code>git clone http://xxx.git</code>，将仓库克隆到本地，也可以在仓库右上角直接下载压缩包解压到themes文件夹下，但是注意要修改文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git yilia</span><br></pre></td></tr></table></figure></li><li><p>修改博客根目录下的 _config.yml文件，修改themes: yilia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></li><li><p>进入<code>yilia</code>文件夹，修改_config.yml文件(不是根目录下面的那个)，内容参考<a href="https://github.com/litten/BlogBackup/blob/master/_config.yml" target="_blank" rel="noopener">yilia参考配置</a></p></li><li>OK，主题切换完成，写博客的基本步骤和原来一样</li></ol><h3 id="7-改进空间"><a href="#7-改进空间" class="headerlink" title="7.改进空间"></a>7.改进空间</h3><p>其实上面只是简单复制了别人写好的博客网站，实际上我们还有更大的开发空间和写博客的一些必备技能。我这里详细展开，仅提供一些可以自己学习的方向。</p><h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p>前面已经说过了，Hexo是一款专门针对markdown的博客框架，也就是说我们的博客必须都是用markdown文件，因此我们必须要学习markdown的基本语法来编写博客，实际上markdown的语法非常简单，总共的语法也只有几十条，在编写博客时顺带查询markdown语法即可。本文就是由markdown自动生成，无需任何手动排版。</p><h4 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h4><p>其实我们可以在原有的主题的基础上进行二次开发，增加一些新的功能，例如我们经常在别人博客中看到的一些动态水墨效果，点击出现爱心等特效，还有博客的点赞评论，网站的流量统计等等，网上都有相应的JS插件，配置也十分简单，网上也有大量的教程，可自行学习。</p><h4 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h4><p>后面大家在编写博客时肯定会出现一个问题，就是数学公式怎么编辑，实际上Markdown中可以直接使用Latex进行数学公式的编辑，Latex可以用编程的方式来编写出一个数学公式，同样的，用Latex编辑数学公式，也是我们学习计算机的一个基本技能。我建议和Markdown一样，大家都可以从需求出发，需用到什么就学相应的语法来完成你的需求，从用中学，从而达到熟能生巧。</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>我们在编写博客时，经常需要插入一些图片，我们可以在Source文件下新建一个文件专门用来存储图片，然后再Markdown博客中用<strong>相对路径</strong>来引入图片。图片会随着你的博客项目一起推送到Github当中，但是这种往往加载速度很慢，加上Github容量有限并且是国外的服务器。</p><p>这里我们可以单独将我们的图片文件上传到第三方的服务器上，然后直接通过图片的url来访问。目前常用的用阿里云和七牛云，新建一个存储空间用来存放图片，基本都有一定免费的存储额度。并且他们有专业的图片加速算法，通常加载速度都非常快。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>我们默认的使用的是Github提供给我们的域名，实际上我们可以自己申请一个域名，来替换掉这个域名，阿里云，腾讯云等等都能进行域名的申请，例如我使用<code>.top</code>的域名，一年只有几块钱，<code>.com</code>一年大概50~60。申请一个自己的个人域名后面也会大有用处，至于后续的域名备案，大家可自行摸索。</p>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NFL定理</title>
      <link href="/2019/08/04/NPL%E5%AE%9A%E7%90%86/"/>
      <url>/2019/08/04/NPL%E5%AE%9A%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>前提：<br>所有“问题”出现的机会相同，火速有问题同等重要(均匀分布)<br>NFL定理(No Free Lunch Theorem), 没有免费的午餐定理， 任意两个学习算法$\varepsilon_{a}$和$\varepsilon_{a}$,他们的期望性能相同。</p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><blockquote><p>假设样本空间$\chi$是离散的, 令$P(h|x,\varepsilon_{a})$代表算法$\varepsilon_{a}$基于训练数据X产生假设h的概率，再令$f$代表我们希望学习的真实目标函数</p></blockquote><p>则有：$\varepsilon_{a}$在训练集之外的所有样本上的误差为</p><script type="math/tex; mode=display">E_{ote}(\varepsilon_{a}|X,f)=\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})</script><p>其中：<br>$\sum_{h}$代表对算法$\varepsilon_{a}$所产生的多个假设的概率求和<br>$\sum_{x\in\chi-X}$代表训练集之外的所有样本<br>$P(x)$代表每个样本x被选中的概率<br>$\prod(h(x)\not=f(x))$代表当前的假设是否和期望值相等,若不等则取值为1,否则取值为0</p><p>考虑二分类问题，且真实目标函数可以是任何函数$\chi\rightarrow\{0,1\}$,函数空间为$\{0,1\}^{|x|}$,对所有可能的f按均匀分布对误差求和</p><script type="math/tex; mode=display">\begin{aligned}\sum_{f}E_{ote}(\varepsilon_{a}|X,f)&=\sum_{f}\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})\\&=\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,\varepsilon_{a})\sum_{f}\prod(h(x)\not=f(x))\\&=\sum_{x\in\chi-X}P(x)*1*\frac{1}{2}2^{\chi}\\&=2^{|\chi|-1}\sum_{x\in\chi-X}P(x)\end{aligned}</script><p>由上式可以看出，总误差和算法无关，也就是说任意两种算法的期望性能相同的</p>]]></content>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim编辑器</title>
      <link href="/2019/08/01/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/08/01/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h2 id="vim的基础配置"><a href="#vim的基础配置" class="headerlink" title="vim的基础配置"></a>vim的基础配置</h2><p>Vim 的全局配置一般在<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效。用户个人的配置在<code>~/.vimrc</code></p><a id="more"></a><p>配置项一般都有”打开”和”关闭”两个设置。”关闭”就是在”打开”前面加上前缀”no”。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">" tab/缩进空格数</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> </span><br><span class="line"><span class="comment">" 整行左右缩进空格数, &lt;&lt;左缩进, &gt;&gt;右缩进, =取消全部缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="comment">" 在行首时tab缩进shiftwidth大小空格, 默认tab都缩进tabstop大小</span></span><br><span class="line"><span class="keyword">set</span> smarttab</span><br><span class="line"><span class="comment">" 采用C语言缩进风格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="comment">" 不进行备份</span></span><br><span class="line"><span class="keyword">set</span> nobackup</span><br><span class="line"><span class="comment">" 不产生swap文件（通常非正常退出都会产生.swap文件）</span></span><br><span class="line"><span class="keyword">set</span> noswapfile</span><br><span class="line"><span class="comment">" 支持使用鼠标</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span></span><br><span class="line"><span class="comment">" 背景风格</span></span><br><span class="line"><span class="keyword">colo</span> torte</span><br><span class="line"><span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br></pre></td></tr></table></figure><h2 id="vim的常用快捷键"><a href="#vim的常用快捷键" class="headerlink" title="vim的常用快捷键"></a>vim的常用快捷键</h2><p>快捷键都是normal模式下使用</p><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><blockquote><p><code>i</code> 切换到插入模式（编辑模式）<br><code>[esc]</code> 退出到normal模式<br><code>v</code> 切换到视图模式（可选中）</p></blockquote><h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h3><blockquote><p><code>:w</code> —&gt; 报错<br><code>:q</code> —&gt; 退出<br><code>:!</code> —&gt; 强制<br><code>:wq!</code> —&gt; 先保存后强制退出</p></blockquote><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><blockquote><p><code>y</code> —&gt; 复制<br><code>yy</code> —&gt; 复制当前行<br><code>p</code> —&gt; 粘贴<br><code>dd</code> —&gt; 删除当前行, 同时会复制<br><code>x</code> —&gt; 删除光标所在字符<br><code>u</code> —&gt; 撤销</p></blockquote><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><blockquote><p><code>hjkl</code> 分别对应 ←↑↓→<br><code>w</code> —&gt; 到下一个单词的开头<br><code>e</code> —&gt; 到下一个单词的结尾<br><code>0</code> —&gt; 到行头<br><code>$</code> —&gt; 到行尾<br><code>^</code> —&gt; 到本行第一个非blank字符<br><code>g_</code>—&gt; 到本行最后一个非blank字符<br><code>%</code> —&gt; 光标移动到最近的括号上,左右括号来回切换<br><code>#</code> —&gt; 到光标所在单词上一个相同单词<br><code>*</code> —&gt; 到光标所在单词下一个相同单词<br><code>gg</code>—&gt; 到文件开头<br><code>G</code> —&gt; 到文件结尾</p></blockquote><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><blockquote><p><code>split</code> 当前文件水平分屏<br><code>vplit</code> 当前文件垂直分屏<br><code>new</code> 水平分屏一个新文件<br><code>vnew</code> 垂直分屏一个新文件<br><code>Ctrl+w+hjkl</code> 切换分屏</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unicode与UTF-8编码</title>
      <link href="/2019/02/16/Unicode%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
      <url>/2019/02/16/Unicode%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>首先确定一个问题,无论采用何种编码方式,最后在计算机当中一定是以二进制的形式存储的。至于编码方式,则是将具体的字符和二进制之间的一个对照关系。</p><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p><code>ASCII</code>是最早出现的编码方式,是美国用来将26个字母和一些英文字符和二进制对应起来的一种编码方式,<code>ASCII</code>一共规定了128个字符的二进制表示,只需要用到7位二进制数,首位统一规定为0.</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>由于世界上各地语言存在差异,因此存在着各种千奇百怪的符号,并且相同的符号在不同的地区可能表示不同的意思.因此一个字节8位的编码方式远远不能满足需求。因此有了<code>Unicode</code>,<code>Unicode</code>实际上是一个字符集，它是<code>ASCII</code>的一个扩充版,他将全世界所有的字符全部包含其中，并且规定所有字符的二进制表示。它共包含了100多万种字符的二进制表示方式。全世界出现的所有的字符都在这个表中有唯一的表示方法。因此解决各国字符不兼容的问题。</p><p><code>Unicode</code>实际上只规定每个字符的二进制表示方法,但并没有给出每个字符的具体存储方式。与此同时也带来一些问题。例如,如何将<code>Unicode</code>和其他的编码方式区分开来,<code>ASCII</code>用一个字节来表示字符,而<code>Unicode</code>可能采用多个字节来表示一个字符。如何知道我在表示一个字符时到底是采用的一位还是两位甚至更多呢？另外,如果把所有字符统一规定为四位甚至五位，那么必然会带来极大的内存浪费。</p><p>但是为了区分不同的字符,必然是需要唯一确定的二进制表示的,但是我们对<code>Unicode</code>可以采用不同的实现方式。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p><code>UTF-8</code>实际上就是目前最常用的一种<code>Unicode</code>的实现方式。他为了解决直接采用<code>Unicode</code>存储带来的内存浪费,采用了一个可变长编码的方式,就是<code>Unicode</code>编码的不同范围的字符采用不同的字节表示,例如小字符采用一个字节表示，大一点的采用两位。每个字符表示的字节数是可长可短的。具体采用几位字节表示在首位用1的个数给出。具体规则如下：</p><blockquote><p>1）对于<code>单字节</code>的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 <code>Unicode</code> 码。因此对于英语字母，<code>UTF-8</code> 编码和 <code>ASCII</code> 码是相同的。</p><p>2）对于<code>n</code>字节的符号(n &gt; 1)，第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 <code>Unicode</code> 码。</p></blockquote><p>具体编码方式如下：<br><table>   <thead>    <tr>      <th>Unicode符号范围(十六进制)</th>      <th>UTF-8编码方式(二进制)</th>    </tr>  </thead>  <tbody>    <tr>      <td>0000 0000-0000 007F</td>       <td>0xxxxxx</td>    </tr>    <tr>      <td>0000 0080-0000 07FF</td>      <td>110xxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0000 0800-0000 FFFF</td>      <td>1110xxxx 10xxxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0001 0000-0010 FFFF</td>      <td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>    </tr>  </tbody></table></p><p>如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>以<code>夏</code>为例,<code>夏</code>的<code>Unicode</code>表示为<code>590F</code>(‭<code>0101100100001111</code>‬),由上表可知,<code>夏</code>在第三行的范围当中,因此将<code>夏</code>的二进制数从右到左一次填入第三行的<code>x</code>当中,高位未填完的<code>x</code>补<code>0</code>,最后得到<code>夏</code>的<code>UTF-8</code>的二进制表示为<code>11100101 10100100 10001111</code>,十六进制表示为<code>‭E5A48F‬</code>。</p>]]></content>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL</title>
      <link href="/2019/01/01/stl/"/>
      <url>/2019/01/01/stl/</url>
      <content type="html"><![CDATA[<h2 id="stl-config-h中的各种组态-configuration"><a href="#stl-config-h中的各种组态-configuration" class="headerlink" title="stl_config.h中的各种组态(configuration)"></a>stl_config.h中的各种组态(configuration)</h2><h3 id="STL-STATIC-TEMPLATE-MEMBER-BUG"><a href="#STL-STATIC-TEMPLATE-MEMBER-BUG" class="headerlink" title="__STL_STATIC_TEMPLATE_MEMBER_BUG"></a>__STL_STATIC_TEMPLATE_MEMBER_BUG</h3><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试在class template 中拥有 static data members. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">int</span>&gt;::_data = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">char</span>&gt;::_data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">int</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">char</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">testClass&lt;<span class="keyword">int</span>&gt; obji1, obji2;</span><br><span class="line">testClass&lt;<span class="keyword">char</span>&gt; objc1, objc2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">obji1._data = <span class="number">3</span>;</span><br><span class="line">objc2._data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-CLASS-PARTIAL-SPECIALIZATION"><a href="#STL-CLASS-PARTIAL-SPECIALIZATION" class="headerlink" title="__STL_CLASS_PARTIAL_SPECIALIZATION"></a>__STL_CLASS_PARTIAL_SPECIALIZATION</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test __STL_FUNCTION__TMPL_PARTIAL_ORDER in &lt;stl_config.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;T, Alloc&gt;&amp;)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"swap()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,y;</span><br><span class="line">swap(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-MEMBER-TEMPLATES"><a href="#STL-MEMBER-TEMPLATES" class="headerlink" title="__STL_MEMBER_TEMPLATES"></a>__STL_MEMBER_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试class template 之内可否再有 template (members)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">iterator</span> <span class="title">position</span>, <span class="title">I</span> <span class="title">first</span>, <span class="title">I</span> <span class="title">last</span>) &#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"insert()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line">x.insert(ite, ia, ia+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-LIMITED-DEFAULT-TEMPLATES"><a href="#STL-LIMITED-DEFAULT-TEMPLATES" class="headerlink" title="__STL_LIMITED_DEFAULT_TEMPLATES"></a>__STL_LIMITED_DEFAULT_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 template 参数可否根据前一个 template 参数而设定默认值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; // for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">deque</span>() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deque"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; x; <span class="comment">//deque</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-NON-TYPE-TEMP-PARAM-BUG"><a href="#STL-NON-TYPE-TEMP-PARAM-BUG" class="headerlink" title="__STL_NON_TYPE_TEMP_PARAM_BUG"></a>__STL_NON_TYPE_TEMP_PARAM_BUG</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 class template 可否拥有 non-type template 参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; //for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)&#123;</span><br><span class="line"><span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//Iterator</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>,alloc,64&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、容器-container"><a href="#1、容器-container" class="headerlink" title="1、容器(container)"></a>1、容器(container)</h2><h2 id="2、算法-algorithm"><a href="#2、算法-algorithm" class="headerlink" title="2、算法(algorithm)"></a>2、算法(algorithm)</h2><h2 id="3、迭代器-iterators"><a href="#3、迭代器-iterators" class="headerlink" title="3、迭代器(iterators)"></a>3、迭代器(iterators)</h2><h2 id="4、仿函数-functors"><a href="#4、仿函数-functors" class="headerlink" title="4、仿函数(functors)"></a>4、仿函数(functors)</h2><h2 id="5、配接器-adapters"><a href="#5、配接器-adapters" class="headerlink" title="5、配接器(adapters)"></a>5、配接器(adapters)</h2><h2 id="6、配置器-allocators"><a href="#6、配置器-allocators" class="headerlink" title="6、配置器(allocators)"></a>6、配置器(allocators)</h2>]]></content>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux笔记</title>
      <link href="/2018/12/15/linux%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/12/15/linux%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="切换python优先级"><a href="#切换python优先级" class="headerlink" title="切换python优先级"></a>切换python优先级</h2><ol><li>设置优先级<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br></pre></td></tr></table></figure><ol><li>切换版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config python</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/linux-01.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随机数算法</title>
      <link href="/2018/10/24/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/24/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近一直在给大一的新生出题，经常需要用到随机数生成后台数据，然后偶然间在网上看到了几个很有意思的随机数算法，这里记录一下。</p><a id="more"></a><h1 id="随机数算法改造"><a href="#随机数算法改造" class="headerlink" title="随机数算法改造"></a>随机数算法改造</h1><h2 id="1、01等概率"><a href="#1、01等概率" class="headerlink" title="1、01等概率"></a>1、01等概率</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数，设计一个新的随机函数要求以等概率生成0和1。</p></blockquote><p>生成零的概率是 <code>p</code> ,1的概率是 <code>(1-p)</code> ,那么两个数随机数,第一个为0第二个为1的概率为 <code>p(1-p)</code> ,第一个为1第二个为0的概率为 <code>(1-p)p</code> 。从而实现等概率。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> p = <span class="number">0.2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_p</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; p * <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">int</span> tmp2 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">if</span> (tmp1 == <span class="number">0</span> &amp;&amp; tmp2 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp1 == <span class="number">1</span> &amp;&amp; tmp2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rand_0_and_1_with_equal_prob();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、1-n随机数"><a href="#2、1-n随机数" class="headerlink" title="2、1~n随机数"></a>2、1~n随机数</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生 1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数 rand_0_and_1_with_p()，设计一个新的随机函数，要求以等概率产生 1  到 n 之间的随机数。</p></blockquote><p>用01生成一个随机的二进制数，n以内的二进制数最多有log2(n)位。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; <span class="number">5</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_to_n_minus_1_with_equal_prob</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>,res,m = n;</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line">k++;</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">res |= rand_0_and_1_with_equal_prob() &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt;= m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、由1-5生成1-7等概率随机数"><a href="#3、由1-5生成1-7等概率随机数" class="headerlink" title="3、由1-5生成1-7等概率随机数"></a>3、由1-5生成1-7等概率随机数</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand5() ，它能生成 1~5 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求据此实现 rand7()，能产生1～7 之间的随机数字。</p></blockquote><p>rand5()可以生成 0 ~ 4 的随机数，用相同的方法，我们可以生成一个等概率随机的五进制数，两位五进制数最多可以表示 0 ~ 24 共 25 个数，去掉 21 ~ 24 ，剩下 0 ~ 21 对 3 取模正好得到 0 ~ 6 的随机数加一等到 1 ~ 7 的随机数</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = x * <span class="number">5</span> + y;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> (res % <span class="number">7</span> ) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、随机数范围扩展"><a href="#4、随机数范围扩展" class="headerlink" title="4、随机数范围扩展"></a>4、随机数范围扩展</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand7(),它能生成 1 ~ 7 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求用rand7()实现rand10() 能产生 1 ~ 10 的随机数字。</p></blockquote><p>用相同的方法可以用rand7()构造出7进制的二位数，<code>( rand7() - 1 ) * 7 + rand7()</code>可以表示1 ~ 49的所有七进制数。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_10</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        x = <span class="number">7</span> * (rand7() - <span class="number">1</span>) + rand7();  </span><br><span class="line">    &#125;<span class="keyword">while</span>(x &gt; <span class="number">40</span>);  </span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span> + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="等概率随机数算法"><a href="#等概率随机数算法" class="headerlink" title="等概率随机数算法"></a>等概率随机数算法</h1><h2 id="1、由两个不同概率函数生成等概率函数"><a href="#1、由两个不同概率函数生成等概率函数" class="headerlink" title="1、由两个不同概率函数生成等概率函数"></a>1、由两个不同概率函数生成等概率函数</h2><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> beta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;<span class="number">10000</span>; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> big = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = rand() % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (val&lt;<span class="number">3</span>) small++;</span><br><span class="line"><span class="keyword">else</span> big++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (big&lt;<span class="number">7000</span>) alpha++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (big&gt;<span class="number">7000</span>) beta++;</span><br><span class="line"><span class="keyword">if</span> (big != <span class="number">7000</span>) total++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total - (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、Knuth-Durstenfeld-Shuffle算法"><a href="#2、Knuth-Durstenfeld-Shuffle算法" class="headerlink" title="/2、Knuth-Durstenfeld Shuffle算法"></a>/2、Knuth-Durstenfeld Shuffle算法</h2><blockquote><p>Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它与列表中最后一个元素交换</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p><img src="/images/shuffle.png" alt="shuffle算法"></p><p>代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">ll = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,len(ll))):</span><br><span class="line">    p = random.randrange(<span class="number">0</span>,i+<span class="number">1</span>)</span><br><span class="line">    ll[i], ll[p] = ll[p], ll[i]</span><br><span class="line"></span><br><span class="line">print(ll)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年秋启明星工作室答辩</title>
      <link href="/2018/09/17/2018%E5%B9%B4%E7%A7%8B%E5%90%AF%E6%98%8E%E6%98%9F%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AD%94%E8%BE%A9/"/>
      <url>/2018/09/17/2018%E5%B9%B4%E7%A7%8B%E5%90%AF%E6%98%8E%E6%98%9F%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AD%94%E8%BE%A9/</url>
      <content type="html"><![CDATA[<p>暑期因为想着去了解一下区块链，搭建一个小的区块链实战一下。结果中途需要用到一个web框架，去串联每个区块链节点。就去试着学习了一下flask这个web框架。结果发现这是一个非常好用的web框架，轻量化，拓展性行强，配套教程和拓展工具库丰富。用来快速搭建一个web十分方便。所以中途学到一半就跑去跟着国外大佬的一个博客教程，搭建一个小的微博网站项目。因为博主的对整个网站的全局的思路十分清晰，从前期开始预留各种借口，优化项目结构，使得整个web应用拓展性极高。收获最多还是他提供给我的全局部署的一个思路。从零开始建站，各种需要考虑的细节，和整体的一个清晰的思路让我受益匪浅。</p><a id="more"></a><p>我的整个web应用的源码已经上传到了我的github上面，大家有兴趣的可以下载了解一下。<a href="https://github.com/aoboxia/flask_web/archive/master.zip" target="_blank" rel="noopener">点击下载</a>。这个是我<a href="https://github.com/aoboxia/flask_web.git" target="_blank" rel="noopener">github链接</a>。</p><h2 id="开发环境和工具"><a href="#开发环境和工具" class="headerlink" title="开发环境和工具"></a>开发环境和工具</h2><p>我电脑windows本地是在pycharm上进行这个web项目的开发的。不需要我自己配置虚拟环境，各种库安装，文件的创建也十分方便，强烈推荐大家使用，如果是简单的爬虫，或者算法题目的编辑，使用一个简单的编辑器就可以了。总之pycharm进行项目开发十分方便。</p><p>服务器上面我是用的ubuntu16.x，linux操作系统也是非常好用，用多了真的会觉得很方便，也强烈推荐。服务器上面我是用的mysql数据库，Gunicorn和Nginx两个web服务器。</p><h2 id="包的分布"><a href="#包的分布" class="headerlink" title="包的分布"></a>包的分布</h2><p>flask框架的web项目有一个标准的文件分布方式。首先是一个<code>app</code>的包，这是整个项目的主体部分。前端后台的代码文件都分布在这个里面。下面是一个我的文件分布：</p><blockquote><p>Microbog</p><blockquote><p>app</p><blockquote><p>forms.py<br>routes.py<br>init.py<br>models.py<br>templates</p><blockquote><p>base.html<br>index.html<br>user.html</p></blockquote></blockquote><p>logs</p><blockquote><p>microblog1.log<br>microblog2.log</p></blockquote><p>venv<br>.env<br>config.py<br>microblog.py<br>tests.py</p></blockquote></blockquote><p>其中省略很多文件，但是列出了主体的核心部分。我们首先可以看到所有文件都分布在microblog这个文件夹下。</p><h3 id="app文件夹"><a href="#app文件夹" class="headerlink" title="app文件夹"></a>app文件夹</h3><p>app是我项目的主体文件夹，可以看到我的大部分python文件和前端的html代码都是分布在这个里面的。下面我一次说明app包下面的文件的功能。</p><h4 id="forms-py"><a href="#forms-py" class="headerlink" title="forms.py"></a>forms.py</h4><p>这是我的表单文件，我的网页界面上面的表单都是我在这个文件中编写的一个类，然后通过python的库调用这个类实例化一个对象来创建一个表单。所以我可以通过编写类的方式就可以创建表单了，而不需要去写前端的代码，这样我可以快速实现我的功能。</p><h4 id="routes-py"><a href="#routes-py" class="headerlink" title="routes.py"></a>routes.py</h4><p>这里面是我专门用来存放视图函数的文件，python的装饰器是一个非常神奇的东西，可以自行百度了解一下。简单来说就是，我可以通过装饰器把函数和一个url绑定起来，这个函数专门用来处理该函数所绑定的url链接中所传来的信息。每当用户访问或点击到某个url，装饰器会捕获到这个访问，然后调用相应的视图函数去处理该事情的数据。<br>因此我每添加一个页面就需要编写一个相应的视图函数去处理该页面对应的url传来的数据。</p><h4 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a>init.py</h4><p>简单来说这就是一个接口文件，因为我们的包是一个封装好的一个整体，比如我这里的app包，外界是访问不了我这个包里面的内容的，那么我们如何去运行这个包中的文件呢？这里我们得给外界开放一个接口，<code>init.py</code>就是用来暴露接口的。我们可以在这个文件里面导入app文件下面的包，然后外面要访问app这个包时，就去找它的<code>init.py</code>文件，然后顺着<code>init.py</code>文件中导入包依次深入进去。所以这个文件其实就是提供接口的一个文件，每个包如果需要给外界提供相应的接口都可以通过创建一个<code>init.py</code>文件来实现。</p><h4 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h4><p>这个里面有点像大家编写游戏代码中的游戏元素类，web项目里面同样需要编写这样的类，我需要编写一个用户类，然后每新增一个用户就相当于给这个类实例化一个对象。然后里面还有邮件类，需要发送邮件时就调用这个类来实例化一个对象编写一封邮件。</p><h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>这是一个专门用来存放html代码的文件夹。我的前端代码都是存放在这个里面的。这是flask一个特别有用的功能。我们知道flask底层其实还是由两个基础的模块实现的，一个模块是<code>jinjia2</code>和<code>Werkzeug</code>，其中<code>jinjia2</code>是一个模板引擎，而我们这里的templates下面的html代码都是依赖这种模板引擎来编写的，让我们可以在html代码中使用循环，条件语句来书写，还可以用一种类似于类的继承的方式来复用html代码。可以说是用一种面向对象的编程方式去编写html代码。</p><h2 id="logs文件夹"><a href="#logs文件夹" class="headerlink" title="logs文件夹"></a>logs文件夹</h2><p>这是一个常用的惯例，我们很多地方都可以看到这个东西，这是一个日志文件夹用来存放日志，那么日志是用来干什么的呢？我们知道我们在编写算法题目时遇到错误我们都能及时的反馈出来，但是当一个项目处于生产阶段时，我们无法预知很多错误，所以我们需要一个日志文件来记录下你的项目在生产过程中出现的一些问题，来帮助你及时得到反馈，处理并修复一些问题。</p><p>下面还有一些我就不一一解释了，其中venv是一个虚拟环境，来用隔离你的项目和你的其他应用之间不相互干扰。比如你在microblog这个项目当中导入一个python包，由于venv这个虚拟环境将本项目和外界隔离开来了，所以外面使用不了这个python包。这个虚拟环境保证了项目的独立性，还有microblog.py文件是相当于一个main函数，就是它去调用app包来运行整个项目。所以在服务器上也只需要运行并监听这个文件就可以部署整个项目了。tests.py是一个测试文件，用来及时测试你的项目的相应功能是否能正常运行，.env文件用来存放环境变量,config.py也是用来调用环境变量的文件。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>其实这一块我还只停留在操作部分，怎么在数据库中查询，删除数据，数据库的更新等部分。至于怎么设计关系部门我还是参照别人的方式去做的。理解一些简单的关系设计，我这项目当中的粉丝相互关注机制还是不太了解，等过一段时间专门学习了数据库再来填坑。</p><h2 id="邮件和搜索"><a href="#邮件和搜索" class="headerlink" title="邮件和搜索"></a>邮件和搜索</h2><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>我为了丰富一下网站功能的丰富性，添加了发送邮件和全文搜索的功能。发送邮件部分主要是本地存储一个写好的邮件模板，然后根据用户的相关信息来填写这个邮件，然后通过一个代理发送出去，这里的代理就是指的google或者腾讯的这种代理。用你的google或者腾讯邮箱的账号来发送这封邮件。填写相关的账号密码和代理服务器即可。<br>另外还需要一个代理发送邮件的机制，flask相应的拓展包中有相关的功能，这个邮件当中会附带一个url链接。当用户接受到邮件然后点击这个链接时，我的服务器上的视图函数的装饰器会捕捉到这个点击，然后进行相关的处理来重置用户的账号密码。另外还需要给这个url附带一个token令牌，这也是web应用中常用的一个东西，用来控制url的有效时长。当超过一定的时长之后这个令牌将会失效，也就是说之后的点击是无效的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>这里搜索功能的实现主要是利用elasticsearch的搜索引擎来实现的。elasticsearch是一个常用的开源搜索引擎。python有相应的客户端来调用这个搜索引擎。你需要给你的数据库中的数据创建相应的索引用来给elasticsearch检索。其中还有一些数据库中的数据更新对应的检索也需要修改，这之间也存在也写先后的逻辑问题。主要使用方法是将elasticsearch运行在服务器后台，然后用代码动态的对数据库中的元素进行增删查改相应的数据索引。</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>在界面美化这方面我做得比较差，因为我主要关注的是项目的框架和功能的拓展，加上我在前端方面了解比较少，所以前端这方面的工作基本处于空白状态。但是其中我还是用到了少量ajax的方法，通过js渲染了一些消息提示框。这部分工作也是网上找的方法。</p><p>前端这一部分确实很大的局限了我的web应用的拓展，因为我不能做出相应功能的界面也导致我的web应用无法继续延伸。所以如果这学期有机会我也打算去学习web前端相应的知识。</p><h2 id="时间统一和语言"><a href="#时间统一和语言" class="headerlink" title="时间统一和语言"></a>时间统一和语言</h2><h3 id="时间统一"><a href="#时间统一" class="headerlink" title="时间统一"></a>时间统一</h3><p>我们知道世界上每个地区之间是有时差的，那么我在不同的地方发送动态如果显示的本地的时间这样会带来一定的问题。所以我在时间上必须得统一起来。这里涉及到一个时区转换的问题,我们有一个UTC的国际统一时间，这个时间是国际统一的，也就是全世界所有地方都一样。但是这个时间不方便我们认知，我们无法从这个时间获知到我们本地的时间具体是什么，因此我们还需要将UTC时间转换为本地时间。也就是我们服务器接受用户发送的动态并存储的时间数据是使用的UTC的国际统一时间戳，但是我们在给用户解析的时候再将这个时间解析为用户本地的时间，这样就解决时区不统一的问题。</p><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>我们在翻墙浏览youtube等国外网站时经常会发现很多东西都是中文显示的，这样满足了多种语言用户的需求。因此我的web应用当中同样部署了这一方案，其实这个实现起来也比较简单，只需要把web应用当中的提示性语句标识一下，然后专门给一个文件用来翻译这些被标识的语句。这个文件就相当于一张表，给你的web应用当中的提示语句都给了一个对应的翻译语句，然后设置一下你的web应用使用哪种语言就可以显示不同的语言了。通常这个翻译的文件都是<code>xxx.po</code>，按照规定的格式编写即可，网上有专门编写<code>.po</code>文件的编辑器可以实现自动翻译，使用起来也比较方便，然后需要将<code>.po</code>文件编译一些生成一个<code>.mo</code>文件就可以使用了，服务器最后调用的就是这个<code>.mo</code>文件。</p><h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><p>这方面的东西都比较碎，有很多零零散散的问题。也不好一一说。简单说一下我使用的gunicorn和nginx服务器。首先是服务器的配置文件。这个真的有点麻烦，最好还是照着网上的标配吧，改起来真的好麻烦，一不下心就崩了。有些端口监听的问题照着网上的来就好。</p><p>这里为什么需要用到两个web服务器？<br>一个是python的web服务器gunicorn。一个是我们现在使用的比较多的web服务器nginx。这种双重的服务器的部署好像是一个很常用的方案。其实一个web服务器也是可行的，也能解决正常的服务请求。但是这里使用双重服务器的好处主要在于负载均衡的问题。这是一个很常见的名词，很多流量大的网站都需要考虑这个问题，不然就会出现访问量增多导致服务器无法处理而导致系统崩溃的问题。因此我们需要合理的分配和调节服务的资源分配。这就是我们需要解决的负载均衡问题。我这里是将我的web应用运行在本地的8000端口，使用gunicorn服务器来监听和处理这个端口的数据，然后对外开放两个端口使用的nginx服务器，外部的数据和请求传输给nginx服务器，经过nginx服务器的处理之后在传输给本地的gunicorn服务器。这样当外界访问量过大时，nginx给以展示缓存部分数据慢慢交给gunicorn处理，虽然访问速度会变慢但是不至于服务器直接崩溃。<br>另外nginx在流量统计，访问管理，端口分配方面更加便捷，也给我们在某些数据处理方面带来了好处。<br>其实原因不止有这些，但是负载均衡是一个主要的问题，其他的方面的原因等我深入了解一些服务器，操作系统相关的知识再去深入了解其中的原理。</p>]]></content>
      
      
        <tags>
            
            <tag> 答辩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解</title>
      <link href="/2018/08/26/%E9%A2%98%E8%A7%A3/"/>
      <url>/2018/08/26/%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>最近发现自己真的太菜了，每次刷题的时候都没感觉，到了真正的比赛都是两眼一抹黑，啥算法都不会了，看来还是学了不知道怎么灵活运用，模板题做多了，思维比较僵化，稍微变化一点的题型完全没有思路。还是决定要多做一些线上的练习赛的题目，不会的之后多看一些别人的思路，学着模仿再到自己的灵活运用。</p><a id="more"></a><h1 id="2018ccpc网赛"><a href="#2018ccpc网赛" class="headerlink" title="2018ccpc网赛"></a>2018ccpc网赛</h1><p>全程划水，很多英文题目都没有看懂，有些大概知道需要用什么做但是还是形成不了具体的思路。慢慢来吧，先补几道水体，难的就不花时间了。</p><h2 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h2><blockquote><p>题目大意是一个商人可以依次经过1到n个城市，每个城市对于同一个商品的价格都不同，商人可以从一个城市买入再到另一个卖出来赚取差价，每经过一个城市都需要花费一个单位的时间而且只能依次经过1到n号城市不能回头。现在问最大的利润和最小的时间是多少。</p></blockquote><p>这道题感觉还挺简单的，不知道为啥当时没做出来，当时一直想着是找最大差值对，但是没有想到去用一个数据结构去维护数据，结果每次都需要重新扫描，自然是超时了。这题用一个堆来维护数据非常简单，依次往后走，前面已经遇到的数据放进一个堆里面存起来，后面每次都在前面找最小的数据差值就是利润，每次减去了一个差值之后就把新的较大值放入堆中，代替原有的值，下次再更新就相当于再原有的基础上更新差值了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; p;</span><br><span class="line">priority_queue&lt;p, <span class="built_in">vector</span>&lt;p&gt;, greater&lt;p&gt; &gt; q;<span class="comment">//这里用一个优先队列模拟堆，注意初始情况优先队列是从大到排序的，这样可以指定为从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n, num, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;num);</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">                ll a = q.top().first;</span><br><span class="line">                <span class="keyword">if</span>(num - a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += num - a;</span><br><span class="line">                    cnt += q.top().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(p(num,<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(p(num,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,sum,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YJJ’s-Salesman"><a href="#YJJ’s-Salesman" class="headerlink" title="YJJ’s Salesman"></a>YJJ’s Salesman</h2><p>这道题感觉似曾相似，知道要用一个线段树或者树状数组来维护数据，但是就是不知道怎么去处理这些数据。。。之后才知道原来简单的dp一下那些数据就行，找到最优解，再用线段树或者树状数组求和。</p><blockquote><p>题意大概是有很多个村庄，告诉了村庄的坐标，每个村庄都有一个权值，去到某个村庄就可以拿到相应的钱，但是约束了一下只有右上角的村庄才能拿到钱，正上方和正右边的是拿不到钱的，问怎么走拿到的前最多</p></blockquote><p>当时一看这道题就有点像之前做过的那个数组数组的题，天上有很多星星，每个星星有一个level，右上角的星星level+1，但是那道题权值都是一样的，现在这道题每个星星多加了一个权值，需要用动态规划的思想处理一下再用树状数组去维护,因为数据比较大，还需要离散化一下，说起来都是刚刚学过的。。。。但是我试了一下，好像不用离散化也能过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tree[maxn],a[maxn],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=maxn)</span><br><span class="line">&#123;</span><br><span class="line">tree[k] = max(num,tree[k]);</span><br><span class="line">ans = max(ans,tree[k]);</span><br><span class="line">k += k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qmax</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res  =<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">res = max(tree[k],res);</span><br><span class="line">k -=k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x&lt;b.x) || (a.x==b.x&amp;&amp;a.y&gt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;p[i].x,&amp;p[i].y,&amp;p[i].val);</span><br><span class="line">a[i] = p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> size=unique(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-(a+<span class="number">1</span>);<span class="comment">// 去重求大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i].y = lower_bound(a+<span class="number">1</span>,a+size+<span class="number">1</span>,p[i].y)-(a+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll val = Qmax(p[i].y<span class="number">-1</span>)+p[i].val;</span><br><span class="line">add(p[i].y,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LCA问题</title>
      <link href="/2018/08/24/LCA%E9%97%AE%E9%A2%98/"/>
      <url>/2018/08/24/LCA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>LCA问题，即最近公共祖先，一般有在线的ST算法和离线的Tarjin算法还有什么倍增法，最近学算法学的有点懵逼，先写一个常用的离线tarjin算法，比较容易理解。其他的先留着，以后再填坑。</p><a id="more"></a><h2 id="Tarjin离线算法"><a href="#Tarjin离线算法" class="headerlink" title="Tarjin离线算法"></a>Tarjin离线算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">10001</span>],s[<span class="number">10001</span>],t[<span class="number">10001</span>],head[<span class="number">10001</span>],dis[<span class="number">10001</span>],vis[<span class="number">10001</span>],lca[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;es[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].to = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">x == par[x] ? x : par[x] == find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjin</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">par[u] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[s[i]] &amp;&amp; t[i] == u)&#123;</span><br><span class="line">lca[i] = find(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[t[i]] &amp;&amp; s[i] == u)&#123;</span><br><span class="line">lca[i] = find(t[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dis[v] = dis[u] + es[i].w;</span><br><span class="line">tarjin(v);</span><br><span class="line">par[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z,tt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tt;</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i] &gt;&gt; t[i];</span><br><span class="line">&#125;</span><br><span class="line">tarjin(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[s[i]] + dis[t[i]] - <span class="number">2</span>*dis[lca[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流</title>
      <link href="/2018/08/24/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
      <url>/2018/08/24/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>网络流是一类基于贪心思想在有权图中寻找最优解的问题。最常见的就是最大流，最小费用流之类的问题。网络流的难度在于建模，怎么将问题转化为网络流的模型求解，如何构建边与边之间的关系，建立源汇点运行最大流算法求解。</p><a id="more"></a><h2 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h2><p>这种算法其实就是贪心思想加上个一点小的优化，每次选择一条通路，流过该条路径上满足的最小流量，不停选择下去就是纯粹的贪心思想，然后优化的一点就是增加了一个增广路径的东西，其实就是把每条路径设置成了双向的，逆向也有一个流量，有点像我们在处理迷宫问题一样，不停的往前走，直到发现走不通了，再回头看能不能找到其他的路径，这里的增广路径就是迷宫问题中回头的那一条路径，就是当每条边的容量没有完全用完时，则可以回流看能不能找到更大的流量。和迷宫问题一样，可以用dfs解决。理解起来比较容易，时间复杂度较高。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap,rev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">g[u].push_back((edge)&#123;v, w, g[v].size()&#125;);</span><br><span class="line">g[v].push_back((edge)&#123;u, <span class="number">0</span>, g[u].size()<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == t)<span class="keyword">return</span> f;</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line">edge &amp;e = g[v][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[e.to] &amp;&amp; e.cap &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> d = dfs(e.to,t,min(f,e.cap));</span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">e.cap -= d;</span><br><span class="line">g[e.to][e.rev].cap += d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> f =  dfs(s,t,INF);</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">flow += f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>由于前一种用dfs深度优先搜索的时候，如果出现路径的容量比较大的情况则增广路径十分大，递归层数也很多，所以我们可以考虑用广度优先搜索来优化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> cap[maxn][maxn],cur_flow[maxn],prev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edmonds_karp</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(prev,<span class="number">0</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cur_flow, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur_flow));</span><br><span class="line"></span><br><span class="line">cur_flow[src] = inf;</span><br><span class="line">q.push(src);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!cur_flow[i] &amp;&amp; cap[cur][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">if</span> (cur_flow[cur] &gt; cap[cur][i])</span><br><span class="line">cur_flow[i] = cap[cur][i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur_flow[i] = cur_flow[cur];</span><br><span class="line">prev[i] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur_flow[dest] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dest; i != src; i = prev[i])&#123;</span><br><span class="line">cap[prev[i]][i] -= cur_flow[dest];</span><br><span class="line">cap[i][prev[i]] += cur_flow[dest];</span><br><span class="line">&#125;</span><br><span class="line">flow_sum += cur_flow[dest];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>, d = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(cap));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;d, &amp;c);</span><br><span class="line">cap[s][d] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, edmonds_karp(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>Dinic算法是EK算法的一种优化，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">///oo表示无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">///mm表示边的最大数量，因为要双向建边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mm = <span class="number">111111</span>;</span><br><span class="line"><span class="comment">///点的最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">///node:节点数,src:源点,dest:汇点,edge:边数</span></span><br><span class="line"><span class="keyword">int</span> node, src, dest, edge;</span><br><span class="line"><span class="comment">///ver:边指向的结点,flow:边的流量,next:链表的下一条边</span></span><br><span class="line"><span class="keyword">int</span> ver[mm], flow[mm], next[mm];</span><br><span class="line"><span class="comment">///head:节点的链表头,work:用于算法中的临时链表头,dis:距离</span></span><br><span class="line"><span class="keyword">int</span> head[mn], work[mn], dis[mn], q[mn];</span><br><span class="line"></span><br><span class="line"><span class="comment">///初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> _node, <span class="keyword">int</span> _src, <span class="keyword">int</span> _dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node = _node, src = _src, dest = _dest;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    edge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///增加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[edge]=v,flow[edge]=c,next[edge]=head[u],head[u]=edge++;</span><br><span class="line">    ver[edge]=u,flow[edge]=<span class="number">0</span>,next[edge]=head[v],head[v]=edge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///广搜计算出每个点与源点的最短距离，如果不能到达汇点说明算法结束</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dinic_bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, l, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[q[r++]=src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l=<span class="number">0</span>; l&lt;r; l++)</span><br><span class="line">        <span class="keyword">for</span>(i=head[u=q[l]]; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">            <span class="keyword">if</span>(flow[i] &amp;&amp; dis[v=ver[i]]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///这条边必须有剩余流量</span></span><br><span class="line">                dis[q[r++]=v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///寻找可行流的增广路算法，按节点的距离来找，加快速度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="comment">///work 是临时链表头，这里用 i 引用它，这样寻找过的边不再寻找*</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=work[u],v,tmp; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[i]&amp;&amp;dis[v=ver[i]]==dis[u]+<span class="number">1</span>&amp;&amp;(tmp=Dinic_dfs(v,min(<span class="built_in">exp</span>,flow[i])))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">///正反向边容量改变</span></span><br><span class="line">            flow[i] -= tmp;</span><br><span class="line">            flow[i^<span class="number">1</span>] += tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///求最大流，直到没有可行流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_flow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret=<span class="number">0</span>, data;</span><br><span class="line">    <span class="keyword">while</span>(Dinic_bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">            work[i] = head[i];</span><br><span class="line">        <span class="keyword">while</span>(data = Dinic_dfs(src, oo))</span><br><span class="line">            ret += data;<span class="comment">//cout&lt;&lt;666&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///套模板</span></span><br><span class="line">    <span class="keyword">int</span> m, n, u, v, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        Init(m+<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            addedge(u, v, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic_flow());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加一个模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_v = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，容量，反向边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>  </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cap;</span><br><span class="line"><span class="keyword">int</span> rev;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[max_v];<span class="comment">//图的邻接表表示  </span></span><br><span class="line"><span class="keyword">int</span> level[max_v];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//向图中增加一条从s到t容量为cap的边  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> cap)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    G[from].push_back((edge)&#123;to,cap,G[to].size()&#125;);  </span><br><span class="line">    G[to].push_back((edge)&#123;from,<span class="number">0</span>,G[from].size()<span class="number">-1</span>&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    level[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=que.front();  que.pop();</span><br><span class="line">        <span class="keyword">if</span>(v==t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (e.cap&gt;<span class="number">0</span>&amp;&amp;level[e.to]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">                que.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过DFS寻找增广路  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">long</span> <span class="keyword">long</span> f)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(v==t)    <span class="keyword">return</span> f;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        edge &amp;e=G[v][i];  </span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;<span class="number">0</span>&amp;&amp;level[v]+<span class="number">1</span>==level[e.to])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d=dfs(e.to,t,min(f,e.cap));  </span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                e.cap-=d;  </span><br><span class="line">                G[e.to][e.rev].cap+=d;  </span><br><span class="line">                <span class="keyword">return</span> d;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//求解从s到t的最大流  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> flow=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">    flow+=dfs(s, t, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tt,x,y,z,cnt=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; max_v; i++)G[i].clear();</span></span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add_edge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt++,max_flow(<span class="number">1</span>,n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">后面还有最小费用流，和各种最大流的变形。。。。有时间慢慢写。。。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树链剖分</title>
      <link href="/2018/08/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2018/08/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      <content type="html"><![CDATA[<p>树链剖分之前一直不知道是个什么东西，最近才学到，发现也是一种很神奇的数据结构，主要是对树上的操作，将树剖分成不同的部分串联起来，再用其他的数据结构去维护他剖分的这些树链。</p><a id="more"></a><p>通常我们采用的是轻重链剖分，也就是将一棵树按照轻链和重链来划分成不同的部分。这里我们只需要知道六个个概念就足够了。</p><blockquote><p>重儿子：重儿子是指某个节点的所有子节点中子孙节点数目最多的儿子节点<br>轻儿子：某个节点的所有子节点中除重儿子之外的所有节点都是轻儿子<br>轻边：由连个亲儿子相连的边称为轻边<br>重链：由两个重儿子相连的边称为重边<br>轻链：轻边<br>重链：由重边连接而成的链称为重链</p></blockquote><p>树链剖分大多数对树的操作用其他的算法都能实现，而且时间复杂度也相当，而树链剖分的最独特的功能就是对树的路径上的值的修改，也就是，要修改在树上连续的节点值，这是其他的数据结构无法完成的。而通过树链剖分的方式则很好的解决这个问题。所以说树链剖分的主要功能是:<strong>修改树的路径上的值</strong></p><p>树链剖分主要分为三个部分：</p><h2 id="划分数据"><a href="#划分数据" class="headerlink" title="划分数据"></a>划分数据</h2><p>这一部分主要是找到树的轻重儿子，确定他们的关系，确定他们在树中的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d; <span class="comment">//深度</span></span><br><span class="line">fa[u] = pre; <span class="comment">//父亲节点</span></span><br><span class="line">ve[u] = <span class="number">1</span>; <span class="comment">//子孙节点个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];<span class="comment">//当前节点个数加上子节点所连的节点个数 </span></span><br><span class="line"><span class="keyword">if</span>(son == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;<span class="comment">//如果当前节点的重儿子为空或者出现子节点个数多于重儿子的则改变重儿子 </span></span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="连接轻重链"><a href="#连接轻重链" class="headerlink" title="连接轻重链"></a>连接轻重链</h2><p>前面找到了轻重儿子，然后就需要把他们连接起来形成链，并把他们一次编号，方便用线段树去维护。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);<span class="comment">//有重儿子则连接重链</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);<span class="comment">//遇到轻儿子则以轻儿子为顶点新开一条链</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查询和修改"><a href="#查询和修改" class="headerlink" title="查询和修改"></a>查询和修改</h2><p>通常我们用线段树来维护这些轻重链，利用前面已经编号的编号建树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span><br><span class="line">        update(p[top[x]], p[x], val, <span class="number">1</span>, n, <span class="number">1</span>);<span class="comment">//修改深度较大的重链上值</span></span><br><span class="line">        x = fa[top[x]];<span class="comment">//重链修改完成，上升到重链头结点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; dep[y]) swap(x,y);</span><br><span class="line">    update(p[x], p[y], val, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询u,v之间的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(<span class="number">1</span>, p[f1], p[u]));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(<span class="number">1</span>, p[son[u]], p[v]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="修改单点，查询最值模板"><a href="#修改单点，查询最值模板" class="headerlink" title="修改单点，查询最值模板"></a>修改单点，查询最值模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> deep[N],fa[N],p[N],fp[N],son[N],ve[N],top[N],col[N];</span><br><span class="line"><span class="keyword">int</span> head[N],sum[N*<span class="number">4</span>],from[N],to[N],value[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt,siz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;es[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].v = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d;</span><br><span class="line">fa[u] = pre;</span><br><span class="line">ve[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];</span><br><span class="line"><span class="keyword">if</span>(son[u] == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">sum[k] = max(sum[k&lt;&lt;<span class="number">1</span>],sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[k] = e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= pos)update(pos,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>update(pos,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res = max(res,query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res = max(res,query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void change(int x,int y,int val)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    while(top[x] != top[y])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span></span><br><span class="line"><span class="comment">//        update(p[top[x]], p[x], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//        x = fa[top[x]];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if(deep[x] &gt; dep[y]) swap(x,y);</span></span><br><span class="line"><span class="comment">//    update(p[x], p[y], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(p[f1], p[u], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(p[son[u]], p[v], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y,z;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp; t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">-1</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">siz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from[i],&amp;to[i],&amp;value[i]);</span><br><span class="line">add(from[i],to[i],value[i]);</span><br><span class="line">add(to[i],from[i],value[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[to[i]] &lt; deep[from[i]])swap(to[i],from[i]);</span><br><span class="line">update(p[to[i]],value[i],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s))&#123;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'D'</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">update(p[to[x]],y,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>块状链表</title>
      <link href="/2018/08/22/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/08/22/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>块状链表应该算一个额外拓展的知识吧，貌似不属于正规的算法，也算是一种比较中庸的数据结构，中和了一下数组和链表的优缺点，形成了一个新的数据结构就是块状链表。</p><a id="more"></a><p><strong>数组</strong> 在数组中修改或删除元素需要位移前后部分，需要的平均时间复杂度为<code>O(n)</code>，查询某个元素的时间复杂度是<code>O(1)</code>。</p><p><strong>链表</strong> 链表删除和修改元素，可以直接修改节点，时间复杂度为<code>O(1)</code>,查询需要遍历节点，平均时间复杂度是<code>O(n)</code></p><p><strong>块状链表</strong> 块状链表是把一个数组中的元素，分成多个数组，每个数组当成一个节点，普通的链表的节点是单个元素，而块状链表的节点是一个数组。它的查询和修改时间复杂度都是<code>O(sqrt(n))</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块大小和块数设为比sqrt(n)稍大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000000</span> + <span class="number">10</span>, block_sz = <span class="number">4000</span> + <span class="number">100</span>, block_num = <span class="number">4000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sz, next;<span class="comment">//sz:块内大小，next:下一个块位置</span></span><br><span class="line">    <span class="keyword">bool</span> rev;<span class="comment">//翻转标记</span></span><br><span class="line">    <span class="keyword">char</span> s[block_sz];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>, next = <span class="number">-1</span>, rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g[block_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_block</span><span class="params">()</span> <span class="comment">//新建块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = que.front();que.pop();</span><br><span class="line">    g[t].init();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_block</span><span class="params">(<span class="keyword">int</span> t)</span> <span class="comment">//删除块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.push(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_update</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//翻转块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[idx].rev)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(g[idx].s, g[idx].s + g[idx].sz);</span><br><span class="line">        g[idx].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_split</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> k)</span> <span class="comment">//把第idx块分裂成两个，前k个元素划分到第一块，其余元素划分到第二块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span> || k == g[idx].sz) <span class="keyword">return</span>;</span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="keyword">int</span> tot = new_block();</span><br><span class="line">    <span class="built_in">memcpy</span>(g[tot].s, g[idx].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (g[idx].sz - k));</span><br><span class="line">    g[tot].sz = g[idx].sz - k, g[idx].sz = k;</span><br><span class="line">    g[tot].next = g[idx].next, g[idx].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_merge</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//合并维护块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = g[i].next; j != <span class="number">-1</span>; j = g[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i].sz + g[j].sz &lt;= block_sz)</span><br><span class="line">            &#123;</span><br><span class="line">                block_update(i), block_update(j);<span class="comment">//确定合并两块时，查看是否翻转</span></span><br><span class="line">                <span class="built_in">memcpy</span>(g[i].s + g[i].sz, g[j].s, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * g[j].sz);</span><br><span class="line">                g[i].sz += g[j].sz, g[i].next = g[j].next;</span><br><span class="line">                del_block(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_init</span><span class="params">()</span> <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(! que.empty()) que.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) que.push(i);</span><br><span class="line">    head = new_block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_locate</span><span class="params">(<span class="keyword">int</span> &amp;idx, <span class="keyword">int</span> &amp;k)</span> <span class="comment">//查询全局第k个元素在某个块的某个位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(idx != <span class="number">-1</span> &amp;&amp; k &gt; g[idx].sz) k -= g[idx].sz, idx = g[idx].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//在全局的第k个元素后插入长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);<span class="comment">//先定位</span></span><br><span class="line">    block_split(idx, k); <span class="comment">//分裂</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = min(block_sz, n - i);</span><br><span class="line">        <span class="keyword">int</span> tot = new_block();</span><br><span class="line">        <span class="built_in">memcpy</span>(g[tot].s, str + i, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        g[tot].sz = sz;</span><br><span class="line">        g[tot].next = g[idx].next, g[idx].next = tot, idx = g[idx].next;</span><br><span class="line">        i += sz;</span><br><span class="line">    &#125;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_delete</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//删去全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next) del_block(i);</span><br><span class="line">    g[st].next = en_next;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_rev</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//翻转全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp[block_num], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].rev ^= <span class="number">1</span>;</span><br><span class="line">        tmp[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[++cnt] = st, tmp[<span class="number">0</span>] = en_next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) g[tmp[i]].next = tmp[i<span class="number">-1</span>];</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//打印全局的第k个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">if</span>(k == g[idx].sz) idx = g[idx].next, k = <span class="number">0</span>;<span class="comment">//输出字符时特判一下，用下面的输出函数不用特判</span></span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, g[idx].s[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//打印全局的第k个元素后的长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">0</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        block_update(i);</span><br><span class="line">        <span class="keyword">int</span> sz = min(n, g[i].sz - k);</span><br><span class="line">        <span class="built_in">memcpy</span>(str + len, g[i].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        len += sz, n -= sz;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cur = <span class="number">0</span>;<span class="comment">//光标位置，初始为0</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    block_init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len) &#123;<span class="keyword">char</span> ch = getchar();<span class="keyword">if</span>(ch &gt;= <span class="number">32</span> &amp;&amp; ch &lt;= <span class="number">126</span>) str[i++] = ch;&#125;</span><br><span class="line">            str[i++] = <span class="string">'\0'</span>;</span><br><span class="line">            block_insert(cur, len, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_delete(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'R'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_rev(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'G'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            block_print(cur);</span><br><span class="line">            <span class="comment">//block_print(cur, 1, str);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>) cur--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'N'</span>) cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分图</title>
      <link href="/2018/08/21/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2018/08/21/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h2 id="二分图的判断"><a href="#二分图的判断" class="headerlink" title="二分图的判断"></a>二分图的判断</h2><p>二分图的判断主要是利用染色法来判断所有相连的边是否有回路，依次给每个点染色，每个相邻的点染的颜色不同，如果发现，两个颜色颜色一样了则说明有回路。则不是二分图。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">color[v] = c;<span class="comment">//给当前节点染色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == c)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果两个直接相连的点颜色相同则有回路</span></span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == <span class="number">0</span> &amp;&amp; !dfs(g[v][i],-c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//0表示还没有染色的点，1，-1交替染色</span></span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i] &amp;&amp; !dfs(i,<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果一个点没有染色的点发现了回路则不是二分图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分最大匹配"><a href="#二分最大匹配" class="headerlink" title="二分最大匹配"></a>二分最大匹配</h2><p>二分图的最大匹配实际上可以转换为网络流里面的最大流问题，每个相连的边可以看成一个容量为1的一条边，然后增加一个源点和汇点分别连一条容量为1的边到二分图的左边和右边节点。最后最大匹配数就是源点和汇点的最大流。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  g[x].size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u = g[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[u] == <span class="number">-1</span> || find(match[u]))&#123;</span><br><span class="line">match[u] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(find(i))res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带权二分图"><a href="#带权二分图" class="headerlink" title="带权二分图"></a>带权二分图</h2><p>匈牙利算法只能解决最大二分匹配数目的问题，如果遇上了每条边都带有权值，那么就需要用到km算法，来计算权值最大的二分匹配方案。</p><p>实际上，二分匹配的算法都是基于贪心的思想，通过搜索找到当前最优解，不停搜索下去，遇到搜索失败再回头寻找新的匹配方案。这里的km算法就是基于这种思想。首先二分图的两边都有一个期望值，然后把左边的期望初始化为与它相连所有边的最大权值，右边都初始化为零，然后开始匹配，如果找到左右期望最大的匹配方案则匹配成功。否则所有左边尝试匹配过的节点都降低一个期望，右边尝试匹配过的节点都增加相同的期望，这样保证了期望和不变。然后继续搜索，匹配不成功就降低期望，直到匹配成功。时间复杂度为<code>O(n^3)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//左右两边的匹配数目</span></span><br><span class="line"><span class="keyword">int</span> match[<span class="number">10001</span>],slack[<span class="number">10001</span>],e[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> lx[<span class="number">10001</span>],ly[<span class="number">10001</span>],visx[<span class="number">10001</span>],visy[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">visx[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;<span class="comment">//右边的节点值每次搜索只匹配一次</span></span><br><span class="line"><span class="keyword">int</span> gap = lx[v] + ly[i] - e[v][i];<span class="comment">//左右期望值之和和相连边的差值</span></span><br><span class="line"><span class="keyword">if</span>(!gap)&#123;</span><br><span class="line">visy[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[i] == <span class="number">-1</span> || dfs(match[i]))&#123;<span class="comment">//如果右边没有匹配成功或者尝试调整和它匹配成功的左节点</span></span><br><span class="line">match[i] = v;<span class="comment">//匹配成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">slack[i] = min(slack[i],gap);<span class="comment">//记录一下期望和实际的差值，如果匹配失败就减去最小的一个差值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));<span class="comment">//右边期望初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">lx[i] = -INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">lx[i] = max(lx[i],e[i][j]);<span class="comment">//左边期望初始化为所有与之相连边中的最大权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//依次给每个左节点匹配</span></span><br><span class="line"><span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span>(slack));<span class="comment">//差值初始化为无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//不断匹配，直到匹配成功</span></span><br><span class="line"><span class="built_in">memset</span>(visx,<span class="number">0</span>,<span class="keyword">sizeof</span>(visx));</span><br><span class="line"><span class="built_in">memset</span>(visy,<span class="number">0</span>,<span class="keyword">sizeof</span>(visy));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dfs(i))<span class="keyword">break</span>;<span class="comment">//匹配成功退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visy[j])</span><br><span class="line">d = min(d,slack[j]);<span class="comment">//找到最小的期望和实际的差值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visx[j])lx[j] -= d;<span class="comment">//匹配失败左边降低期望</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[j])ly[j] += d;<span class="comment">//右边增加期望</span></span><br><span class="line"><span class="keyword">else</span>slack[j] -= d;<span class="comment">//因为左边期望降低，所以没有访问过的期望差值也降低</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[i] != <span class="number">-1</span>)</span><br><span class="line">res += e[match[i]][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//返回所有最大权值边之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树和树状数组</title>
      <link href="/2018/08/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2018/08/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>线段树和树状数组有很多相似之处，都可以解决RMQ(区间最值查询)问题。都是通过维护一个特殊的数据结构来达到高效的查找，时间复杂度都是<code>O(log n)</code></p><a id="more"></a><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="1-单点更新"><a href="#1-单点更新" class="headerlink" title="1.单点更新"></a>1.单点更新</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">k += n - <span class="number">1</span>;</span><br><span class="line">dat[k] = e;</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">k = (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k] = min(dat[k*<span class="number">2</span>+<span class="number">1</span>], dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= a || b &lt;= l)<span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(a &lt;= l &amp;&amp;  r &lt;= b)<span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl = query(a, b, k * <span class="number">2</span> + <span class="number">1</span>, l, (l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr = query(a, b, k * <span class="number">2</span> + <span class="number">2</span>, (l+r)/<span class="number">2</span>, r);</span><br><span class="line"><span class="keyword">return</span> min(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sum[k];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid)built(l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid)built(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = min(sum[k&lt;&lt;<span class="number">1</span>], sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[k] += e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)update(pos,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>update(pos,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = min(sum[k&lt;&lt;<span class="number">1</span>],sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L) res = min(res,query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid)res = min(res,query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间更新"><a href="#2-区间更新" class="headerlink" title="2.区间更新"></a>2.区间更新</h2><p>这里是以区间求和为例，至于区间替换，区间求最值，可以直接把求和数组换成相应的数组就行，求最值就存放最值，区间替换就把累加变成赋值。有些题目中可不用建树，或者查询，直接更新数据，得到区间和数组即可，根据实际情况更改，至于扫描线，求面积交之类的题目，只不过把更新的对象从点变成了线段而已，最后还是转换利用点进行更新，思想基本相同。</p><p>线段树区间更新有一个很重要的思想就是<code>lazy</code>，本来我们进行区间更新的时候，应该更新所有被当前新加入的节点影响的节点，这样的递归层数比较大，时间复杂度较高，实际上我们很多节点我们并不需要知道他的数据，因此线段树的区间更新就采用了<code>lazy</code>思想，只更新需要用到的节点，也就是当前层数的数据，当前节点下面的子树不继续更新，而是用一个数据记录记录当前节点的子树需要更新的值，当我们下次递归到了他的子树时，我们检查这个节点是否有<code>lazy</code>标记，如果我们发现<code>lazy</code>标记，我们就把当前数据加上相应的标记值，然后把当前的<code>lazy</code>传递给子节点，然后取消当前标记。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[<span class="number">1000000</span>],add[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下传递lazy标记，如果是单点更新则不用乘上区间长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里为什么都是用的+而不是=，是因为虽然父节点已经更新了lazy标记，但是可能当前节点还有部分未更新</span></span><br><span class="line">sum[k&lt;&lt;<span class="number">1</span>] += add[k] * (ll)(len - (len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">add[k&lt;&lt;<span class="number">1</span>] += add[k];</span><br><span class="line">sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[k] * (ll)(len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[k];</span><br><span class="line">add[k] = <span class="number">0</span>;<span class="comment">//取消lazy标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<span class="comment">//更新当前节点的lazy标记</span></span><br><span class="line">sum[k] += e * (ll)(r-l+<span class="number">1</span>);</span><br><span class="line">add[k] += e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(add[k])pushdown(k,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L)update(L,R,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)update(L,R,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = sum[k&lt;&lt;<span class="number">1</span>] + sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">add[rt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sum[rt];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">built(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">built(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(add[k])pushdown(k,r-l+<span class="number">1</span>);<span class="comment">//只有需要用到那个区间才更新那个区间的lazy标记</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res += query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res += query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line">ll e;</span><br><span class="line"><span class="built_in">string</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">built(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span>(q == <span class="string">"Q"</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(l,r,<span class="number">1</span>,n,<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; e;</span><br><span class="line">update(l,r,e,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-离散化"><a href="#3-离散化" class="headerlink" title="3.离散化"></a>3.离散化</h2><p>当我们要更新的区间比较大超出了我们的数组的储存空间时，我们可以通过离散化来将每个区间编号。然后遍历区间的编号，并通过二分搜索找到改变编号区间的左右范围。通常我们将所有区间按照一定的规律排序便于按照我们的要求更新数据，另外还可以用去重，减少不必要的数据更新。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//将左右区间的值都放入一个数组</span></span><br><span class="line">dat[k++] = es[i].x;</span><br><span class="line">dat[k++] = es[i].y;</span><br><span class="line">&#125;</span><br><span class="line">sort(dat,dat+k);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(dat,dat+k) - dat;<span class="comment">//去重 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l = lower_bound(dat,dat+cnt,es[i].x) - dat;<span class="comment">//二分找到每个区间的范围</span></span><br><span class="line"><span class="keyword">int</span> r = lower_bound(dat,dat+cnt,es[i].y) - dat;</span><br><span class="line"><span class="comment">//在[l,r]的范围内更新相应的数据，可以根据具体的区间开闭要求更改l,r的值</span></span><br><span class="line">update(l,r,es[i].value,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>最近做题看到一个比较特别的区间求和，这里求的是所有值的<code>sin</code>函数之和，每次更新数据不再是简单的加法，需要每次都记录一下<code>sin x</code>和<code>cos x</code>的值。然后利用求和公式计算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double, double&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pdd sum[<span class="number">200000</span>],f[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">pdd <span class="keyword">operator</span>+(pdd x, pdd y)&#123;</span><br><span class="line"><span class="keyword">return</span> make_pair(x.first+y.first, x.second+y.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(pdd &amp;x, <span class="keyword">double</span> u,<span class="keyword">double</span> v)</span></span>&#123;</span><br><span class="line">x = make_pair(x.first*v + x.second*u, x.second*v - x.first*u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> z,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">double</span> u = <span class="built_in">sin</span>(z);</span><br><span class="line"><span class="keyword">double</span> v = <span class="built_in">cos</span>(z);</span><br><span class="line">add(f[k],u,v);</span><br><span class="line">add(sum[k],u,v);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L)update(L,R,z,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)update(L,R,z,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = sum[k&lt;&lt;<span class="number">1</span>] + sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">add(sum[k],f[k].first,f[k].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">f[rt].second = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">sum[rt] = make_pair(<span class="built_in">sin</span>(e),<span class="built_in">cos</span>(e));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">built(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">built(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pdd <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line">pdd res = make_pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res = query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res = res + query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">add(res,f[k].first,f[k].second);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,l,r,q,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">built(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,query(l,r,<span class="number">1</span>,n,<span class="number">1</span>).first);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;e);</span><br><span class="line"><span class="keyword">if</span>(l &lt;= <span class="number">0</span> || l &gt; n || r &lt;= <span class="number">0</span> || r &gt; n)<span class="keyword">continue</span>;</span><br><span class="line">update(l,r,e,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="1-单点更新-1"><a href="#1-单点更新-1" class="headerlink" title="1.单点更新"></a>1.单点更新</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">bit[i] += x;</span><br><span class="line">i += lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">res += bit[i];</span><br><span class="line">i -= lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间更新-1"><a href="#2-区间更新-1" class="headerlink" title="2.区间更新"></a>2.区间更新</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和为 Σbit1[i]*i + Σbit0[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit0[MAX_N],bit1[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *bit,<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">bit[i] += k;</span><br><span class="line">i += lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *bit,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">res += bit[i];</span><br><span class="line">i -= lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在区间[l,r]加上x</span></span><br><span class="line">add(bit0,l,(<span class="number">1</span>-l)*x);</span><br><span class="line">add(bit1,l,x);</span><br><span class="line">add(bit0,r+<span class="number">1</span>,r*x);</span><br><span class="line">add(bit1,r+<span class="number">1</span>,-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二维形式"><a href="#3-二维形式" class="headerlink" title="3.二维形式"></a>3.二维形式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,bit[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &lt;= n; j += lowbit(j))&#123;</span><br><span class="line">bit[i][j] += k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &gt; <span class="number">0</span>; j -= lowbit(j))&#123;</span><br><span class="line">res += bit[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;<span class="comment">//查询某个矩阵内元素之和,sum(x,y)代表(x,y)左上角矩阵之和</span></span><br><span class="line">    <span class="keyword">return</span> sum(x2,y2) - sum(x1<span class="number">-1</span>,y2) - sum(x2,y1<span class="number">-1</span>) + sum(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>polya计数</title>
      <link href="/2018/08/13/polya%E8%AE%A1%E6%95%B0/"/>
      <url>/2018/08/13/polya%E8%AE%A1%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>当我们遇到一些具有对称性的图形时，我们通常为了保证计数方案的唯一性，需要去掉一些被重复计算的方案数，<code>polya计算定理</code>就是用来解决这样的问题的，他是先计算出所有重复的方案数，将每个重复的方案计算相同的次数，最后再统一除以重复的次数，最后得到唯一的计数方案。</p><a id="more"></a><p>有一个很经典的问题就是，石头染色方案的问题。</p><blockquote><p>现有n块石头围成一圈。要用m种颜色染这n块石头，问一共有多少种不同的方法。旋转和翻转之后的方案视作一种。</p></blockquote><p>首先考虑旋转的种类，显然总共有旋转0个位置、1个位置、2个位置。。。n-1个位置等n种旋转方法。</p><p>下面计算旋转k个位置之后和原来相同的方案数。首先我们按照顺时针顺序从0。。。n-1个给石头编号。由于旋转k个位置后和原来的位置相同，所以第i个石头和第(i+k)个石头颜色相同。这么递推下去可以知道第i个石头和第(i+k<em>t)mod n个石头的颜色相同。求解`k</em>t=0(mod n)<code>最小的t。很显然，</code>t = n/gcd(k,n)`满足条件，并且是最小的。</p><p>因此我们得到了颜色相同的石头的旋转轨迹：</p><pre><code>i --&gt; (i+k) mod n --&gt; (i+2*k) mod n --&gt; ... --&gt; (i+t*k) mod n</code></pre><p>总共循环t次，所以循环节的长度为t，即<code>n/gcd(k,n)</code>。由于总个数为n，那么循环节的个数为<code>n/n/gcd(k,n) = gcd(k,n)</code>,因此循环k个位置之后的和原来相同的染色方案数为<code>m^gcd(k,n)</code>总的方案数就是循环所有位置的方案数之和，因为都重复了n次，然后除以n。</p><pre><code>{m^gcd(0,n) + m^gcd(1,n) + m^gcd(2,n) + ... + m^gcd(k,n)} / n</code></pre><p>前面是考虑的旋转之后的重复问题，我们再来看一下，翻转重复的问题。翻转重复也就是对称问题。如果两个石头位置对称那么则算他们重复，那么这种就比较简单了，我们很容易知道每次对称的重复个数为2，那么n个石头包含多少个2呢？我们再分奇偶谈论。</p><ol><li>当n为奇数时：<br>对称轴一定是经过一个点和它的对边，共有n个对称轴，假设对称轴是穿过n节点，那么在对称中n+1和n-1互换，n+2和n-2互换，这样共有<code>(n-1)/2+1</code>（对称轴穿过的点本身是一个循环节）个循环节。</li><li>当n为偶数时：<br>分情况讨论对称轴穿过两个点还是两条边。<br>两条边：n/2个置换，每个置换的循环节个数都是<code>n/2</code><br>两个点：n/2个置换，每个置换循环节个数是<code>(n-2)/2+2 = n/2+1</code></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sol</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">res += (ll)<span class="built_in">pow</span>(m, gcd(i,n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">res += n * (ll)<span class="built_in">pow</span>(m,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res += n/<span class="number">2</span> * (ll)<span class="built_in">pow</span>(m,n/<span class="number">2</span>);</span><br><span class="line">res += n/<span class="number">2</span> * (ll)<span class="built_in">pow</span>(m,n/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">res /= <span class="number">2</span>*n;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分段优化"><a href="#分段优化" class="headerlink" title="分段优化"></a>分段优化</h2><p>我们考虑到在枚举循环节的个数时，计算了n次gcd，其中有很多次都是重复的，n的因子的个数远小于n所以，有很多<code>gcd(k,n)</code>是重复的。我们要统计<code>gcd(k,n) = d</code>的k的个数，那么k一定是d的倍数，则有<code>k = d*t</code>,因此<code>d = gcd(k,n) = gcd(d*t,n)</code>,可以得到, <code>gcd(t,n/d) = 1</code>满足条件的t的个数就是欧拉函数<code>ψ(n/d)</code>。</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>这题同样可以用莫比乌斯反演来求解。。。。</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算几何</title>
      <link href="/2018/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
      <url>/2018/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
      <content type="html"><![CDATA[<p>这一部分可谓是纯粹的数学题了，异常的麻烦，变化比较多，而且特殊情况考虑比较多，代码量也很大，这里总结一些常用的模板</p><a id="more"></a><h1 id="判交问题"><a href="#判交问题" class="headerlink" title="判交问题"></a>判交问题</h1><h2 id="判断线段是否相交"><a href="#判断线段是否相交" class="headerlink" title="判断线段是否相交"></a>判断线段是否相交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inter</span><span class="params">(point a, point b, point c, point d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y) &gt; max(c.y, d.y) || min(c.x, d.x) &gt; max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> h, i, j, k;</span><br><span class="line">    h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">    i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x);</span><br><span class="line">    j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x);</span><br><span class="line">    k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x);</span><br><span class="line">    <span class="keyword">return</span> h * i &lt;= eps &amp;&amp; j * k &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断四点是否共面"><a href="#判断四点是否共面" class="headerlink" title="判断四点是否共面"></a>判断四点是否共面</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">    point <span class="keyword">operator</span> - (point &amp;o)</span><br><span class="line">    &#123;</span><br><span class="line">        point  ans;</span><br><span class="line">        ans.x = <span class="keyword">this</span>-&gt;x - o.x;</span><br><span class="line">        ans.y = <span class="keyword">this</span>-&gt;y - o.y;</span><br><span class="line">        ans.z = <span class="keyword">this</span>-&gt;z - o.z;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">dot_product</span><span class="params">(<span class="keyword">const</span> point &amp;a, <span class="keyword">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y + a.z * b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">cross_product</span><span class="params">(<span class="keyword">const</span> point &amp;a, <span class="keyword">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    point  ans;</span><br><span class="line">    ans.x = a.y * b.z - a.z * b.y;</span><br><span class="line">    ans.y = a.z * b.x - a.x * b.z;</span><br><span class="line">    ans.z = a.x * b.y - a.y * b.x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(dot_product(p[<span class="number">3</span>] - p[<span class="number">0</span>], cross_product(p[<span class="number">2</span>] - p[<span class="number">0</span>], p[<span class="number">1</span>] - p[<span class="number">0</span>])) == <span class="number">0.0</span> ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圆和多边形的面积交"><a href="#圆和多边形的面积交" class="headerlink" title="圆和多边形的面积交"></a>圆和多边形的面积交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">_point (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):x(x),y(y) &#123;&#125;</span><br><span class="line">&#125;Point,Vector;</span><br><span class="line">Point p[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point c;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">&#125;Circle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point p;</span><br><span class="line">Vector v;</span><br><span class="line">&#125;Line;</span><br><span class="line"> </span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector a, Vector b) &#123;<span class="keyword">return</span> Vector(a.x + b.x, a.y + b.y);&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector a, Vector b) &#123;<span class="keyword">return</span> Vector(a.x - b.x, a.y - b.y);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.x + a.y * b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span> <span class="params">(Vector a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span> (Dot (a, a));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.y - a.y * b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span> <span class="params">(Point a, Point b)</span> </span>&#123;<span class="keyword">return</span> Length (a - b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span> (Dot (a, b) / Length (a) / Length (b));&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span> <span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineCircleIntersection</span> <span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回线段和圆的交点个数</span></span><br><span class="line"><span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line"><span class="keyword">double</span> e = a * a + c * c, f = <span class="number">2</span> * (a * b + c * d), g = b * b + d * d - C.r * C.r;</span><br><span class="line"><span class="keyword">double</span> delta = f * f - <span class="number">4</span> * e * g;<span class="comment">//判别式</span></span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">t1 = (-f - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2</span> * e);</span><br><span class="line">t2 = (-f + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2</span> * e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slove</span> <span class="params">(Circle r, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &lt;= <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//两个顶点都在圆内，直接求三角形面积</span></span><br><span class="line">ans += Cross (p[i] - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &lt;= <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//p[i]在圆内，p[i+1]在圆外，求与圆的交点</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line">getLineCircleIntersection (L, r, t1, t2);</span><br><span class="line">t1 = t1 &gt; <span class="number">0</span> ? t1 : t2;</span><br><span class="line">Point inter;</span><br><span class="line">inter.x = L.p.x + L.v.x * t1; inter.y = L.p.y + L.v.y * t1;</span><br><span class="line">ans += Cross (p[i] - r.c, inter - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &gt; <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//p[i]在圆外，p[i+1]在圆内</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line">getLineCircleIntersection (L, r, t1, t2);</span><br><span class="line">t1 = t1 &lt; t2 ? t1 : t2;</span><br><span class="line">Point inter;</span><br><span class="line">inter.x = L.p.x + L.v.x * t1; inter.y = L.p.y + L.v.y * t1;</span><br><span class="line">ans += Cross (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (p[i] - r.c, inter - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, inter - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &gt; <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//两个点都在圆外</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line"><span class="keyword">if</span> (getLineCircleIntersection (L, r, t1, t2) &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;<span class="comment">//只有一个或者没有交点</span></span><br><span class="line">x = (Angle (p[(i + <span class="number">1</span>) % n] - r.c, p[i] - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Point inter1,inter2;</span><br><span class="line"><span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">swap (t1,t2);</span><br><span class="line">inter1.x = L.p.x + L.v.x * t1; inter1.y = L.p.y + L.v.y * t1;</span><br><span class="line">inter2.x = L.p.x + L.v.x * t2; inter2.y = L.p.y + L.v.y * t2;</span><br><span class="line">ans += Cross (inter1 - r.c, inter2 - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (p[i] - r.c, inter1 - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, inter1 - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">x = (Angle (inter2 - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2.0</span>) * r.r * r.r;</span><br><span class="line"><span class="keyword">if</span> (Cross (inter2 - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> h;</span><br><span class="line">Circle c;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;c.c.x, &amp;c.c.y, &amp;h) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> x1,y1;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf"</span>,&amp;x1, &amp;y1);</span><br><span class="line"><span class="comment">//求圆心</span></span><br><span class="line"><span class="keyword">double</span> t = <span class="built_in">sqrt</span> (h / <span class="number">5.0</span>);</span><br><span class="line">c.c.x += x1 * t;</span><br><span class="line">c.c.y += y1 * t;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;c.r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf\n"</span>,<span class="built_in">fabs</span> (slove (c, n)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含问题"><a href="#包含问题" class="headerlink" title="包含问题"></a>包含问题</h1><h2 id="点是否在三角形内"><a href="#点是否在三角形内" class="headerlink" title="点是否在三角形内"></a>点是否在三角形内</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算三角形面积 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(point p1,point p2, point p3)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y)) * <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断面积和是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(point p1,point p2, point p3, point p)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> s1 = calc(p,p1,p2);</span><br><span class="line"><span class="keyword">double</span> s2 = calc(p,p1,p3);</span><br><span class="line"><span class="keyword">double</span> s3 = calc(p,p2,p3);</span><br><span class="line"><span class="keyword">double</span> s  = calc(p1,p2,p3);</span><br><span class="line"><span class="keyword">if</span>(s == (s1+s2+s3))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点是否在多边形内"><a href="#点是否在多边形内" class="headerlink" title="点是否在多边形内"></a>点是否在多边形内</h2><h3 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a>凸多边形</h3><p>一般主要有四种方法：</p><ol><li>射线法</li><li>角度和判断法</li><li>改进弧长法</li><li>二分法</li></ol><p>前三种时间复杂度为<code>O(n)</code>,二分法时间复杂度为<code>O(logn)</code>，这里就记录一下二分法。二分法的思想是将第一个点与其余的所有边相连，得到<code>n-1</code>条射线，然后用二分搜索将点的位置确定在某两条相邻的射线之间。<br>主要有三步：</p><ol><li>判断点是否在最左一条边的左边和最右一条边的右边</li><li>二分枚举每条射线和该点与原点的连线做叉乘判断点相对该条射线的位置，然后继续往该点的方向搜索</li><li>最后把改点锁定在两条射线之间，然后该点是否在两条射线相连的边的内部<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">&#125;a[<span class="number">100005</span>],k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量叉乘 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">judge</span><span class="params">(point p1,point p2, point p3)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k.x &gt;&gt; k.y;</span><br><span class="line"><span class="comment">// 判断点是否在最左一条边的左边和最右一条边的右边 </span></span><br><span class="line"><span class="keyword">if</span>(judge(a[<span class="number">0</span>],a[<span class="number">1</span>],k) &gt; <span class="number">0</span> || judge(a[<span class="number">0</span>],a[n<span class="number">-1</span>],k) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span>, h = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; h)&#123; <span class="comment">// 二分搜索点在那两条边之间 </span></span><br><span class="line"><span class="keyword">int</span> mid = (l+h)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judge(a[<span class="number">0</span>],a[mid],k) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">h = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该点是否在两条射线相连的边的内部 </span></span><br><span class="line"><span class="keyword">if</span>(judge(a[l],a[l<span class="number">-1</span>],k) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="重心问题"><a href="#重心问题" class="headerlink" title="重心问题"></a>重心问题</h2><h3 id="判断多边形重心"><a href="#判断多边形重心" class="headerlink" title="判断多边形重心"></a>判断多边形重心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">bcenter</span><span class="params">(point pnt[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p, s;</span><br><span class="line">    <span class="keyword">double</span> tp, area = <span class="number">0</span>, tpx = <span class="number">0</span>, tpy = <span class="number">0</span>;</span><br><span class="line">    p.x = pnt[<span class="number">0</span>].x;</span><br><span class="line">    p.y = pnt[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;   </span><br><span class="line">        <span class="comment">//  point:0 ~ n - 1</span></span><br><span class="line">        s.x = pnt[(i == n) ? <span class="number">0</span> : i].x;</span><br><span class="line">        s.y = pnt[(i == n) ? <span class="number">0</span> : i].y;</span><br><span class="line">        tp = (p.x * s.y - s.x * p.y);</span><br><span class="line">        area += tp / <span class="number">2</span>;</span><br><span class="line">        tpx += (p.x + s.x) * tp;</span><br><span class="line">        tpy += (p.y + s.y) * tp;</span><br><span class="line">        p.x = s.x;</span><br><span class="line">        p.y = s.y;</span><br><span class="line">    &#125;</span><br><span class="line">    s.x = tpx / (<span class="number">6</span> * area);</span><br><span class="line">    s.y = tpy / (<span class="number">6</span> * area);</span><br><span class="line">    <span class="comment">//area = fabs(area);</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三角形相关重心"><a href="#三角形相关重心" class="headerlink" title="三角形相关重心"></a>三角形相关重心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">Point()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Point(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy)&#123;</span><br><span class="line">x=xx;</span><br><span class="line">y=yy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point <span class="keyword">operator</span>+(Point a,Point b)&#123;  <span class="comment">//向量加 </span></span><br><span class="line"><span class="keyword">return</span> Point(a.x+b.x,a.y+b.y);  </span><br><span class="line">&#125; </span><br><span class="line">Point <span class="keyword">operator</span>-(Point a,Point b)&#123; <span class="comment">//向量减</span></span><br><span class="line"><span class="keyword">return</span> Point(a.x-b.x,a.y-b.y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Point a,Point b)</span></span>&#123; <span class="comment">//求ab的长度 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(a.x-b.x)+sqr(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">gravity</span><span class="params">(Point a,Point b,Point c)</span></span>&#123; <span class="comment">// 重心  </span></span><br><span class="line"><span class="keyword">double</span> x=(a.x+b.x+c.x)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> y=(a.y+b.y+c.y)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">waixin</span><span class="params">(Point a, Point b, Point c)</span></span>&#123; <span class="comment">//外心 </span></span><br><span class="line">    <span class="keyword">double</span> a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d = a1 * b2 - a2 * b1;</span><br><span class="line">    <span class="keyword">return</span> Point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 -a2 * c1) / d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">Incenter</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;  <span class="comment">//三角形内心 </span></span><br><span class="line">     <span class="keyword">double</span> A=dis(b,c);</span><br><span class="line">     <span class="keyword">double</span> B=dis(a,c);</span><br><span class="line">     <span class="keyword">double</span> C=dis(a,b);</span><br><span class="line">     <span class="keyword">double</span> S=A+B+C; </span><br><span class="line">     <span class="keyword">double</span> x=(A*a.x+B*b.x+C*c.x)/S;</span><br><span class="line">     <span class="keyword">double</span> y=(A*a.y+B*b.y+C*c.y)/S;</span><br><span class="line"> <span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">ortho</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;  <span class="comment">//垂心 </span></span><br><span class="line"><span class="keyword">double</span> A1=b.x-c.x;</span><br><span class="line"><span class="keyword">double</span> B1=b.y-c.y;</span><br><span class="line"><span class="keyword">double</span> C1=A1*a.y-B1*a.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A2=a.x-c.x;</span><br><span class="line"><span class="keyword">double</span> B2=a.y-c.y;</span><br><span class="line"><span class="keyword">double</span> C2=A2*b.y-B2*b.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x=(A1*C2-A2*C1)/(A2*B1-A1*B2);</span><br><span class="line"><span class="keyword">double</span> y=(B1*C2-B2*C1)/(A2*B1-A1*B2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>凸包是指包含点集p中所有的点的最小凸多边形。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安德鲁算法，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point p1,point p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p1.x == p2.x)<span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line"><span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(point p1,point p2,point p3)</span></span>&#123;<span class="comment">//判断新加入的点是否和最后两个点构成逆时针</span></span><br><span class="line"><span class="keyword">return</span> ((p1.x-p3.x)*(p2.y-p3.y) - (p2.x-p3.x)*(p1.y-p3.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; u,l;</span><br><span class="line"></span><br><span class="line">sort(p,p+n,cmp);<span class="comment">//将集合中的点按照升序排序，x相同的按y坐标升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将x最小的两个点添加至u</span></span><br><span class="line">u.push_back(p[<span class="number">0</span>]);</span><br><span class="line">u.push_back(p[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//将x最大的两个点添加至l</span></span><br><span class="line">l.push_back(p[n<span class="number">-1</span>]);</span><br><span class="line">l.push_back(p[n<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建凸包上部</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = u.size(); j &gt;= <span class="number">2</span> &amp;&amp; judge(u[j<span class="number">-2</span>],u[j<span class="number">-1</span>],p[i]); j--)&#123;</span><br><span class="line">u.pop_back();<span class="comment">//一旦新加入的点和之前的点形成凹边(即为逆时针),就删除前面的边,直到构成凸包</span></span><br><span class="line">&#125;</span><br><span class="line">u.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建凸包下部</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-3</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l.size(); j &gt;= <span class="number">2</span> &amp;&amp; judge(l[j<span class="number">-2</span>],l[j<span class="number">-1</span>],p[i]); j--)&#123;</span><br><span class="line">l.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">l.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按顺时针方向生成凸包的点的序列</span></span><br><span class="line">reverse(l.begin(), l.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = u.size()<span class="number">-2</span>; i &gt;= <span class="number">1</span>; i--)l.push_back(u[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2018/08/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2018/08/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      <content type="html"><![CDATA[<p>这个莫比乌斯反演真的是把我折磨得死去活来，前前后后尝试去推导了很多次，但大部分推导都是建立在一些原有的结论和公式至上的，不够直观，加上我数学素养不好，对那些公式毫无感觉，老想找到一些简单明了的陈述，至今仍是稀里糊涂。想来也罢，不会推导就算了，好在它的公式记忆起来比较方便，加上莫比乌斯函数用算法也比较好实现。暂且就把它记下来吧。</p><a id="more"></a><h2 id="线性筛法求莫比乌斯函数"><a href="#线性筛法求莫比乌斯函数" class="headerlink" title="线性筛法求莫比乌斯函数"></a>线性筛法求莫比乌斯函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// d = 1时  mu[d] = 1</span></span><br><span class="line"><span class="comment">// d = p1 * p2 * ... * pk时  mu[d] = (-1)^k</span></span><br><span class="line"><span class="comment">// 其他情况  mu[d] = 0</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN], mu[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isprime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moblus</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])&#123;</span><br><span class="line">prime[cnt++] = i;</span><br><span class="line">mu[i] = <span class="number">-1</span>; <span class="comment">// d为单个素数时,k=1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i*prime[j] &lt;= n; j++)&#123;</span><br><span class="line">isprime[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j])mu[i*prime[j]] = -mu[i];<span class="comment">//若i为素数则k=2,与mu[i]反号,不为素数时则k=1也会反号</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">mu[i*prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是怎么到合适的反演函数，这里f(k)是我们要求的gcd(x,y) == k的个数，反演函数是F(k)表示gcd(x,y) == k的倍数的个数,F(k) = (b/i)+(d/i) (取整)</span></span><br><span class="line"><span class="comment">// 从两个区间选出两个数x,y,求gcd(x,y) == k的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN], mu[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isprime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moblus</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])&#123;</span><br><span class="line">prime[cnt++] = i;</span><br><span class="line">mu[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i*prime[j] &lt; n; j++)&#123;</span><br><span class="line">isprime[i*prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j])mu[i*prime[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">mu[i*prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    Moblus(MAXN);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        ll ans1=<span class="number">0</span>;</span><br><span class="line">        b/=k;</span><br><span class="line">        d/=k;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;d)swap(b,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)ans1+=(ll)mu[i]*(b/i)*(d/i);</span><br><span class="line">        ll ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)ans2+=(ll)mu[i]*(b/i)*(b/i);<span class="comment">//重复的部分只取一半</span></span><br><span class="line">        ans2&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans1-ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分段优化"><a href="#分段优化" class="headerlink" title="分段优化"></a>分段优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分段优化，sum是mu的前缀和</span></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt; n; i++)   sum[i] += sum[i-1];</span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    n /= d, m /= d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last = <span class="number">1</span>; i &lt;= n; i = last + <span class="number">1</span>) &#123;</span><br><span class="line">        last = min(n / (n / i), m / (m / i));</span><br><span class="line">        ans += (ll)(sum[last] - sum[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> mu[maxn];</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d,k,x;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mobius</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !vis[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * prime[j] &gt;=maxn) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>( i % prime[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">        mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)swap(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,nex;i&lt;=a;i=nex+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nex = min(a/(a/i),b/(b/i));</span><br><span class="line">        res += <span class="number">1L</span>L *(mu[nex]-mu[i<span class="number">-1</span>])*(a/i)*(b/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mobius();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        a--;</span><br><span class="line">        c--;</span><br><span class="line">        n = min(b,d);</span><br><span class="line">        ans = solve(b/k,d/k)+solve(a/k,c/k)-solve(a/k,d/k)-solve(c/k,b/k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言知识点</title>
      <link href="/2018/08/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/08/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>大一开学之前就开始接触C语言，大一上一整学期也打下一些基础，尤其对C的内部原理，内存管理方面有一些兴趣，自己零零散散也学到一些，今天才突然想起来要把这些东西给记录下来，如果后面又遇到相关的问题再来总结。</p><a id="more"></a><h1 id="一、C语言内存管理"><a href="#一、C语言内存管理" class="headerlink" title="一、C语言内存管理"></a>一、C语言内存管理</h1><p>C语言的内存管理这一块虽然我们目前使用不多，但是仍然是C语言的学习中很重要的一部分，我们在接触面向对象的语言时，基本很少看见有人提及内存管理这个词，不是没有，而是他们的内存模型比较复杂，再加上一些封装使我们的分析变得很困难，而C语言相对现在主流的一些面向对象的语言而言，更加偏向底层。同时由于C语言出现较早，应用程度很广泛，在它之后的大多数语言都有借鉴它的内存模型，所以学习C语言的内存管理对我们熟练掌握这门语言并且了解一些语言原理和构建是有很大的借鉴意义的。</p><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>C语言主要将内存划分为五部分，每部分存放的数据类型和存取规则也有所不同。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>英文名:<code>Stack</code><br>这里的栈有别与数据结构中的线性存储结构<code>栈</code>，数据结构中的<code>栈</code>是一种先进后出的限定线性存储结构。而这里的<code>栈</code>是一个内存区，是一种<strong>由到高地址向低地址扩展</strong>的数据结构。</p><p>栈区主要用来存放<strong>程序存放临时创建的局部变量</strong>，函数内部创建的局部变量都是存放在栈区里的，包括函数的形参和隐式创建的返回值等等</p><p>既然有存放的问题，那么随之而来的就是顺序问题了，存放总有一个先后顺序吧，谁先进谁后进呢？首先从大的方面来说肯定是，越早出现的肯定越早进栈，拿函数调用过程距离，首先进栈是一个地址，就是下个需要执行的程序段的地址(这个在后面介绍),紧接着是参数，也就是传入的形参，这里的形参也有一个先后顺序，一般来说是从右到左，这个具体有编译器决定，(返回值应该也会创建块内存，具体放在哪里我不清楚),然后是函数内部的局部变量，释放过程中是先释放局部变量，然后形参，最后找到那个地址所在的位置进行跳转。</p><p>栈区是自动回收内存的，所有变量都有生存周期，局部变量的生存周期一般都是在某个程序段或者函数内。随着程序段或者函数的调用结束时结束生存周期，内存也被自动回收，栈具有<strong>小内存，分配回收灵活</strong>的特点，当我们在进行递归操作时，随着递归层数的不断加深，栈区不得不保存每一层的相关信息，直到整个递归过程结束才释放所有空间，然后栈区的分配和释放空间也是需要时间，这也是为什么我们频繁调用函数时，时间开销会变大。递归这种频繁调用函数的操作不仅带来了额外的时间开销，而且可能快速填满栈区的空间，导致栈溢出。</p><p>这里简单谈一下栈区是如何找到一个函数的入口的，就是每次调用函数，栈区就把相应的临时变量分配的空间自上而下的放入到其中，但是在放入这些变量之前，还得存放一个地址，不然怎么回去勒，这个地址就是下次需要跳转的位置，那么这个地址的值是哪里来的呢？</p><p>这里还涉及到操作系统的问题，我们的编译器只是做好翻译的工作，就是把我们的C语言代码翻译成二进制文件，然而这些二进制文件要怎么执行还得交给操作系统去安排，操作系统把这份翻译好的二进制文件放入一个线程中，然后cpu再去运转它，那么什么时候放入呢？在哪里放入呢？这里就存在一个断点的问题，我们不过多讨论，就是操作系统交给cpu运行这份二进制文件时会产生一个断点，这个断点是有位置的，我们的栈区就是保存这个断点来作为函数的入口。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>英文名:<code>Heap</code><br>同样这里的<code>堆</code>也和数据结构里面的堆不同,这里的堆是一种<strong>由低地址向高地址扩展的数据结构，是一块不连续的内存区域</strong></p><p>堆区主要用来存放<strong>程序运行中动态分配</strong>的内存。什么是动态分配的内存呢？这里动态分配的内存主要指由我们程序员灵活分配的内存，是由我们分配并释放的，在<code>C</code>中我们用<code>malloc</code>函数来申请堆中的内存，<code>C++</code>中可以用<code>new</code>来申请。同样对应<code>free</code>和<code>delete</code>来释放部分空间(注意<code>malloc</code>,<code>free</code>是函数,<code>new</code>,<code>delete</code>是关键字)。这部分空间比较大，使用起来也比较灵活，但是管理起来确实很复杂的。</p><p>首先说它为什么是不连续的，我们在数据结构中接触到了链表，这里的堆的空间正是利用的这种不连续的空间，当我们申请内存的时候，我们向操作系统发送指令，然后操作系统有一个管理空余内存空间的链表，这个链表了记录计算机内部空余空间的位置，以节点的形式保存下来，我们申请的时候，操作系统就通过遍历链表的形式去查找合适的空间，如果找到一个合适的节点空间就返回这个空间的地址作为返回值给我们的函数,这个节点的空间可能会有剩余，剩余的空间地址会加入到空闲空间地址表中。</p><p>曾经还有一个问题困扰着我，就是网上的图和别人口中说的堆区和栈区都是一起的，栈由高到低，堆由低到高，那么为什么堆的空间比栈要大呢？</p><p>实际上，堆区和栈区的空间并不是连接在一起的，栈是一块连续的空间，它的大小是固定的。所以相邻变量存放的地址也是相邻的。而堆区是不连续的空间，因为堆是利用的计算机的这种零碎的空间，所以堆的空间比较大，它取决于计算机可利用的虚拟内存，一般来说是很大的。但是他们的存放结构分别是自顶向下和自底向上，这是由他们的存储结构决定的。实际上他们是不相邻的。</p><p>再说一下为什么申请的堆的空间比较慢，而栈空间的分配则要快得多，原因前面已经说过了，栈是一块连续的空间，所有它分配空间时，我可以通过直接跳转移动指针的方式去分配空间的，时间复杂度为<code>O(1)</code>,而堆则需要去查表，搜索节点。除此之外，堆区的内存维护也是一个很复杂的东西，正因为堆区是一块不连续的空间，因此难免会带来很多碎片化的空间，如何去处理这些碎片化的空间是非常复杂的，也苦了那些系统的设计者们。。。但是幸好我们不需要去做这部分工作，但是需要注意的是堆空间的释放问题，试想如果在递归调用的过程中申请了一块堆的空间，然后你又没有及时释放它，那么这个堆区的入口的指针则会一直保存下去，每到一个地方就要多维护一个指针，递归起来是很可怕的，所以及时释放我们申请的空间是很有必要的。</p><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p><code>BSS段</code>是<code>Block Started by Symbol</code>的简称,这一段是专门用来存放未被初始化或者显示初始为零的全局变量的，这一部分是和数据段”相邻的”，未被初始化的全局变量存放在BSS段，而已经初始化的全局变量则是存在数据段中的。有很多博客中这一部分都混淆不清,甚至很多都是错误的。具体的我在下面的<code>DATA段</code>中一并说明。</p><h3 id="DATA段"><a href="#DATA段" class="headerlink" title="DATA段"></a>DATA段</h3><p><code>DATA段</code>是用来存放初始化了的全局变量和静态变量，全局变量就是定义在函数外部全局都可见的变量，而静态变量则是我们人为声明的，通过<code>stastic</code>修饰的变量我们把它称作静态变量。他们是单独存放在一块区域的，他们的内存空间是在编译期间决定的，默认初始化为0。除此之外，<code>DATA段</code>还存放一些字符串常量，如<code>const char *s = &quot;hello&quot;</code>这里的字符串的值是存放在这里的，而指针还是作为一个局部变量存放在栈区中的。</p><p>顺带提一下<code>const int i = 1</code>这里的<code>i</code>是常量还是变量，它又是存放在哪里的，<code>const</code>的实现方法不同的编译器有可能不同，但是大部分编译器<code>const</code>的实现方法还是通过检查语法的形式实现的。也就是当编译器发现我们修改了<code>const</code>修饰的变量时则会报错，但实际上这里的<code>i</code>变量如果是局部变量的话，还是存放在栈区的。你可以通过以下代码验证一下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出的地址应该是连续的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来用一段代码看一下<code>BSS</code>中的全局变量,<code>DATA</code>中的全局变量的区别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];            <span class="comment">//BSS段 </span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000000</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">//BSS段 </span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1000000</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//DATA段 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你把这三个数组分别放进三个不同的源程序中运行一下，然后再去看一下他们生成的可执行文件的大小，你会发现数组c的编译成的可执行文件要大很多，而数组a和b是一样的。这就是<code>BSS段</code>和<code>DATA段</code>的一点区别，就是<code>BSS段</code>的数据是不被分配内存的，他只记录数据所需要的内存大小,<code>DATA段</code>的变量是要给数据分配内存的，而且这部分内存是包含进了可执行文件里面，而可执行文件中是不包含<code>BSS段</code>的空间的，只知道保存在它当中的数据块的大小，然后通过链接器将这部分内存连接到<code>DATA段</code>之后，这也是为什么含有数组c的可执行文件会多出那么大一部分内存。至于初始化，<code>BSS</code>的初始化是由操作系统完成的，而<code>DATA段</code>是由程序完成初始化的。</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>通常是指用来存放程序二进制机器码的一块内存区域。这部分区域的大小在程序运行前就已经确定。该部分内容可通过反汇编操作将机器码转换为汇编语言。</p><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>对于C语言这种翻译成机器代码的语言，变量名是不占内存的，他在汇编中的表示都是以(内存区地址+偏移量的形式存储的)。对于JS这种动态类型的语言是存储所有的局部变量名的。但是编译器为我们维护了一个变量表，这些变量名编译器会以字符的形式记录下来，并且记录变量对应的映射在内存中的地址。那些通过变量名的赋值操作都是编译器帮我们完成的。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>对于变量的类型，在C/C++中是通过指令解释的，通过指令来解释某一块内存以怎样的形式执行。对其他语言，一般存在额外的元数据区内。</p><h2 id="…待续"><a href="#…待续" class="headerlink" title="…待续"></a>…待续</h2>]]></content>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高斯消元法</title>
      <link href="/2018/08/10/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/"/>
      <url>/2018/08/10/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="列主元高斯消元法"><a href="#列主元高斯消元法" class="headerlink" title="列主元高斯消元法"></a>列主元高斯消元法</h2><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解Ax=b, 其中A为方阵</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">vec <span class="title">gauss</span><span class="params">(<span class="keyword">const</span> mat &amp;A, <span class="keyword">const</span> vec&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = A.size();</span><br><span class="line">mat B(n, vec(n+1));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">B[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形成增广矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">B[i][n] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="comment">// 把正在处理的未知数系数的绝对值最大的式子换到第i行 </span></span><br><span class="line"><span class="keyword">int</span> pivot = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(B[j][i]) &gt; <span class="built_in">fabs</span>(B[pivot][i]))pivot = j;</span><br><span class="line">&#125;</span><br><span class="line">swap(B[i], B[pivot]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在某个未知量系数全为零则无解或者有无穷多解</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(B[i][i]) &lt; eps)<span class="keyword">return</span> vec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把正在处理的未知数系数变为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)B[i][j] /= B[i][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i != j &amp;&amp; B[j][i] != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 从第j个式子中消去第i个未知数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt;= n; k++)B[j][k] -= B[j][i] * B[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一列的值就是方程组的唯一解 </span></span><br><span class="line"><span class="function">vec <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)x[i] = B[i][n];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全主元高斯消元法"><a href="#全主元高斯消元法" class="headerlink" title="全主元高斯消元法"></a>全主元高斯消元法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全主元在每次消去后，调整向量的位置时和所有元素进行了一次比较，可以减小误差，但时间复杂度较大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> a[][MAXN], <span class="keyword">double</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, row = <span class="number">0</span>, col = <span class="number">0</span>, index[MAXN];</span><br><span class="line">    <span class="keyword">double</span> MAXP, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)index[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (MAXP = <span class="number">0</span>, i = k; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][j] &gt; <span class="built_in">fabs</span>(MAXP)))&#123;</span><br><span class="line">                    MAXP = a[row = i][col = j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(MAXP) &lt; eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col != k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                temp = a[i][col];</span><br><span class="line">                a[i][col] = a[i][k];</span><br><span class="line">                a[i][k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            j = index[col];</span><br><span class="line">            index[col] = index[k];</span><br><span class="line">            index[k] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row != k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt; n; j++)&#123;</span><br><span class="line">                temp = a[k][j];</span><br><span class="line">                a[k][j] = a[row][j];</span><br><span class="line">                a[row][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = b[k];</span><br><span class="line">            b[k] = b[row];</span><br><span class="line">            b[row] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = k + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            a[k][j] /= MAXP;</span><br><span class="line">            <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                a[i][j] -= a[i][k] * a[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b[k] /= MAXP;</span><br><span class="line">        <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            b[i] -= b[k] * a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            b[i] -= a[i][j] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)a[<span class="number">0</span>][index[k]] = b[k];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)b[k] = a[<span class="number">0</span>][k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开关类型高斯消元"><a href="#开关类型高斯消元" class="headerlink" title="开关类型高斯消元"></a>开关类型高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开关类型的高斯消元，即都为01构成的矩阵，在消元的过程中可以直接异或运算</span></span><br><span class="line"><span class="comment">//n,m为矩阵的行和列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, r, u;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">r = i;</span><br><span class="line"><span class="keyword">while</span>(mtx[r][i] == <span class="number">0</span> &amp;&amp; r &lt; n)r++; <span class="comment">//找到首非零元 </span></span><br><span class="line"><span class="keyword">if</span>(mtx[r][i])&#123;</span><br><span class="line"><span class="keyword">if</span>(r != i)swap(mtx[r],mtx[i]);</span><br><span class="line"><span class="keyword">for</span>(u = i+<span class="number">1</span>; u &lt; n; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mtx[u][j])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; m; k++)&#123;</span><br><span class="line">mtx[u][k] ^= mtx[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回矩阵的秩,自由元个数为(n-i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>欧拉函数和欧拉定理</title>
      <link href="/2018/08/10/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%92%8C%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
      <url>/2018/08/10/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%92%8C%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><blockquote><p>欧拉函数是小于n的正整数中与n互质的数的数目</p></blockquote><a id="more"></a><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公式法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            n /= i;</span><br><span class="line">            ans *= i  - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                ans *= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        ans *= n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容斥定理</span></span><br><span class="line"><span class="comment">// 任何一个数都可以分解成为几个质数乘积的形式，那么减去所有这些质数的倍数得到就是所有互质的数，减去这些倍数的方法是容斥定理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans -= ans / i;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">        ans -= ans / n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉筛法求素数"><a href="#欧拉筛法求素数" class="headerlink" title="欧拉筛法求素数"></a>欧拉筛法求素数</h2><p>这种筛法它在当合数i可以整除质数时跳出对下一个数进行操作，比方说，当i = 4时，不会筛掉12这个数因为12找到他的最小的质因数是2，12 = 2 * 6，6定义为它相对最大的合数因子，那么4不满足这个条件，所以不在i =4 时筛掉12，而是在i = 6的时候筛掉12.这样就避免了重复操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">bool</span> isprime[MAX];</span><br><span class="line"><span class="keyword">int</span> prime[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])prime[cnt++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; prime[i]*j &lt; n; j++)&#123;</span><br><span class="line">isprime[i*prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//很关键的一步</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h2><p>筛法求欧拉函数就是在求素数的基础上，利用了几个数学结论顺带可以求出欧拉函数。<br><strong>当p为素数时:</strong></p><blockquote><p>结论一:  <code>phi(p) = p-1</code><br>结论二:  <code>phi(p^k) = p^k - p^(k-1)</code><br>结论三:  <code>如果i mod p == 0, 那么 phi(i * p) = phi(i) * p</code><br>结论四:  <code>如果i mod p != 0, 那么 phi(i * p) = phi(i) * (p-1)</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[MAX];</span><br><span class="line"><span class="keyword">int</span> prime[MAX], phi[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])&#123;</span><br><span class="line">prime[cnt++] = i;</span><br><span class="line">phi[i] = i - <span class="number">1</span>; <span class="comment">//结论一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i*prime[j] &lt;= n; j++)&#123;</span><br><span class="line">isprime[prime[j]*i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">phi[i*prime[j]] = phi[i] * prime[j]; <span class="comment">//结论三</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">phi[i*prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>); <span class="comment">//结论四</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则:</p><p><div align="center">    ![欧拉定理](/images/欧拉定理.jpg)</div><br>其中φ(n)为欧拉函数</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓展GCD</title>
      <link href="/2018/08/09/%E6%8B%93%E5%B1%95GCD/"/>
      <url>/2018/08/09/%E6%8B%93%E5%B1%95GCD/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>对于不完全为0的非负整数a，b，必定存在整数对，x，y使得方程  ax + by = gcd（a，b）成立。</strong></p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>设:</p><script type="math/tex; mode=display">a*x_{1} + b*y_{1} = gcd(a,b)\\b*x_{2} + (a\%b)*y_{2} = gcd(b,a\%b)</script><p>由$gcd(a,b) = gcd(b,a\%b)$得：</p><script type="math/tex; mode=display">a*x_{1}+b*y_{1}=b*x_{2}+(a\%b)*y_{2}</script><p>由$a\%b=a-(a/b)*b$得：</p><script type="math/tex; mode=display">a*x_{1} + b*y_{1} = b*x_{2} + [a - (a/b) * b] * y_{2}\\a*x_{1} + b*y_{1} = a*y_{2} + b * [x_{2} - (a/b) * y_{2}]</script><p>由恒等式得：</p><script type="math/tex; mode=display">x_{1} = y_{2}\\y_{1} = x_{2} - (a/b) * y_{2}</script><p>当 $b = 0$ 时 $gcd(a,b) = a$<br>此时 $x = 1,y为任意值$，为得到最小解 $y$ 取 $0$</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = exgcd(b, a%b, x, y);</span><br><span class="line"><span class="keyword">int</span> t = x;</span><br><span class="line">x = y;</span><br><span class="line">y = t - (a/b) * y;</span><br><span class="line">  <span class="comment">//    简写形式</span></span><br><span class="line">  <span class="comment">//    int r = exgcd(b, a%b, y, x);</span></span><br><span class="line">  <span class="comment">//    y -= (a/b) * x;</span></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-求解不定方程"><a href="#1-求解不定方程" class="headerlink" title="1.求解不定方程"></a>1.求解不定方程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">求解线性方程 ax + by = c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">linear_equation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = exgcd(a,b,x,y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c % d)   <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// c不为gcd(a,b)的整数倍时，方程无解 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = c / d;</span><br><span class="line">x = k * x; </span><br><span class="line">y = k * y;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 其中一组解 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通解公式为：</span></span><br><span class="line"><span class="comment">x = x1 + b/gcd(a,b) * t;</span></span><br><span class="line"><span class="comment">y = y1 - a/gcd(a,b) * t; </span></span><br><span class="line"><span class="comment">t为任意整数</span></span><br><span class="line"><span class="comment">c != gcd(a,b)时,还要乘上k </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>好像这个不定方程的通解的证明很少，这里简单证明一下：</p><blockquote><p>条件：$ax+by=gcd(a,b)$<br>结论：<br>$x=x_{0}+kb/gcd(a,b)$<br>$y=y_{0}-ka/gcd(a,b)$</p></blockquote><p>已知一组特解 </p><script type="math/tex; mode=display">ax_{0}+by_{0}=gcd(a,b)</script><p>换元：</p><script type="math/tex; mode=display">y_{0}=\frac{gcd(a,b)-ax_{0}}{b}</script><p>设</p><script type="math/tex; mode=display">x^{'}=x_{0}+i</script><p>则</p><script type="math/tex; mode=display">y^{'}=\frac{gcd(a,b)-ax^{'}}{b}=\frac{gcd(a,b)-a(x_{0}+i)}{b}=\frac{gcd(a,b)-ax_{0}}{b}-\frac{ai}{b}</script><p>又$y\in Z$且$y^{‘}\in Z$则</p><script type="math/tex; mode=display">ai/b\in Z</script><p>又$\exists d=gcd(a,b)\in Z$使得</p><script type="math/tex; mode=display">a=a^{'}d \hspace{1cm}  b=b^{'}d</script><p>其中$a^{‘}$,$b^{‘}$互质,得</p><script type="math/tex; mode=display">i=kb^{'}=kb/d\hspace{1cm}</script><p>其中$k=1,2,3…$由此我们得到$x$的通解为</p><script type="math/tex; mode=display">x=x_{0}+i=x_{0}+kb/gcd(a,b)</script><p>同理可得:</p><script type="math/tex; mode=display">y=y_{0}-ka/gcd(a,b)</script><p>证毕</p><h3 id="2-求解线性同余方程"><a href="#2-求解线性同余方程" class="headerlink" title="2.求解线性同余方程"></a>2.求解线性同余方程</h3><h4 id="引理："><a href="#引理：" class="headerlink" title="引理："></a>引理：</h4><blockquote><p>$同余方程ax\equiv b\pmod{n}对于未知数 x 有解，当且仅当 gcd(a,n)|b。且方程有解时，方程有 gcd(a,n)个解。$</p></blockquote><p>即相当于求解方程 $ax + ny = b$</p><p>设 $d = gcd(a,b)$则有</p><script type="math/tex; mode=display">a*x_{1} + n*y_{1} = d</script><p>方程两边同乘$(b/d)$得</p><script type="math/tex; mode=display">a*(a/b)*x_{1}+b*(a/b)*y_{1} = b</script><p>由恒等式得：</p><script type="math/tex; mode=display">x = (a/b)*x_{1}\\y = (a/b)*y_{1}</script><p>则同余方程 $ax\equiv b\pmod{n}$一组解为：</p><script type="math/tex; mode=display">x0 = x*(b/d) \pmod{n}</script><p>设$ans = x*(b/d)$, $s = n/d$</p><p>方程$ax ≡ b \pmod{n}$的最小整数解为：</p><script type="math/tex; mode=display">(ans\%s+s)\%s</script><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">求解同余方程 ax ≡ b(mod n)</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">modular_linear_equation</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,x0,y0;</span><br><span class="line"><span class="keyword">int</span> d = exgcd(a,n,x,y);</span><br><span class="line"><span class="keyword">if</span>(b%d != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//b不能整除gcd(a,n)时，方程无解 </span></span><br><span class="line">x0 = x * (b/d) % n; <span class="comment">//其中一组解 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通解公式为：</span></span><br><span class="line"><span class="comment">x = (x0 + (n/d)*t) mod n;</span></span><br><span class="line"><span class="comment">t 为任意正整数； </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-求模的逆元"><a href="#3-求模的逆元" class="headerlink" title="3.求模的逆元"></a>3.求模的逆元</h3><p>同余方程$ax ≡ b \pmod{n}$ 如果 $gcd(a,n)== 1$ 则方程只有唯一解。</p><p>在这种情况下，如果 $b == 1$ 同余方程就是 $ax=1 \pmod{n},gcd(a,n) = 1$</p><p>这时称求出的 $x$ 为 $a$ 的对模 $n$ 乘法的逆元。 </p><p>即$gcd(a,n) = 1$时; 求解方程$ax + ny = 1$ 中的 $x$ 即为 $a$ 对模$n$的逆元</p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  求逆元 ax = 1(mod n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modReverse</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(a, n, x, y);</span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//  无逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><p>在模意义下的除法运算中经常用到乘法逆元， 在$\mod p$的意义下我们把$x$的乘法逆元写作 $x^-1$。乘法逆元有如下的性质：</p><script type="math/tex; mode=display">x * x^{-1}\equiv 1\pmod{p}</script><p>当我们要求$x / y\equiv 1 \pmod{p}$时,就可以转化为$x * y^{-1}\equiv 1 \pmod{p}$,即求$y$的乘法逆元。这里我们我们默认$p$为质数。则用到费马小定律：</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\pmod{p}</script><p>可以写作$a\ast a^{p-2}\equiv 1\pmod{p}$这里的$a^{p-2}$正好是$a$的乘法逆元<br>因此原等式左边则可以转化为$x\ast y^{p-2}\pmod{p}$这种形式</p>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/2018/08/09/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2018/08/09/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>中国剩余定理是用来解决，一元线性同余方程组的问题：<br>形如：</p><script type="math/tex; mode=display">(S):\left\{    \begin{aligned}    x\equiv a_{1} (mod\ m_{1})\\    x\equiv a_{2} (mod\ m_{2})\\    \vdots\\    x\equiv a_{n} (mod\ m_{n})    \end{aligned}    \right.</script><p>一堆东西每次取$mi$个最后剩余$ai$个，请问这堆东西最少有多少个？</p><a id="more"></a><p><strong>中国剩余定理：</strong><br><strong>所有$mi$两两互质的前提下</strong><br>设</p><script type="math/tex; mode=display">M=m_{1}*m_{2}*...*m_{i}</script><p>即$M$为模数的乘积，设</p><script type="math/tex; mode=display">M_{i}=M/m_{i}</script><p>即$M_{i}$是除$m_{i}$以外所有模数的乘积，设</p><script type="math/tex; mode=display">t_{i} * M_{i} ≡ 1\pmod{m_{i}}</script><p>即$t_{i}$是$M_{i}$模$m_{i}$的乘法逆元，则$S$的通解为</p><script type="math/tex; mode=display">a_{1}*t_{1}*M_{i} + a_{2}*t_{2}*M_{2} + ... + a_{i}*t_{i}*M_{i} + K*M</script><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>证明过程可以参考：</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">中国剩余定理</a></p></blockquote><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求乘法逆元</span></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = exgcd(b, a%b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">1</span>)  <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无逆元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">china_remain</span><span class="params">(ll m[], ll a[], ll n)</span></span>&#123;</span><br><span class="line">    ll M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        M *= m[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ll tm = M / m[i];</span><br><span class="line">        x = exgcd(tm, m[i], x, y);</span><br><span class="line">        res = (res + x * a[i] * tm) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>中国剩余定理只适用与所有$mi$两两互质的情况下，如果存在$mi$不互质的话，是无法通过求逆元的方式推导出最后的通解公式的。所以上述问题就变成了普通的多元线性同余方程组的问题，我们可以通过两两合并同余方程的方法来求解。如：</p><script type="math/tex; mode=display">Res = k_{1}*m_{1} + a_{1}\\Res = k_{2}*m_{2} + a_{2}</script><p>合并之后有：</p><script type="math/tex; mode=display">Res = a_{1}+m_{1}*K \pmod{m_{1}*m_{2}/gcd}</script><p>其中$K$是$k_{1}*m_{1} = a_{2}-a_{1} \pmod{ m_{2}}$算出的一个特解。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>设：</p><script type="math/tex; mode=display">Res = k_{1}*m_{1} + a_{1}\\Res = k_{2}*m_{2} + a_{2}</script><p>则有</p><script type="math/tex; mode=display">k_{1}*m_{1} + a_{1} = k_{2}*m_{2} + a_{2}\\k_{1}*m_{1} = a_{2}-a_{1}\pmod{m_{2}}</script><p>令 </p><script type="math/tex; mode=display">gcd = gcd(m_{1}, m_{2})</script><p>仅当$a_{2}-a_{1} | gcd$时有解，则可以将等式两边同除$gcd$得:</p><script type="math/tex; mode=display">k_{1}*m_{1} = a_{2}-a_{1}\pmod{m_{2}/gcd}</script><p>则可以通过$exgcd$求得$k_{1}$的通解为$k_{1} = K + (m_{2}/gcd)*C$,$C$为某一整数；<br>将$k_{1}$带入原式中得：</p><script type="math/tex; mode=display">Res = m_{1}*(K + (m_{2}/gcd)*C) + a_{1}</script><p>整理得：</p><script type="math/tex; mode=display">Res = a_{1}+m_{1}*K + m_{1}*m_{2}/gcd*C</script><p>则有：</p><script type="math/tex; mode=display">Res = a_{1}+m_{1}*K\pmod{m_{1}*m_{2}/gcd}</script><p>证毕</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = exgcd(b, a%b, y, x);</span><br><span class="line">y -= (a/b)*x;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mi两两不互质的情况</span></span><br><span class="line"><span class="function">ll <span class="title">remaind</span><span class="params">(ll m[], ll r[], ll n)</span></span>&#123;</span><br><span class="line">ll M = m[<span class="number">0</span>], R = r[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">ll x, y;</span><br><span class="line">ll d = exgcd(M, m[i], x, y);</span><br><span class="line"><span class="keyword">if</span>((r[i] - R) % d)<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不能整除则无解</span></span><br><span class="line">                <span class="comment">// x 为 k1*m1 = a_&#123;2&#125;-a1 (mod m2/gcd)方程的解</span></span><br><span class="line">x = (r[i] - R) / d * x % (m[i] / d);</span><br><span class="line">R += M * x;</span><br><span class="line"><span class="comment">//M = m[i] * M / d;</span></span><br><span class="line">                M = M / d * m[i];</span><br><span class="line">R %= M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> R &gt; <span class="number">0</span> ? R : R + M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kmp算法</title>
      <link href="/2018/08/07/kmp%E7%AE%97%E6%B3%95/"/>
      <url>/2018/08/07/kmp%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>一直放了很久没去学，从别人口中感觉好像是一个很难的东西，最近遇到了相关的题目才不得不去学习它，找到了一篇非常好的博客，从头到尾下来一气呵成，瞬间感觉又多学了一种算法，顺带了很快的就A了几道相关的题目。我感觉<a href="">这篇博客</a>已经非常详细了。这里我就顺带记载一下。</p><a id="more"></a><h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里提前创建一个next数组，如果在字符串匹配过程中出现了匹配中断的情况，则直接跳到有效的位置继续匹配。</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(m)，m是子串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getnext</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = p.size();</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j &lt; len)&#123;</span><br><span class="line"><span class="comment">// 如果k还在原点，或者匹配成功则记录当前k的值即为前缀的长度 </span></span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">-1</span> || p[k] == p[j])&#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span>(p[k] != p[j])&#123;  </span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 不能出现当前字符和跳转后的字符相等，因此当前字符的跳转位置往前递归 </span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">// 否则就跳转到k的上一个位置 </span></span><br><span class="line"> k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统匹配"><a href="#传统匹配" class="headerlink" title="传统匹配"></a>传统匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">int</span> pLen = p.size();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j])&#123; <span class="comment">//匹配成功则继续匹配 </span></span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//否则就回到刚开始匹配的位置的后一个 </span></span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)<span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP匹配"><a href="#KMP匹配" class="headerlink" title="KMP匹配"></a>KMP匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为我们已经用next数组记录下了如果匹配中断的下一次能够重新匹配上的位置，所以可以一直匹配，不用回头</span></span><br><span class="line"><span class="comment">//因为i是从头扫描到尾的，不用回头，所以时间复杂度是O(n),n是父串的长度，所以总的时间复杂度是O(n+m)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">int</span> pLen = p.size();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 和普通匹配唯一的区别，遇到匹配中断是直接跳到下一个位置继续匹配，而不是从头开始 </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)<span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路径</title>
      <link href="/2018/08/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/08/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<p>常见的最短路径算法主要分为三类：<code>Dijkstra算法</code>，<code>Bellman-Ford算法</code>，<code>Floyd算法</code>，<code>SPFA算法</code>。这里简单记录一下。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>单源最短路径<br>不能解决负环<br>时间复杂度：链表和数组实现：<code>O(n^2)</code>, 堆优化：<code>O(V*lgV + E)</code></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵实现</span></span><br><span class="line"><span class="keyword">int</span> dis[MAX_V], vis[MAX_V];</span><br><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V];</span><br><span class="line"><span class="keyword">int</span> V; <span class="comment">// 顶点数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">dis[s] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//从尚未使用过的点中选取一个距离最小的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i] &amp;&amp; (index == <span class="number">-1</span> || dis[i] &lt; dis[index]))&#123;</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(index == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">vis[index] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">dis[i] = min(dis[i], dis[index] + cost[index][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通版本每次用于查找dis数组中的最小值带来和很大的时间开销，堆优化主要是用一个更好的数据结构来存储这部分数据，能够更快的找到最短距离</span></span><br><span class="line"><span class="comment">// 堆优化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> w,v; &#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P; <span class="comment">//first是最短距离，second是顶点的编号 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAX_V], vis[MAX_V];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAX_V];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过指定greater&lt;P&gt;参数,堆按照first从小到大的顺序取出值 ,也可在结构体中重置运算符 </span></span><br><span class="line">priority_queue &lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">dis[s] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">q.push(P(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">P p = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> v = p.second;</span><br><span class="line"><span class="keyword">if</span>(dis[v] &lt; p.first)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">Edge e = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(dis[e.v] &gt; dis[v] + e.w)&#123;</span><br><span class="line">dis[e.v] = dis[v] + e.w;</span><br><span class="line">q.push(P(dis[e.v], e.v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h2><p>单源最短路径<br>可以解决负环<br>时间复杂度<code>O(VE)</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> u, v, w&#125;;</span><br><span class="line"></span><br><span class="line">edge es[MAX_E]; <span class="comment">//边 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAX_V];</span><br><span class="line"><span class="keyword">int</span> V, E; <span class="comment">//V是定点数，E是边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_ford</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">bool</span> update = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">edge e = es[i];</span><br><span class="line"><span class="keyword">if</span>(dis[e.u] != INF &amp;&amp; dis[e.v] &gt; dis[e.u] + e.w)&#123;</span><br><span class="line">dis[e.v] = dis[e.u] + e.w;</span><br><span class="line">update = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!update)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回true则存在负环 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_negative_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[e.v] &gt; dis[e.u] + e.w)&#123;</span><br><span class="line">dis[e.v] = dis[e.u] + e.w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第n次仍然更新了，则存在负环</span></span><br><span class="line"><span class="keyword">if</span>(i == V - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p><code>SPFA</code>是<code>bellman_ford</code>的队列优化版本，实现原理基本相同。<br>能判断是否有负环，不能找到负环。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> next, v, w;&#125; es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAX_V], vis[MAX_V], num[MAX_E];</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组实现邻接表，head提前初始化为-1 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">es[cnt].v = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis(u) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">int</span> w = es[i].w;</span><br><span class="line"><span class="keyword">if</span>(dis[v] &gt; dis[u] + w)&#123;</span><br><span class="line">dis[v] = dis[u] + w;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt == ++num[v])<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//入队次数超过节点数则存在负环 </span></span><br><span class="line"><span class="comment">//if(!q.empty() &amp;&amp; dis[v] &lt; dis[u])&#123; // 队列非空且优于队首(SLF)</span></span><br><span class="line"><span class="comment">//q.push_front(v);</span></span><br><span class="line"><span class="comment">//&#125;else&#123;</span></span><br><span class="line"><span class="comment">//q.push_back(v);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">q.push(v);</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>任意两点最短路径<br>可以解决负环<br>时间复杂度：<code>O(n^3)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)&#123;</span><br><span class="line">d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>差分约束问题一般形如下面这样的不等式组问题：</p><div align="center">![](/images/差分约束1.png)</div><p>通常我们可以把它转化成一个图论的问题，<code>x1 - x2 &lt;= c</code>，可以构建一条以x2到x1，权值为c的一条边。</p><div align="center">![](/images/差分约束2.png)</div><p>这样我们就把这个不等式组的问题转换成了一个图论问题。但是我们要如何求解呢？</p><p><center>B - A <= c="" (1)<="" center=""></=></center></p><p><center>C - B <= a="" (2)<="" center=""></=></center></p><p><center>C - A <= b="" (3)<="" center=""><br>我们想要知道<code>C - A</code>的最大值，通过(1) + (2)，可以得到 <code>C - A &lt;= a + c</code>，所以这个问题其实就是求<code>min{b, a+c}</code>。</=></center></p><p><div align="center">![](/images/差分约束3.png)</div><br>我们发现min{b, a+c}正好对应了A到C的最短路，而这三个不等式就是著名的<strong>三角不等式</strong>。将三个不等式推广到m个，变量推广到n个，<strong>就变成了n个点m条边的最短路问题了</strong>。</p><p>求<code>C - A</code>的最大值为什么又变成了最短路径了呢？其实很简单，在这个不等式的解是一定要满足整个不等式组的，那么如果现在有两个式子<code>C - A &lt;= 1</code>和<code>C - A &lt;= 2</code>，那么<code>C - A</code>的最大值是多少呢？没错，就是<code>1</code>。所以同理，<code>max(xi - xj)</code>就是求满足整个不等式条件下的最大值，而也正好是图中两点之间的最短路径，这里的最短路径也可以理解为，将路径压缩至最短后需要满足的最低限度的要求。</p><p>通常为了方便求出满足该不等式的一组解，我们选择假如一个起点，该起点到每个点的距离都为0，也就是<code>xi - x0 = 0</code>,在求出最短路径之后则有<code>xi - x0 &lt;= 0</code>此时的<code>x0</code>到每个点的距离正好是该不等式组的一组解。</p><p>当求解最短路径时存在负环，则说明该不等式组无解，对应不等式中出现了两个不等式不能同时满足，则出现死循环。</p><p>做题时可能会遇到不等式中的符号不相同的情况，但我们可以对它们进行适当的转化:</p><p>1&gt; 方程给出：X[n-1]-X[0]&gt;=T ,可以进行移项转化为： X[0]-X[n-1]&lt;=-T。<br>2&gt; 方程给出：X[n-1]-X[0]<t, 3="" 可以转化为x[n-1]-x[0]<="T-1。"> 方程给出：X[n-1]-X[0]=T，可以转化为X[n-1]-X[0]&lt;=T&amp;&amp;X[n-1]-X[0]&gt;=T，再利用(1)进行转化即可</t,></p><p>对于不同的题目，给出的条件都不一样，我们首先需要关注问题是什么，如果需要求的是两个变量差的最大值，那么需要将所有不等式转变成”&lt;=”的形式，建图后求最短路；相反，如果需要求的是两个变量差的最小值，那么需要将所有不等式转化成”&gt;=”，建图后求最长路。</p><h3 id="次短路和最短路条数"><a href="#次短路和最短路条数" class="headerlink" title="次短路和最短路条数"></a>次短路和最短路条数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是要求两条最短路径之和，要求两条路径不同。</span></span><br><span class="line"><span class="comment">则有两种情况：</span></span><br><span class="line"><span class="comment">最短路径的数目大于1条则为最短路的两倍：res = 2*dist[n]</span></span><br><span class="line"><span class="comment">最短路径只有一条则为最短路加次短路：res = dist1[n] + dist2[n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> v,w; &#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; G[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">100001</span>],dist2[<span class="number">100001</span>],sum[<span class="number">100001</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">G[u].push_back(edge&#123;v,w&#125;);</span><br><span class="line">G[v].push_back(edge&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt;q;</span><br><span class="line"><span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(dist2,INF,<span class="keyword">sizeof</span>(dist2));</span><br><span class="line">dist[s] = <span class="number">0</span>;</span><br><span class="line">sum[s] = <span class="number">1</span>;</span><br><span class="line">q.push(P(<span class="number">0</span>, s));</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">P u = q.top(); q.pop();</span><br><span class="line"><span class="keyword">int</span> v = u.second;</span><br><span class="line"><span class="keyword">if</span> (dist2[v] &lt; u.first)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e = G[v][i];</span><br><span class="line"><span class="keyword">int</span> d2 = dist[v] + e.w;</span><br><span class="line"><span class="keyword">if</span> (dist[e.v] &gt; d2)</span><br><span class="line">&#123;</span><br><span class="line">sum[e.v] = sum[v];<span class="comment">//如果可以更新，当前最短路的条数则继承前一个节点数的 </span></span><br><span class="line">swap(dist[e.v], d2);</span><br><span class="line">q.push(P(dist[e.v], e.v));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dist[e.v] == d2)&#123;</span><br><span class="line">sum[e.v] += sum[v];<span class="comment">//如果松弛后权值相等，则最短路数目相加 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)<span class="comment">//求次短路 </span></span><br><span class="line"><span class="keyword">if</span> (dist2[e.v] &gt; d2 &amp;&amp; dist[e.v] &lt; d2)</span><br><span class="line">&#123;</span><br><span class="line">dist2[e.v] = d2;</span><br><span class="line">q.push(P(dist2[e.v], e.v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; sum[n] &lt;&lt; endl;//最短路条数</span></span><br><span class="line"><span class="keyword">if</span>(sum[n] &gt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">2</span>*dist[n];</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> dist[n] + dist2[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>,x,y,z;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line">res = solve(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(res != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>,<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flask实战</title>
      <link href="/2018/08/04/flask%E5%AE%9E%E6%88%98/"/>
      <url>/2018/08/04/flask%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>最近因为打算做暑期答辩的过程中需要搭建一个小的用户服务器，了解到了<code>python</code>里面的<code>flask</code>框架,就趁着这个机会找了一个<code>github</code>上一个基于<code>flask</code>框架搭建的博客项目，从零开始，其中包括了<code>项目环境的配置</code>、<code>功能板块的实现</code>、<code>后台逻辑的实现</code>、<code>数据库逻辑的设计和数据的迁移</code>、<code>各种api接口的调用</code>、<code>项目的重构</code>等等。这里简单记录一下一些从中得到的一些体会和收获。</p><a id="more"></a><h2 id="python的库"><a href="#python的库" class="headerlink" title="python的库"></a>python的库</h2><p>之前一直知道python有很多功能强大的函数库，然后可以利用这些函数库很方便的实现一些功能。之前用pygame库做了一个小游戏。里面基本都是基于pygame提供的函数实现的。也基本没有用到其他的函数库，所以体会不是很深，这次的web实战用到了大量的的函数库或者说是包。我自己也在这个项目中实现了一些包的封装。对包的结构也有了进一步的了解。</p><h3 id="1-什么是库"><a href="#1-什么是库" class="headerlink" title="1.什么是库"></a>1.什么是库</h3><p>我们也通常把python的函数库称为包。我这里划分的不是以标准库和第三方库为界限的。我认为这里主要有两种类型的库。</p><h4 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h4><p>一种是完全用python代码实现的一些特定功能的类和函数的集合，像一种python的原生库。相当于那些库的创造者们为了实现特定的功能为我们定义了大量的函数和变量。然后用一种较为规范的方式封装起来方便我们调用。例如<code>pygame</code>，为了解决我们游戏设计中的一些基本问题，他把那些创建游戏界面，游戏中的对象，如何插入图片，对象运动的轨迹都提前写好封装到了类中，当我们需要调用的时候，就可以继承他封装的类，然后获得一些属性，这里的属性其实就是他为你写好的方法，你通过继承的形式获得了。又比如<code>jieba</code>，<code>random</code>，这种更偏向于C++当中的<code>stl</code>，解决我们在编程过程中遇到的一些常见的问题。<code>jieba</code>是一个分词库，能够将一些连续的文本信息进行自动划分并统计词频。在需要进行数据处理时使用相当便捷。<code>random</code>是用来创建随机数的，这个应用程度更加广泛。</p><h4 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h4><p>另一种库更像一种粘合工具，在我们的实际生产中单纯的一门语言是绝对不够的。我们需要使用大量的工具。就拿网站开发距离，前端界面是一块，后台逻辑是一块，数据存储是一块，然后还需要一些外界的api接口，与其他的应用进行交互等等。但是每一个板块的工具的使用方法不尽相同，标准也层次不齐。函数的使用方法命名习惯也都不一样，因此对那些工具的使用方法进行规范统一是十分必要的。</p><p>所以我们再python的库中可以看到很多熟悉的名字，<code>PyQt</code>,<code>elasticsearh</code>,<code>MySQL</code>,这些库主要功能并不是实现功能，更多的是方便使用，<code>Qt</code>是一门基于C++的常用的可视化框架，但如何在python当中使用呢，这时我们就需要用到这种库来进行粘合，<code>elsticsearch</code>是目前比较流行的一个搜索引擎，在很多地方都可以引入它到自己的项目当中。而与他同名的python库主要是对<code>elasticsearch</code>的使用起到了一个封装的作用。他原有的创建索引的方式较为复杂，python当中的<code>elasticsearch</code>起到了一个客户端的作用，让数据以一种更方便python语言调用的方式重写了原有的方法。他接受python当中传入的数据经过整合处理再告诉引擎要如何去调用。<code>MySQL</code>也是一样接受python传入的数据到他封装好的函数中再去调用相应的sql语句去处理更新数据库中的数据。</p><p>正是python拥有这种丰富工具库才让我们可以仅仅通过python的语法去使用各种功能强大的工具。功能强大的函数库也正是python最鲜明的特色之一。</p><h3 id="2-库的结构"><a href="#2-库的结构" class="headerlink" title="2.库的结构"></a>2.库的结构</h3><p>这里我把他称作<strong>包</strong>更为合适，因为我需要讨论的是它的物理结构。我发现初学者和我一样，对于那些封装好的包的结构一无所知。只知道要以一种怎样的方式去使用它。有时候打开电脑的文件夹看着各种奇怪的英文名称和嵌套的文件结构，奇怪的文件后缀一脸茫然，可能一不小心删掉了某个文件，或者更改了文件的路径就导致整个应用无法运行。因此简单了解这些包的结构也是有一定必要的。</p><p>我们可以去查看一下我们的python文件夹下到底有什么东西，可能我们从下载python解释器开始就再没有打开过了，那它里面到底有些什么东西呢？<br><code>DLLs</code>,<code>Lib</code>,<code>Scripts</code>,<code>include</code>,这是python目录下的主要几个文件夹。<code>include</code>里面就是类似c语言中的头文件的一些东西。我们也可以自己编写这些头文件，然后进行封装，然后会产生一个<code>dll</code>的文件，这一个专门的连接文件,我们在很多地方可以看到他，一般一些文件经过封装之后都会产生一个这个文件，<code>DLLs</code>文件夹就是专门用来存放这种类型的文件的。<code>Lib</code>是我们的导入的包存放的地方，我们从网上下载的各种包都存放在这个里面。<code>Scripts</code>是一个专门用来存放可执行文件的地方,python里面很多脚本文件都在里面，比如我们经常用的<code>pip</code>,<code>easy_install</code>，我们可以直接调用他们来完成一些功能。这些脚本文件都是经过封装的，在他们未被封装之间也是一个python文件，通过打包的形式，将python文件中需要用到的一个头文件部分都单独分离开单独打包成一个脱离于python解释器的可执行文件。大部分<code>.exe</code>文件都是通过这种打包的形式而来的。</p><h2 id="项目的结构优化"><a href="#项目的结构优化" class="headerlink" title="项目的结构优化"></a>项目的结构优化</h2><p>之前经常听人提起，或者在网上听到各种有关项目重构的话题，这次的学习中也算了解到了一点项目重构的具体内容。</p><p>对于一个项目随着用户量的增加和后期的持续开发，一个好的项目架构是极其重要的。一些前期看来清晰的项目结构也会随着各种函数和功能的增多变得杂乱不堪。这里暂且记录一下我从这个项目中学到的一些对于项目可拓展性和可维护性的一些技巧。</p><h3 id="1-代码的重用"><a href="#1-代码的重用" class="headerlink" title="1.代码的重用"></a>1.代码的重用</h3><p>在代码的可重用性这方面，<code>flask</code>正是在这方面有很大的优势，<code>flask</code>提供的大都是一些偏基础的方法，也正是基于这个原因，它的拓展性很高。在我做的这个网站项目里面大量封装了它的一些方法，通过自己的一些封装和改写，使得它的一些原生的方法得到很多的拓展。</p><p>在我们项目的开发的过程中最常见的一个问题就是代码量过大，逻辑杂乱无章，无法维护，通过提高的代码的重用是一个好的项目必须要考虑的一件事，我们不希望在一个项目中相同的功能的代码出现两次，因此我们需要做的就是尽可能的抽离一些实现基础功能的代码。因此使用频率最高的代码，对象等应当处于较底层的位置，随着功能的拓展再依次往上封装。</p><p>这里我具体遇见的有这么几种情况：</p><h4 id="前端代码的重用"><a href="#前端代码的重用" class="headerlink" title="前端代码的重用"></a>前端代码的重用</h4><p>前段界面的代码调用率是非常高的，而且代码量也非常大，因此每个界面的的前段代码相互独立是极不明智的，我们的每个界面的大致排版和设计应该相同的，因此我们我们完全可以把页面一些主体的代码部分放在一部分，然后其他界面都在此基础上添加少量特有的部分，这种方法极大简化了各种复杂的界面的代码简洁性。</p><h4 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h4><p>在一个项目中，基本没有代码是单独出现的，都是封装在类或者函数当中的。因此我们应当尽可能的使用继承的方式来创建和实现一个具体的功能板块，当我们增加新的功能板块时需要用到原有的对象的时，我们就可以直接从封装好的包中导入相应的对象，在原有的方法的基础上再继续封装新的函数来实现新的功能。</p><p>因此我们经常遇到的情况就是，在一个类和方法在向上封装的过程中，不断地改写代码，将原有的的类和方法中具体的值次封装成新的对象和方法。当再在此基础上拓展时，则继续向上封装。</p><h3 id="2-全局变量的设置"><a href="#2-全局变量的设置" class="headerlink" title="2. 全局变量的设置"></a>2. 全局变量的设置</h3><p>在一个项目的初期，我们倾向于包所有的包和模块放在一起把一些包中导入的应用实例设置为一个全局的变量，当我们需要调用时，直接从包中调用该实例来创建对象。但在测试和应用阶段，随着配置的环境的改变，改模块的应用发生改变，则会导致部分全局变量无法被实例化，因此给项目带来了一定的局限性。</p><p>所以我们应当尽量避免不将应用设置为全局变量，而是在实际运行过程中动态的去创建它，这样就可以根据环境配置的改变去动态的创建不同的应用实例。通常我们可以采用将这些应用的创建写进一个函数中进行统一的加工处理和创建。</p><h3 id="3-模块的分布"><a href="#3-模块的分布" class="headerlink" title="3.模块的分布"></a>3.模块的分布</h3><p>为了进一步的提升代码的可重用性，将相对集中的模块功能细化是一个很好的选择，将功能相对特殊的模块单独分离开来，尽量利用原有的模块的基础上去创建新的模块，考虑到兼容性和可拓展性，可在原有基础之上重写代码，使原有的模块的可拓展性更高。</p><p>考虑到项目的定位和需求，提前指定大概需要的功能板块，预留详细的接口和方法。适当引入合适的模块和api接口也是拓展项目板块的重要途径。</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>环境变量是个啥</title>
      <link href="/2018/08/03/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%AA%E5%95%A5/"/>
      <url>/2018/08/03/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%AA%E5%95%A5/</url>
      <content type="html"><![CDATA[<p>我相信很多人和我之前一样，每次学习一门语言或者安装一个新的软件之前很多都需要提前配置环境，但事实上每次都是按照网上直白的教程一步步的去做，至于为什么要这么做，这么做的作用是什么毫无头绪。甚至一不小心弄错了一步接下来又是一大串未知的错误。环境变量的配置更是其中十分常见的一个东西。那么<code>环境变量</code>到底是个啥？这里我就简单根据我的了解谈一谈一直困扰我们的<code>环境变量</code>。</p><a id="more"></a><h3 id="1-哪里有环境变量"><a href="#1-哪里有环境变量" class="headerlink" title="1.哪里有环境变量"></a>1.哪里有环境变量</h3><p>这里让我们用几个实际的例子来看一下具体什么地方有环境变量：</p><h4 id="python中的环境变量"><a href="#python中的环境变量" class="headerlink" title="python中的环境变量"></a>python中的环境变量</h4><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量1.png" width="900" height="600" alt="环境变量1" align="center"></div><p>我们刚安装<code>python</code>的时候如果你忘记在安装的过程中把<code>python</code>添加到环境变量中，你就应该自己手动添加了。</p><h4 id="windows系统中的环境变量"><a href="#windows系统中的环境变量" class="headerlink" title="windows系统中的环境变量"></a>windows系统中的环境变量</h4><p>这是我们windows系统下设置环境变量的地方，我们所有的环境变量都存放在这里，里面有很多都是系统已经设置好的变量，比如一些系统初始化需要的路径，加载显卡，和声明用户使用权限等等。</p><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量2.png" width="400" height="400" alt="环境变量2" align="center"></div><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量3.png" width="400" height="400" alt="环境变量3" align="center"></div><h3 id="2-环境变量的类型"><a href="#2-环境变量的类型" class="headerlink" title="2.环境变量的类型"></a>2.环境变量的类型</h3><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>其实一般我们使用过程中这两者差距不大，用户变量是针对我们当前用户的，我们的windows系统可以设置多个用户的。那么不同用户之间肯定也有独立的设置。如果你将你的环境变量设置在用户变量中，那么登录你计算机的其他用户就无法使用这个环境变量。</p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>一般系统变量是只有<code>Administrator</code>权限的用户才能设置，也就相当于<code>Linux</code>中的<code>root</code>权限的用户。在系统变量中设置的环境变量是对计算机中所有用户都有效的，但是有时为了不相互干扰，我们通常将环境变量设置在用户变量中，由于我们的计算机一般都是只创建了单个用户，所以不存在这个问题。对我们而言这里的用户变量和系统变量的功能是相同的。</p><h3 id="3-环境变量的配置"><a href="#3-环境变量的配置" class="headerlink" title="3.环境变量的配置"></a>3.环境变量的配置</h3><p>这里以windows下举例:</p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><p>在windows操作系统中可以通过我的电脑-&gt;系统属性-&gt;高级系统设置-&gt;环境变量，来设置系统的环境变量.这种方式比较直观.<br>那么我通过在图像界面添加的这种环境变量到底给计算机带来什么变化呢?其实我们的windows操作系统只不过将很多类似的操作都用图形界面的形式呈现给我们了。但是在windows下层是有一个叫注册表的东西。我们很多基于图形界面的操作其实都是修改了对应注册表目录下的文件内容。同样的道理，这里我们在系统设置里面修改或添加的环境变量其实都是添加到了注册表的相应文件的，我们下载的应用也都是要在注册表内登记配置的。而我们的应用需要用到这个变量的时候也是直接在注册表中调用的，所以我们很多软件安装过程中的错误其实都是由于注册表中的配置不对，导致一些文件路径无法识别，从而导致应用无法找到存在在我们计算机上的相应资源。</p><p>windows的注册表相对属于底层的东西，因此我们绝对多数无法通过图形界面修改的设置，都可以通过修改注册表的相关目录的内容来完成。它的隐蔽性保证了我们不会通过一些误操作导致系统崩溃。但是也给我们对计算机灵活运用产生了一些阻碍。</p><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>我们还可以用一种更为简洁的方式来设置环境变量，那就是直接通过打开windows的命令行来实现。<br><code>set</code>：查看所有的环境变量<br><code>set PATH</code>：查看某种类型的环境变量(如 <code>PATH</code>)<br><code>set xxx = &quot;date&quot;</code>:添加一个环境变量<br>请注意：<strong>通过命令行设置的环境变量只对当前窗口有效</strong>，也就是你关闭了dos窗口下次再打开的时候是不起作用的。</p><h3 id="4-环境变量的使用"><a href="#4-环境变量的使用" class="headerlink" title="4.环境变量的使用"></a>4.环境变量的使用</h3><p>最后一个问题就是，既然环境变量随处可见，我们也经常需要用到环境变量，但是具体在系统或者应用项目中是如何去使用它的呢？也就是这些变量是如何被调用的，用在哪里？</p><h4 id="引入环境变量"><a href="#引入环境变量" class="headerlink" title="引入环境变量"></a>引入环境变量</h4><p>这里来看看我的网站项目后台代码是具体怎么调用这些环境变量的。</p><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量4.png" width="900" height="450" alt="环境变量4" align="center"></div>这里是我网站的一个项目配置文件，就是专门用来从我的本地上调用环境变量的，这里我专门用一个文件来调用了，其他模块需要用到的时候，直接导入整个配置文件即可。这是一个很好的习惯，有时候你可能会习惯哪里需要用到某个变量的时候再直接去调用，这样环境变量的分布将变得杂乱不堪。单独创建一个文件来配置所有的环境变量是一个很好的方法。#### 项目中的配置再来看看我这个文件到底干了什么。我首先导入一个`os`模块，这是python的一个标准函数库，专门用来执行和系统有关的操作，调用系统的一些文件。然后我加载了一个`.env`的文件，这个文件等下再介绍。后面就是所有我需要用到的环境变量了。其中主要包含三个部分，连接数据库需要的`用户名`，`密码`，`链接`，和我的发送邮件板块需要用到的`端口`，`代理`，`邮件名`，`密码`,还有我调用的搜索引擎需要用到一些变量。很明显这些变量都是一些固定值，所以我们必须把它们存在我们本地，然后通过调用的形式去使用它。我把这些用一个类封装起来了，下次有地方需要用的时候就可以通过创建这个类的实例来使用了。`os.environ.get()`函数是`os`模块中提供的一个函数用来从本地调取环境变量。然后赋值给类中的变量，完成环境变量的调用。那么我又是怎么使用这些变量的呢？<div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量5.png" width="900" height="350" alt="环境变量5" align="center"></div><h4 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h4><p><code>app</code>模块是我这个项目的主模块，这是<code>app</code>模块中的初始化文件中的一部分代码。这里我通过<code>app.config[&#39;xxx&#39;]</code>来完成从上面的文件中调用环境变量，<code>config</code>是我就是我上面<code>Config</code>类所在的文件，也是app子目录下面的一个文件，因为我在这个文件中创建了<code>Config</code>类的实例，所以这里可以调用上面那个类从系统调用的环境变量，在实例化的过程中将他们配置到了我的网站项目中。这样就完成了环境变量从本地到我的项目的转移。这样在我的这个项目实例中，就可以开始使用这些变量了。那现在我们就来看一下环境变量最后在我的邮件发送函数中的具体应用吧。</p><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量7.png" width="900" height="250" alt="环境变量7" align="center"></div><p>这个就是我用来发送邮件的函数，有了前面的铺垫，这里是不是显得特别的简洁。这里我简单的加载了我<code>send_mail</code>函数需要用到的几个参数，分别是<code>sender</code>,<code>recipients</code>,<code>text_body</code>,<code>html_body</code>,发送人就是前面我在环境变量中设置的我自己的邮箱，收件人是一个变量，是实时传入的参数中获取的，然后就是我邮件的文本内容，和<code>html</code>代码用来渲染我的文本内容。最后就可以将邮件通过<code>send_mail</code>函数发送出去啦，<code>send_mail</code>是我使用的python某个函数库中的一个函数，至于它是怎么发送的我们就不用管了。</p><p>这里我就简单的介绍完了，整个环境变量从我们的本地设置到项目中到最后实际使用的整个流程了，虽然各个应用的使用方式可能有所不同，但是大体的流程就是一样的。先从本地加载需要用到的环境变量部署到应用的某个模块中，然后具体某个模块需要用到的时候再去调用它，把它们放进某个参数当中，实现某个功能。</p><h4 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a>.env文件</h4><p>最后一个遗留的问题就是<code>.env</code>文件，这到底是干啥的。这种只有后缀的文件一般是看不见的，都是隐藏的文件，在命令行和<code>shell</code>中通过加<code>-a</code>的参数来显示他们。</p><div align="center"><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/环境变量6.png" width="900" height="400" alt="环境变量6" align="center"></div><p>这是一个专门用来存储环境变量的文件，其实和你在电脑本地设置环境变量是一样的，只不过你在电脑上设置的环境变量是存储在你的计算机本地上的。而这里是存在<code>.env</code>文件中的。所以我们经常将一些变量设置在这个文件当中，需要使用的时候就可以直接从这个文件中调用了，不用再从你的计算机中去找了。但是有些有些环境变量是不能提前预知的，比如你的python解释器在你电脑中的安装目录，这个你是可以任意更改的，所以无法将他们提前写到放进<code>.env</code>文件，只能实时的安装过程中去配置它。</p>]]></content>
      
      
        <tags>
            
            <tag> 扫盲 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hashlib库</title>
      <link href="/2018/07/22/hashlib%E5%BA%93/"/>
      <url>/2018/07/22/hashlib%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="1. 常用属性"></a>1. 常用属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashlib.algorithms_available</span><br><span class="line">h.block_size</span><br><span class="line">h.digest_size</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash.new([arg])     <span class="comment">#创建指定加密模式的hash对象</span></span><br><span class="line">hash.update(arg)    <span class="comment">#更新哈希对象以字符串参数。如果同一个hash对象重复调用该方法，m.update(a); m.update(b) 等价于 m.update(a+b)</span></span><br><span class="line">hash.digest()       <span class="comment">#返回摘要，作为二进制数据字符串值。</span></span><br><span class="line">hash.hexdigest()    <span class="comment">#返回摘要，作为十六进制数据字符串值</span></span><br><span class="line">hash.copy()         <span class="comment">#复制</span></span><br></pre></td></tr></table></figure><h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">print(hashlib.algorithms_available)</span><br><span class="line"></span><br><span class="line">sha = hashlib.sha256()</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">'hello'</span></span><br><span class="line">str2 = <span class="string">"world"</span></span><br><span class="line">sha.update(str1.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">sha.update(str2.encode(<span class="string">"'utf-8"</span>))</span><br><span class="line"></span><br><span class="line">print(sha.block_size)</span><br><span class="line">print(sha.digest_size)</span><br><span class="line">print(sha.digest())</span><br><span class="line">print(sha.hexdigest())</span><br><span class="line">print(hashlib.new(<span class="string">"sha256"</span>,<span class="string">"helloworld"</span>.encode(<span class="string">'utf-8'</span>)).hexdigest())</span><br><span class="line"></span><br><span class="line">shaa = sha.copy()</span><br><span class="line">print(shaa.hexdigest())</span><br></pre></td></tr></table></figure><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hashlib_1.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 函数库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jieba库</title>
      <link href="/2018/07/21/jieba%E5%BA%93/"/>
      <url>/2018/07/21/jieba%E5%BA%93/</url>
      <content type="html"><![CDATA[<p><code>jieba</code>库是python的一个第三方中文分词库，<code>jieba</code>支持三种分词模式，<code>精确模式</code>,<code>全模式</code>,<code>搜索引擎模式</code>。</p><p><code>精确模式</code>：试图将语句最精确的切分，不存在冗余数据，适合做文本分析<br><code>全模式</code>：将语句中所有可能是词的词语都切分出来，速度很快，但是存在冗余数据<br><code>搜索引擎模式</code>：在精确模式的基础上，对长词再次进行切分</p><a id="more"></a><h2 id="1-分词"><a href="#1-分词" class="headerlink" title="1. 分词"></a>1. 分词</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">words = jieba.cut(<span class="string">"他来到了网易杭研大厦"</span>)</span><br><span class="line">print(<span class="string">"/"</span>.join(words))</span><br></pre></td></tr></table></figure><p><code>他/来到/了/网易/杭研/大厦</code></p><h2 id="2-加入自定义词典"><a href="#2-加入自定义词典" class="headerlink" title="2. 加入自定义词典"></a>2. 加入自定义词典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jieba.load_userdict(<span class="string">"dict.txt"</span>)</span><br><span class="line">words=jieba.cut(<span class="string">"他来到了网易杭研大厦"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"/"</span>.join(words)</span><br></pre></td></tr></table></figure><p><code>他/来到/了/网易杭研/大厦</code></p><p>自定义词典’dict.txt’中的内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">杭研大厦 <span class="number">100</span> n</span><br></pre></td></tr></table></figure></p><p>自定义的词典一行上面有三列，第二个是指出现的次数，第三个是词性</p><h2 id="3-动态修改词典"><a href="#3-动态修改词典" class="headerlink" title="3. 动态修改词典"></a>3. 动态修改词典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words =jieba.cut(<span class="string">"我们中出了一个叛徒"</span>,HMM=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment">#jieba.suggest_freq(('中出'),True)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'/'</span>.join(words)</span><br></pre></td></tr></table></figure><p><code>我们/中/出/了/一个/叛徒</code><br><code>我们/中出/了/一个/叛徒</code></p><p>使用 suggest_freq(segment, tune=True) 可调节单个词语的词频，使其（或不能）被分出来。</p><h2 id="4-关键词提取、词性标注"><a href="#4-关键词提取、词性标注" class="headerlink" title="4. 关键词提取、词性标注"></a>4. 关键词提取、词性标注</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg </span><br><span class="line"></span><br><span class="line">words=pseg.cut(<span class="string">"我爱北京天安门"</span>)</span><br><span class="line"><span class="keyword">for</span> word ,flag <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s %s'</span> %(word,flag))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我 r </span><br><span class="line">爱 v</span><br><span class="line">北京 ns</span><br><span class="line">天安门 ns</span><br></pre></td></tr></table></figure><h2 id="5-三种模式的分词"><a href="#5-三种模式的分词" class="headerlink" title="5. 三种模式的分词"></a>5. 三种模式的分词</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">seg_str = <span class="string">"好好学习天天向上"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.cut(seg_str)))    <span class="comment"># 精简模式，返回一个列表类型的结果</span></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.cut(seg_str, cut_all=<span class="keyword">True</span>)))      <span class="comment"># 全模式，使用 'cut_all=True' 指定 </span></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.cut_for_search(seg_str)))     <span class="comment"># 搜索引擎模式</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好好学习/天天向上</span><br><span class="line">好好/好好学/好好学习/好学/学习/天天/天天向上/向上</span><br><span class="line">好好/好学/学习/好好学/好好学习/天天/向上/天天向上</span><br></pre></td></tr></table></figure><p><strong>jieba分词的简单应用</strong></p><ol><li><p>对文本进行分词，统计词频</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line">txt = open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line">words = jieba.cut(txt)</span><br><span class="line"></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> len(word) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[word] = counts.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">items = list(counts.items())</span><br><span class="line"></span><br><span class="line">items.sort(key = <span class="keyword">lambda</span> x : x[<span class="number">1</span>], reverse = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    print(word, <span class="string">"   "</span>, count)</span><br></pre></td></tr></table></figure></li><li><p>英文单词统计</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">()</span>:</span></span><br><span class="line">    txt = open(<span class="string">"1.txt"</span>, <span class="string">"r"</span>).read()</span><br><span class="line">    txt = txt.lower()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'!"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_‘&#123;|&#125;~'</span>:</span><br><span class="line">        txt = txt.replace(ch, <span class="string">" "</span>)      <span class="comment"># 将文本中特殊字符替换为空格</span></span><br><span class="line">    <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line">file_txt = get_text()</span><br><span class="line">words = file_txt.split()    <span class="comment"># 对字符串进行分割，获得单词列表</span></span><br><span class="line">counts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">if</span> len(word) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        counts[word] = counts.get(word, <span class="number">0</span>) + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">items = list(counts.items())    </span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="keyword">True</span>)      </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    word, count = items[i]</span><br><span class="line">    print(word, <span class="string">"    "</span>, count)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 函数库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>random库</title>
      <link href="/2018/07/17/random%E5%BA%93/"/>
      <url>/2018/07/17/random%E5%BA%93/</url>
      <content type="html"><![CDATA[<h2 id="一些常用的random函数"><a href="#一些常用的random函数" class="headerlink" title="一些常用的random函数"></a>一些常用的random函数</h2><h3 id="1-产生一个简单的随机数"><a href="#1-产生一个简单的随机数" class="headerlink" title="1. 产生一个简单的随机数"></a>1. 产生一个简单的随机数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">random.random()             <span class="comment">#产生一个在[0.0,1.0)区间里的实数</span></span><br><span class="line">random.uniform(a, b)        <span class="comment">#产生一个在[a, b)区间里的实数</span></span><br><span class="line">random.randint(a, b)        <span class="comment">#产生一个在[a, b]区间里的随机整数</span></span><br></pre></td></tr></table></figure><h3 id="2-产生特定分布的随机数"><a href="#2-产生特定分布的随机数" class="headerlink" title="2. 产生特定分布的随机数"></a>2. 产生特定分布的随机数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">random.guess(mu, sigma) <span class="comment"># 高斯分布：以 mu 为均值，sigma 为标准差</span></span><br><span class="line">random.normalvariate(mu, sigma) <span class="comment"># 正态分布：以 mu 为均值，sigma 为标准差</span></span><br><span class="line">random.lognormvariate(mu, sigma)<span class="comment"># 对数正态分布</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-对列表类型的操作"><a href="#3-对列表类型的操作" class="headerlink" title="3. 对列表类型的操作"></a>3. 对列表类型的操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">random.choice(seq)                  <span class="comment"># 从列表,字符串,元组类型中随机选取一个元素返回</span></span><br><span class="line">random.shuffle(seq[, random-func])  <span class="comment"># 对 seq 进行洗牌，默认用 random.random()</span></span><br><span class="line">random.sample(seq, k)               <span class="comment"># 从 seq 中随机选取一个子集并返回</span></span><br></pre></td></tr></table></figure><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">list2 = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">str = <span class="string">"abcdefghijklmn"</span></span><br><span class="line"></span><br><span class="line">print(random.random())</span><br><span class="line">print(random.uniform(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">print(random.randint(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">print(random.choice(str))</span><br><span class="line">print(random.choice(list1))</span><br><span class="line">print(random.choice(list2))</span><br><span class="line"></span><br><span class="line">random.shuffle(list1)</span><br><span class="line">random.shuffle(list2)</span><br><span class="line">print(list1)</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line">print(random.sample([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><code>ouput</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.8483344485810689</span></span><br><span class="line"><span class="number">6.2889839071697455</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">k</span><br><span class="line"><span class="number">7</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 函数库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>turtle库</title>
      <link href="/2018/07/16/turtle%E5%BA%93/"/>
      <url>/2018/07/16/turtle%E5%BA%93/</url>
      <content type="html"><![CDATA[<p><strong>turtle库是python中很常用的一个绘制图像的函数库,通过一系列的函数指令控制画笔的移动在坐标系内绘制出相应的图像</strong></p><blockquote><p><a href="https://docs.python.org/3.3/library/turtle.htmlhighlight=turtle" target="_blank" rel="noopener">官方文档</a></p></blockquote><h2 id="1-画布"><a href="#1-画布" class="headerlink" title="1. 画布"></a>1. 画布</h2><h3 id="设置画布大小"><a href="#设置画布大小" class="headerlink" title="设置画布大小"></a>设置画布大小</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">turtle.screensize(width = <span class="keyword">None</span>, height = <span class="keyword">None</span>, background_color = <span class="keyword">None</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">turtle.screensize(<span class="number">500</span>,<span class="number">600</span>,<span class="string">"yellow"</span>)</span><br><span class="line">turtle.screensize()             <span class="comment">#默认为(300,400)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">turtle.setup(width = <span class="keyword">None</span>, height = <span class="keyword">None</span>, startx = <span class="keyword">None</span>, starty = <span class="keyword">None</span>)</span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">turtle.setup(<span class="number">300</span>,<span class="number">400</span>,<span class="number">0</span>,<span class="number">0</span>)       <span class="comment">#初始位置默认为屏幕正中央</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-画笔"><a href="#2-画笔" class="headerlink" title="2. 画笔"></a>2. 画笔</h2><h3 id="画笔的属性"><a href="#画笔的属性" class="headerlink" title="画笔的属性"></a>画笔的属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">turtle.pen(fillcolor=<span class="string">"black"</span>, pencolor=<span class="string">"red"</span>, pensize=<span class="number">10</span>)</span><br><span class="line">turtle.pensize()             <span class="comment">#设置笔的宽度</span></span><br><span class="line">turtle.pencolor()            <span class="comment">#设置笔的颜色，无参数时默认当前颜色</span></span><br><span class="line">turtle.speed(speed)          <span class="comment">#设置笔的移动速度，范围[0,10]</span></span><br><span class="line">turtle.shape(name=<span class="keyword">None</span>)      <span class="comment">#设置箭头的形状，分别有“turtle”，“circle”，“square”,"arrow","triangle",默认为"classic"</span></span><br><span class="line">turtle.resizemode(rmode=<span class="keyword">None</span>)<span class="comment">#设置画笔箭头的放缩模式，分别有"atuo"(随画笔大小改变),"user"(手动设置),"noresize"(不变)</span></span><br><span class="line">turtle.shapesize(stretch_wid=<span class="keyword">None</span>, stretch_len=<span class="keyword">None</span>, outline=<span class="keyword">None</span>) <span class="comment">#设置垂直，水平，外轮廓的放缩倍数,仅当“user”模式时有效</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">turtle(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">turtle(outline=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">turtle.tilt(angle)           <span class="comment">#旋转箭头的形状，方向保持不变</span></span><br></pre></td></tr></table></figure><h3 id="移动和绘制"><a href="#移动和绘制" class="headerlink" title="移动和绘制"></a>移动和绘制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">turtle.forward(distance)    <span class="comment">#向当前画笔方向移动distance个距离，初始向右</span></span><br><span class="line">turtle.backward(distance)   <span class="comment">#向当前画笔方向移动distance个距离，初始向左</span></span><br><span class="line">turtle.right(degree)        <span class="comment">#将画笔顺时针旋转degree个度数</span></span><br><span class="line">urtle.left(degree)          <span class="comment">#将画笔逆时针旋转degree个度数</span></span><br><span class="line"></span><br><span class="line">turtle.pendown()            <span class="comment">#将画笔落下</span></span><br><span class="line">turtle.penup()              <span class="comment">#将画笔提起</span></span><br><span class="line">turtle.goto(x,y)            <span class="comment">#将画笔移动到指定位置</span></span><br><span class="line"><span class="comment">#Sample：</span></span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.goto(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">turtle.pendown()</span><br><span class="line"></span><br><span class="line">turtel.setx()               <span class="comment">#将画笔的x坐标移动到指定位置，大于0向左</span></span><br><span class="line">turtel.sety()               <span class="comment">#将画笔的y坐标移动到指定位置，大于0向上</span></span><br><span class="line">turtel.setheading(angle)    <span class="comment">#将坐标轴旋转angle个弧度，大于0逆时针</span></span><br><span class="line">turtel.home()               <span class="comment">#将画笔的朝向初始化为向右</span></span><br><span class="line">turtel.dot(r, *color)       <span class="comment">#绘制一个指定直径的原点，颜色默认为画笔颜色</span></span><br><span class="line">turtle.circle(r, extent=<span class="keyword">None</span>, steps=<span class="keyword">None</span>) <span class="comment">#r表示半径，extent表示弧度，steps表示边的条数</span></span><br><span class="line"><span class="comment">#Sample：</span></span><br><span class="line">turtle.circle(<span class="number">50</span>)           <span class="comment">#画一个半径为50的圆，半径大于零表示在箭头右侧</span></span><br><span class="line">turtle.circle(<span class="number">50</span>, steps=<span class="number">3</span>)  <span class="comment">#画一个正三角形</span></span><br><span class="line">turtle.circle(<span class="number">50</span>,<span class="number">180</span>)       <span class="comment">#画一个半圆</span></span><br></pre></td></tr></table></figure><h3 id="画笔的控制命令"><a href="#画笔的控制命令" class="headerlink" title="画笔的控制命令"></a>画笔的控制命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">turtle.fillcolor(colorstring)   <span class="comment">#设置填充颜色</span></span><br><span class="line">turtle.color(color1, color2)    <span class="comment">#同时设置画笔颜色和填充颜色，color1为画笔颜色，color2为填充颜色</span></span><br><span class="line">turtle.filling()                <span class="comment">#布尔型，判断当前图形是否被填充</span></span><br><span class="line">turtle.begin_fill()             <span class="comment">#准备开始填充图形</span></span><br><span class="line">turtle.end_fill()               <span class="comment">#填充完成</span></span><br><span class="line">turtle.hideturtle()             <span class="comment">#影藏绘画笔的形状</span></span><br><span class="line">turtle.showturtle()             <span class="comment">#显示画笔形状</span></span><br></pre></td></tr></table></figure><h3 id="全局的控制命令"><a href="#全局的控制命令" class="headerlink" title="全局的控制命令"></a>全局的控制命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">turtle.clear()      <span class="comment">#情空画布，但是画笔的位置不变</span></span><br><span class="line">turtle.reset()      <span class="comment">#清空画布，画笔初始化为开始位置</span></span><br><span class="line">turtle.undo()       <span class="comment">#撤销上一次的画笔指令</span></span><br><span class="line">turtle.isvisible()  <span class="comment">#布尔型，判断当前画笔是否可见</span></span><br><span class="line">turtle.clone()      <span class="comment">#复制当前画笔</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">p1 = turtle.Turtle()</span><br><span class="line">p2 = p1.clone()</span><br><span class="line">p2.penup()</span><br><span class="line">p2.goto(<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">p2.forward(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">turtle.write(s, font=(<span class="string">"font_name"</span>,font_size,<span class="string">"font_type"</span>)) <span class="comment">#s为文本内容，font的三个参数分别为字体名称，大小，类型</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">turtle.write(<span class="string">"hello,world"</span>, font=(<span class="string">"'Arial', 40, 'normal'"</span>))</span><br></pre></td></tr></table></figure><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">turtle.mainloop() <span class="keyword">or</span> turtle.done()  <span class="comment">#启动循环事件，能保证图像一直保持在屏幕上，必须是最后一个语句</span></span><br><span class="line">turtle.mode(mode = <span class="keyword">None</span>)            <span class="comment">#设置画笔的模式，分别有standard(向右，逆时针)，logo(向上，顺时针)</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line">turtle(<span class="string">"standard"</span>)</span><br><span class="line">turtle(<span class="string">"logo"</span>)</span><br><span class="line"></span><br><span class="line">turtle.delay(delay=<span class="keyword">None</span>)            <span class="comment">#/设置延迟，单位为毫秒</span></span><br><span class="line">turtle.begin_poly()                 <span class="comment">#开始记录画笔的位置</span></span><br><span class="line">turtle.end_poly()                   <span class="comment">#结束记录画笔的位置</span></span><br><span class="line">turtle.get_poly()                   <span class="comment">#获取记录画笔的位置</span></span><br><span class="line"><span class="comment">#Sample:</span></span><br><span class="line"><span class="comment">#自己绘制一个图像记录下来，命名为m_shape,下次可用的画笔箭头列表中就有"m_shape"这种箭头了</span></span><br><span class="line">turtle.begin_poly()</span><br><span class="line">turtle.fd(<span class="number">10</span>)</span><br><span class="line">turtle.right(<span class="number">120</span>)</span><br><span class="line">turtle.fd(<span class="number">10</span>)</span><br><span class="line">turtle.right(<span class="number">120</span>)</span><br><span class="line">turtle.fd(<span class="number">10</span>)</span><br><span class="line">turtle.end_poly()</span><br><span class="line">pos = turtle.get_poly()</span><br><span class="line">turtle.register_shape(<span class="string">"m_shape"</span>, pos)</span><br><span class="line">turtle.shape(<span class="string">"m_shape"</span>)</span><br></pre></td></tr></table></figure><h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h2><h3 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">turtle.pensize(<span class="number">5</span>)</span><br><span class="line">turtle.pencolor(<span class="string">"yellow"</span>)</span><br><span class="line">turtle.fillcolor(<span class="string">"red"</span>)</span><br><span class="line"></span><br><span class="line">turtle.begin_fill()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">turtle.forward(<span class="number">200</span>)</span><br><span class="line">turtle.right(<span class="number">144</span>)</span><br><span class="line">turtle.end_fill()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">turtle.penup()</span><br><span class="line">turtle.goto(<span class="number">-150</span>,<span class="number">-120</span>)</span><br><span class="line">turtle.color(<span class="string">"violet"</span>)</span><br><span class="line">turtle.write(<span class="string">"Done"</span>, font=(<span class="string">'Arial'</span>, <span class="number">40</span>, <span class="string">'normal'</span>))</span><br><span class="line"></span><br><span class="line">turtle.mainloop()</span><br></pre></td></tr></table></figure><ul><li>时钟<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抬起画笔，向前运动一段距离放下</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Skip</span><span class="params">(step)</span>:</span></span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.forward(step)</span><br><span class="line">    turtle.pendown()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkHand</span><span class="params">(name, length)</span>:</span></span><br><span class="line">    <span class="comment"># 注册Turtle形状，建立表针Turtle</span></span><br><span class="line">    turtle.reset()</span><br><span class="line">    Skip(-length * <span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。</span></span><br><span class="line">    turtle.begin_poly()</span><br><span class="line">    turtle.forward(length * <span class="number">1.1</span>)</span><br><span class="line">    <span class="comment"># 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。</span></span><br><span class="line">    turtle.end_poly()</span><br><span class="line">    <span class="comment"># 返回最后记录的多边形。</span></span><br><span class="line">    handForm = turtle.get_poly()</span><br><span class="line">    turtle.register_shape(name, handForm)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Init</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> secHand, minHand, hurHand, printer</span><br><span class="line">    <span class="comment"># 重置Turtle指向北</span></span><br><span class="line">    turtle.mode(<span class="string">"logo"</span>)</span><br><span class="line">    <span class="comment"># 建立三个表针Turtle并初始化</span></span><br><span class="line">    mkHand(<span class="string">"secHand"</span>, <span class="number">135</span>)</span><br><span class="line">    mkHand(<span class="string">"minHand"</span>, <span class="number">125</span>)</span><br><span class="line">    mkHand(<span class="string">"hurHand"</span>, <span class="number">90</span>)</span><br><span class="line">    secHand = turtle.Turtle()</span><br><span class="line">    secHand.shape(<span class="string">"secHand"</span>)</span><br><span class="line">    minHand = turtle.Turtle()</span><br><span class="line">    minHand.shape(<span class="string">"minHand"</span>)</span><br><span class="line">    hurHand = turtle.Turtle()</span><br><span class="line">    hurHand.shape(<span class="string">"hurHand"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> hand <span class="keyword">in</span> secHand, minHand, hurHand:</span><br><span class="line">        hand.shapesize(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        hand.speed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立输出文字Turtle</span></span><br><span class="line">    printer = turtle.Turtle()</span><br><span class="line">    <span class="comment"># 隐藏画笔的turtle形状</span></span><br><span class="line">    printer.hideturtle()</span><br><span class="line">    printer.penup()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SetupClock</span><span class="params">(radius)</span>:</span></span><br><span class="line">    <span class="comment"># 建立表的外框</span></span><br><span class="line">    turtle.reset()</span><br><span class="line">    turtle.pensize(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">        Skip(radius)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            turtle.forward(<span class="number">20</span>)</span><br><span class="line">            Skip(-radius - <span class="number">20</span>)</span><br><span class="line">        </span><br><span class="line">            Skip(radius + <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                turtle.write(int(<span class="number">12</span>), align=<span class="string">"center"</span>, font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">30</span>:</span><br><span class="line">                Skip(<span class="number">25</span>)</span><br><span class="line">                turtle.write(int(i/<span class="number">5</span>), align=<span class="string">"center"</span>, font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">                Skip(<span class="number">-25</span>)</span><br><span class="line">            <span class="keyword">elif</span> (i == <span class="number">25</span> <span class="keyword">or</span> i == <span class="number">35</span>):</span><br><span class="line">                Skip(<span class="number">20</span>)</span><br><span class="line">                turtle.write(int(i/<span class="number">5</span>), align=<span class="string">"center"</span>, font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">                Skip(<span class="number">-20</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                turtle.write(int(i/<span class="number">5</span>), align=<span class="string">"center"</span>, font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">            Skip(-radius - <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            turtle.dot(<span class="number">5</span>)</span><br><span class="line">            Skip(-radius)</span><br><span class="line">        turtle.right(<span class="number">6</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Week</span><span class="params">(t)</span>:</span>   </span><br><span class="line">    week = [<span class="string">"星期一"</span>, <span class="string">"星期二"</span>, <span class="string">"星期三"</span>,</span><br><span class="line">            <span class="string">"星期四"</span>, <span class="string">"星期五"</span>, <span class="string">"星期六"</span>, <span class="string">"星期日"</span>]</span><br><span class="line">    <span class="keyword">return</span> week[t.weekday()]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Date</span><span class="params">(t)</span>:</span></span><br><span class="line">    y = t.year</span><br><span class="line">    m = t.month</span><br><span class="line">    d = t.day</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%s %d%d"</span> % (y, m, d)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Tick</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 绘制表针的动态显示</span></span><br><span class="line">    t = datetime.today()</span><br><span class="line">    second = t.second + t.microsecond * <span class="number">0.000001</span></span><br><span class="line">    minute = t.minute + second / <span class="number">60.0</span></span><br><span class="line">    hour = t.hour + minute / <span class="number">60.0</span></span><br><span class="line">    secHand.setheading(<span class="number">6</span> * second)</span><br><span class="line">    minHand.setheading(<span class="number">6</span> * minute)</span><br><span class="line">    hurHand.setheading(<span class="number">30</span> * hour)</span><br><span class="line">    </span><br><span class="line">    turtle.tracer(<span class="keyword">False</span>) </span><br><span class="line">    printer.forward(<span class="number">65</span>)</span><br><span class="line">    printer.write(Week(t), align=<span class="string">"center"</span>,</span><br><span class="line">                font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">    printer.back(<span class="number">130</span>)</span><br><span class="line">    printer.write(Date(t), align=<span class="string">"center"</span>,</span><br><span class="line">                font=(<span class="string">"Courier"</span>, <span class="number">14</span>, <span class="string">"bold"</span>))</span><br><span class="line">    printer.home()</span><br><span class="line">    turtle.tracer(<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 100ms后继续调用tick</span></span><br><span class="line">    turtle.ontimer(Tick, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 打开/关闭龟动画，并为更新图纸设置延迟。</span></span><br><span class="line">    turtle.tracer(<span class="keyword">False</span>)</span><br><span class="line">    Init()</span><br><span class="line">    SetupClock(<span class="number">160</span>)</span><br><span class="line">    turtle.tracer(<span class="keyword">True</span>)</span><br><span class="line">    Tick()</span><br><span class="line">    turtle.mainloop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 函数库 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
