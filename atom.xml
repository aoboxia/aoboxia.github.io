<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.tree的博客</title>
  
  <subtitle>爱学习的小夏</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-16T14:51:01.814Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr.tree</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mutex/Condition Variable/Semaphore</title>
    <link href="http://yoursite.com/2020/03/15/Mutex-Condition-Variable-Semaphore/"/>
    <id>http://yoursite.com/2020/03/15/Mutex-Condition-Variable-Semaphore/</id>
    <published>2020-03-15T12:01:39.000Z</published>
    <updated>2020-03-16T14:51:01.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><h4 id="TS-Test-And-Set-指令："><a href="#TS-Test-And-Set-指令：" class="headerlink" title="TS(Test And Set)指令："></a>TS(Test And Set)指令：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test_and_set</span><span class="params">(<span class="keyword">bool</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> tmp = *value;</span><br><span class="line">    *value = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS-Compare-And-Swap-指令："><a href="#CAS-Compare-And-Swap-指令：" class="headerlink" title="CAS(Compare And Swap)指令："></a>CAS(Compare And Swap)指令：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span> *value, <span class="keyword">int</span> expected, <span class="keyword">int</span> new_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *value;</span><br><span class="line">    <span class="keyword">if</span>(*value == expected) </span><br><span class="line">        *value = new_value;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>基本所有的CPU指令都支持CAS指令，X86架构下是<code>CMPXCHG</code>, TS指令是<code>tsl</code>。<br>TS指令相比CAS，用到的内存更小，仅需要一个bit，用到的寄存器也更少，速度更快，因此TS比CAS更常用。</p><p>Linux中对于锁的实现都是通过futex系统调用。futex由一块能够被多个进程共享的内存空间组成，保存在用户空间的共享内存中，这样对于futex的操作可以放到用户态来执行而不是在内核态，实际上futex的作用就是减少系统调用的次数来提高系统的性能。当发生竞争时（获取不到锁），则会通过futex进行系统调用切换到内核态进行休眠。</p><h4 id="Mutex和SpinLock的实现"><a href="#Mutex和SpinLock的实现" class="headerlink" title="Mutex和SpinLock的实现"></a>Mutex和SpinLock的实现</h4><p>Mutex实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(mutex) &#123;</span><br><span class="line">    lock(bus);    <span class="comment">//给总线加锁</span></span><br><span class="line">    mutex = mutex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mutex != <span class="number">0</span>)</span><br><span class="line">        block()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        success</span><br><span class="line">    unlock(bus);  </span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(mutex) &#123;</span><br><span class="line">    lock(bus);</span><br><span class="line">    mutex = mutex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mutex != <span class="number">1</span>) </span><br><span class="line">        wakeup();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        success</span><br><span class="line">   unlock(bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过CAS指令实现SpinLock<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      ; <span class="comment">// do nothing</span></span><br><span class="line">    *lock = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>Mutex在linux中互斥锁的实现，实际上就是一把锁<strong>维护了一个等待队列和一个引用计数器</strong>，当获取锁之前，先对引用计数器减1操作，如果为非负，则可以获取锁进入临界区。否则需要将该任务挂在该等待对列上。</p><p>加锁的底层实现是使用如<code>xchg</code>指令，将某个特定的寄存器置1，当其他线程需要申请cpu时，会查看该寄存器内的值，如果不为0，则等待。</p><p><a href="https://www.jianshu.com/p/a7ddb2998b3b" target="_blank" rel="noopener">linux 2.6 互斥锁的实现</a></p><h4 id="Mutex和SpinLock的比较"><a href="#Mutex和SpinLock的比较" class="headerlink" title="Mutex和SpinLock的比较"></a>Mutex和SpinLock的比较</h4><ul><li><p>获取Mutex锁一旦被占用，线程立即进入休眠。而SpinLock则会咋原地循环等待，一般在多核处理器下才会被使用。</p></li><li><p>SpinLock对CPU资源消耗较大，但是效率更高，没有切换上下文的开销。一般SpinLock只在内核当中使用，需使用者对加锁时间有一定的预估。Linux中<strong>获取SpinLock的进程是无法被抢占的</strong>，否者进程转化为等待态会导致死锁。</p></li><li><p>现在有些Mutex的实现中也会自旋几次后再进行休眠。</p></li></ul><h2 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h2><ol><li>首先思考一个问题:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 1:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread 2:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= <span class="number">100</span>)</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>thread2要等到<code>cnt &gt;= 100</code>后才对cnt进行赋值，但每次cnt的值加一，就要释放一次锁，thread2就要获取一次锁，然后解锁，没有获取到锁还会进行休眠，造成了极大不必要的开销。<strong>事实上，完全可以等到thread1达到条件之后再通知thread2</strong>，在此之前让thread先进行阻塞。因此我们引入了条件变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread1 :</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    iCount++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(iCount &gt;= <span class="number">100</span>)</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(iCount &lt; <span class="number">100</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">    iCount = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>thread2在调用pthread_cond_wait方法后被阻塞，必须等到thread1发送条件信息才会继续运行。</p><ol><li>我们再看第二个问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread 1:</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">false</span> == ready) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread 2:</span></span><br><span class="line">ready = <span class="literal">true</span>;</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br></pre></td></tr></table></figure></li></ol><p>如果我们不对thread2进行加锁会出现什么问题？<br>显然，如果在进入while循环之后，调用pthread_cond_wait之前，thread2的pthread_cond_signal被调用，那么thread1便会错过条件信号，一直阻塞下去，发生死锁。因此：<strong>条件变量必须加锁，避免条件信号的发送早于wait方法之前执行，导致死锁。</strong></p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h4 id="Semaphore和Mutex的区别"><a href="#Semaphore和Mutex的区别" class="headerlink" title="Semaphore和Mutex的区别"></a>Semaphore和Mutex的区别</h4><p>很多地方都说到，Mutex是Semaphore=1时的特殊情况，但是在实际使用过程当中，Mutex的使用范围是远远多于Semaphore的。</p><p>Mutex和Semaphore都可以实现资源使用互斥，但是一般对于临界区的互斥，大都使用Mutex而不用Semaphore，主要原因有两点：</p><ul><li><strong>效率上：</strong> Mutex实现更加简单而且接近底层，在CPU指令层面就已经实现了锁。而Semaphore大都是在操作系统层面实现的，实现相较复杂，效率较低。</li><li><strong>设计思想上：</strong> Mutex就是专门为实现资源互斥而设计的，而Semaphore在设计思想上，是为了实现规定数量的线程对多个资源的访问，更多用于线程调度。虽然可以采用Semaphore的形式实现互斥锁，但是没必要。</li></ul><h4 id="Semaphore的使用场景"><a href="#Semaphore的使用场景" class="headerlink" title="Semaphore的使用场景"></a>Semaphore的使用场景</h4><ol><li>线程调度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1: a = 1</span><br><span class="line">thread2: b = 2</span><br><span class="line">thread3: c = a + b</span><br></pre></td></tr></table></figure></li></ol><p>现有三个线程，分别执行三条指令，显然thread3需要在thread1和thread1和2之后执行，那么如何来控制他们之间的先后顺序呢，由此我们引入Semaphore。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = calculatea();</span><br><span class="line">    semaphore_increase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = calculateb();</span><br><span class="line">    semaphore_increase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore_decrease();</span><br><span class="line">    semaphore_decrease();</span><br><span class="line">    c = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1 = thread_create(geta);</span><br><span class="line">t2 = thread_create(getb);</span><br><span class="line">t3 = thread_create(getc);</span><br><span class="line">thread_join(t3);</span><br></pre></td></tr></table></figure></p><p>通过这种方式，我们<strong>实现了进程之间的同步并可以规定他们的执行顺序</strong>。</p><ol><li>限制线程并发的数量<br>现有一个线程池，多个线程之间相互抢占资源，为了控制线程并发的数量，我们可以通过控制Semaphore的大小来实现，得不到信号量，线程则无法进行。这也是我们经常说到的生产者消费者问题。</li></ol><p>最后总结下两者的区别：</p><ul><li>Mutex是为了实现临界区资源使用互斥</li><li>Semaphore一般用于线程调度和控制并发数量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mutex&quot;&gt;&lt;a href=&quot;#Mutex&quot; class=&quot;headerlink&quot; title=&quot;Mutex&quot;&gt;&lt;/a&gt;Mutex&lt;/h2&gt;&lt;h4 id=&quot;TS-Test-And-Set-指令：&quot;&gt;&lt;a href=&quot;#TS-Test-And-Set-指令：&quot; class=&quot;headerlink&quot; title=&quot;TS(Test And Set)指令：&quot;&gt;&lt;/a&gt;TS(Test And Set)指令：&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_and_set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; *value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; tmp = *value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *value = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;CAS-Compare-And-Swap-指令：&quot;&gt;&lt;a href=&quot;#CAS-Compare-And-Swap-指令：&quot; class=&quot;headerlink&quot; title=&quot;CAS(Compare And Swap)指令：&quot;&gt;&lt;/a&gt;CAS(Compare And Swap)指令：&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; expected, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; new_value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = *value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(*value == expected) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *value = new_value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TLB详解</title>
    <link href="http://yoursite.com/2020/03/14/TLB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/14/TLB详解/</id>
    <published>2020-03-14T09:37:56.000Z</published>
    <updated>2020-03-16T14:51:19.228Z</updated>
    
    <content type="html"><![CDATA[<p>TLB(translation lookaside buffer)是并行查找能力的高速缓冲存储器，是页表号和物理块号一一映射的Key-Value映射表。根据逻辑地址中的页号找到对应的物理块地址，加上页内偏移量得到实际的物理地址。</p><a id="more"></a><p>名词解释：<br><strong>PTE</strong>： Page Table Entry，页表项<br><strong>TTBR</strong>：Translation Table Base Register，页基址寄存器<br><strong>VA/PA</strong>：virtual address / physical address，虚拟地址和物理地址<br><strong>VPN/PPN</strong>：virtual page number / physical page number，虚拟页号和物理页号<br><strong>ASID</strong>：Address Space ID，与进程号对应的一个地址空间编号</p><h2 id="TLB的本质"><a href="#TLB的本质" class="headerlink" title="TLB的本质"></a>TLB的本质</h2><p>TLB其实就是一块高速缓存。TLB和Page之间的关系就相当于Cache和Memory之间的关系。TLB中缓存了VA-PA的键值对。用于快速转换VA和PA。<br>但是TLB和Cache之间有一定的区别，TLB缓存的是PTE和一些标记位，而Cache缓存的是任意的数据。他们的存储结构也有所不同。</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>TLB的命中率可以达到90%以上，这样，分页带来的速度损失就降低到10%以下。TLB的有效性是<strong>基于著名的局部性原理</strong>。</p><p>空间局部性/时间局部性：程序执行时经常使用到的内存块是具有局部性的，可以利用局部性原理提取频繁利用的数据块存放进快表中，可以有较高的命中率。</p><h2 id="TLB的结构"><a href="#TLB的结构" class="headerlink" title="TLB的结构"></a>TLB的结构</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><h4 id="全相连-full-associative"><a href="#全相连-full-associative" class="headerlink" title="全相连 - full associative"></a>全相连 - full associative</h4><p>在这种组织方式下，一个TLB表项可以和任意线性地址的页表项关联。这种关联方式使得TLB表项空间的利用率最大。但是延迟也可能相当的大，因为每次CPU请求，TLB硬件都把线性地址和TLB的表项逐一比较，直到TLB hit或者所有TLB表项比较完成。特别是随着CPU缓存越来越大，需要比较大量的TLB表项，所以这种组织方式只适合小容量TLB</p><h4 id="直接相连"><a href="#直接相连" class="headerlink" title="直接相连"></a>直接相连</h4><p>每一个线性地址块都可通过模运算对应到唯一的TLB表项，这样只需进行一次比较，降低了TLB内比较的延迟。但是这个方式产生冲突的几率非常高，导致TLB miss的发生，降低了命中率。</p><h4 id="组相连-set-associative"><a href="#组相连-set-associative" class="headerlink" title="组相连 - set-associative"></a>组相连 - set-associative</h4><p>为了解决全相连内部比较效率低和直接匹配的冲突，引入了组相连。这种方式把所有的TLB表项分成多个组，每个线性地址块对应的不再是一个TLB表项，而是一个TLB表项组。CPU做地址转换时，首先计算线性地址块对应哪个TLB表项组，然后在这个TLB表项组顺序比对。按照组长度，我们可以称之为2路，4路，8路。</p><p>经过长期的工程实践，发现8路组相连是一个性能分界点。8路组相连的命中率几乎和全相连命中率几乎一样，超过8路，组内对比延迟带来的缺点就超过命中率提高带来的好处了。</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>现在的TLB一般采用组相连的方式进行存储PTE，常见的有4路组相连和8路组相连。TLB采用组相连方式，则VPN中的TLB索引分为两部分：TLBT和TLBI，其中TLBI是组号（四组则占2位，8组占3位），全相连方式则没有TLBI，下图是四路组相连的TLB的部分结构：</p><p><img style="margin: 0 auto;display:block;" src="https://img-blog.csdn.net/20170105023330560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF5MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p><img style="margin:0 auto;display:block;" src="https://pic2.zhimg.com/80/v2-80141749c349c85b28ee001e2d3f88c5_720w.jpg"></p><ol><li>当CPU需要访问内存时，首先判断MMU是否生效。由协处理器CP15的寄存器1的M位来决定是enabled还是disabled。</li><li>当MMU生效时，MMU负责将VA转换为PA，首先从VA中取出如下几个字段：<ul><li>TLBT</li><li>TLBI</li><li>VPN</li><li>VPO</li></ul></li><li>根据TBLI找到TLB中对应的组（索引）在组内用TBLT进行匹配，若hit则返回对应的PPN，不成功，则进行Translation Table Walk</li><li>MMU将PPN加上VPO得到PA返回给cache</li><li>cache从PA中取出缓存偏移CO、缓存组索引CI、以及缓存标记CT。</li><li>从下图cache表中查看该PA处的数据是命中，如果命中并将它返回给MMU，随后MMU将它传递回CPU。<br><img style="margin:0 auto;display:block;" src="https://img-blog.csdn.net/20170105023442842?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSmF5MTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></li></ol><h2 id="Flush-Table"><a href="#Flush-Table" class="headerlink" title="Flush Table"></a>Flush Table</h2><p>x86_32架构下仅提供了两种硬件接口来刷新TLB表项：</p><ol><li>向cr3寄存器写入值时，会导致处理器自动刷新非全局页的TLB表项</li><li>在Pentium Pro以后，invlpg汇编指令用来无效指定线性地址的单个TLB表项无效。</li></ol><h3 id="ASID"><a href="#ASID" class="headerlink" title="ASID"></a>ASID</h3><p>每个进程都有特定的页表，不同进程的同一个VA可能映射到不同的PA，因此TLB也需要被刷新，但是由于频繁刷新整个TLB开销较大，因此可以采用部分刷新。因此引入了在TLB的每个表项中引入了ASID（Address Space ID），用于标记不同的进程号。</p><p>进程号PID是进程唯一的标识，占16位，ASID一般采用8位标识进程，缩小了空间开销（ASID一般在进程创建时同PID一起被分配）。当查找TLB时，硬件可以对比tag以及ASID是否都相等(对比页表基地址寄存器存储的ASID和TLB表项存储的ASID)。如果都相等，代表TLB hit。否则TLB miss。</p><p>当ASID全部分配完后，整个TLB进行Flush。</p><h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><p>我们知道内核空间和用户空间是分开的，并且内核空间是所有进程共享。既然内核空间是共享的，进程A切换进程B的时候，如果进程B访问的地址位于内核空间，完全可以使用进程A缓存的TLB。但是现在由于ASID不一样，导致TLB miss。</p><p>我们针对内核空间这种全局共享的映射关系称之为global映射。针对每个进程的映射称之为non-global映射。所以，我们在最后一级页表中引入一个bit(non-global (nG) bit)代表是不是global映射。当虚拟地址映射物理地址关系缓存到TLB时，将nG bit也存储下来。当判断是否命中TLB时，当比较tag相等时，再判断是不是global映射，如果是的话，直接判断TLB hit，无需比较ASID。当不是global映射时，最后比较ASID判断是否TLB hit。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TLB(translation lookaside buffer)是并行查找能力的高速缓冲存储器，是页表号和物理块号一一映射的Key-Value映射表。根据逻辑地址中的页号找到对应的物理块地址，加上页内偏移量得到实际的物理地址。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习</title>
    <link href="http://yoursite.com/2020/03/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/11/操作系统复习/</id>
    <published>2020-03-11T06:27:21.000Z</published>
    <updated>2020-03-17T12:41:38.201Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><a id="more"></a><h3 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>硬件：（cpu初始化）</p><ol><li>设置中断标记</li><li>产生一个中断时间的ID</li></ol><p>软件：</p><ol><li>保存现场</li><li>中断服务程序处理</li><li>清楚中断标记</li><li>恢复现场</li></ol><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ol><li>保存现场</li><li>异常处理<ul><li>杀死进程</li><li>重新执行异常指令</li></ul></li><li>恢复现场</li></ol><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>系统调用一般通过操作系统提供的API<br>Win32 API用于windows系统<br>POSIX API用于Unix，Linux，Mac OS等系统</p><p>引发用户态到内核态的转换</p><h3 id="用户态和内核态的转换"><a href="#用户态和内核态的转换" class="headerlink" title="用户态和内核态的转换"></a>用户态和内核态的转换</h3><h4 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h4><ol><li><p>系统调用<br>由用户主动发起，申请使用操作系统提供的服务。本质是操作系统为用户提供的一个中断接口。</p></li><li><p>异常<br>cpu在用户态下执行时，出现了不可预知的异常时，会产生中断，从用户态转换到内核态，将当前进程交给内核中处理相应异常的进程中处理。</p></li><li><p>外围设备的中断<br>当外围设备完成了用户的请求之后，会产生中断，告知操作系统已经完成，向cpu发起中断，切换到内核态处理中断产生进程的后续操作。</p></li></ol><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><ol><li>用户态的进程和内核态的进程之间的映射关系</li><li>建立内核堆栈，将用户态的堆栈切换到内核态的堆栈</li><li>验证参数，进入内核态之前，会对一些参数进行合法性验证。</li><li>内核态映射到用户态的地址空间，并更新相应的页面使用权限</li><li>更新内核态下一些独立的地址空间（TLB）</li></ol><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><ol><li><p>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p></li><li><p>使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个<strong>过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令</strong>。</p></li><li><p>将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始<strong>执行中断处理程序</strong>，这时就转到了内核态的程序执行了。</p></li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img style="margin:0 auto;display:block;" src="https://img-blog.csdnimg.cn/20191014095110829.png"></p><h3 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><p>内碎片：占用分区内未被利用的内存碎片<br>外碎片：未被占用分区之间的小内存碎片</p><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><ol><li>最先适配(first fit)<br>实现简单，性能较好，大的内存块都分布在高端地址。时间较长低端地址容易产生大量外碎片。</li><li>下次适配(next fit)<br>分配简单，空闲分区分布均匀，但大的内存块不易保留。</li><li>最优适配(best fit)<br>较大分区可以被保留，但会产生大量较小的外碎片。</li><li>最差适配(worse fit)<br>不易形成外碎片，但较大的内存块被占用较多。</li></ol><h4 id="内存紧缩"><a href="#内存紧缩" class="headerlink" title="内存紧缩"></a>内存紧缩</h4><p><img style="margin:0 auto;display:block;" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTUvMTM1MDMwNzg1M184OTE3LmpwZw?x-oss-process=image/format,png"></p><p>将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区。</p><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p><img style="margin:0 auto;display:block;" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTYvMTM1MDM1NzUzOV83MjI5LnBuZw?x-oss-process=image/format,png"></p><p>覆盖技术通过重复利用内存空间实现了在一块较小内存中运行需要较大内存的程序。<br>例如：上图中B和C不会同时使用，因此B和C可以共用一块80K大小的内存。</p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换技术是通过将暂时不能运行的进程整个拷贝到外存当中，并将所占内存释放，交换单位为整个进程的地址空间。不影响程序的结构，但是操作开销较大。</p><h3 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p><img style="margin:0 auto;display:block;" src="https://img-blog.csdn.net/20150923210436674"></p><p>段式管理方式按照用户进程中的自然段划分逻辑空间。段内要求连续，段间不要求连续，因此整个地址空间是二维的。</p><h4 id="段表地址转换"><a href="#段表地址转换" class="headerlink" title="段表地址转换"></a>段表地址转换</h4><p><img style="margin:0 auto;display:block;" src="https://img-blog.csdn.net/20150923210522058"></p><p>分段系统的地址变换过程如上所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：</p><ul><li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。若S多M，则产生越界中断，否则继续执行。</li><li>段表中段号S对应的段表项地址 = F + S * M，取出该段表项的前几位得到段长C。若W &gt;= C，则产生越界中断，否则继续执行。</li><li>取出段表项中该段的起始地址b，物理地址 E = b + W。</li></ul><h4 id="段的共享"><a href="#段的共享" class="headerlink" title="段的共享"></a>段的共享</h4><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（它不属于临界资源)，这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享。</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><ol><li><p>页面：进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。<strong>进程按块进行内存申请，也是给每个页面（Page）申请对应的页框（Page Frame），Page和Frame是同等大小，一一对应的。</strong></p></li><li><p>页表：为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</p></li></ol><p><img style="margin:0 auto;display:block;" src="https://img-blog.csdn.net/20150923205216036"></p><h4 id="页表地址转换"><a href="#页表地址转换" class="headerlink" title="页表地址转换"></a>页表地址转换</h4><p>地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。<strong>整个地址变换过程均是由硬件自动完成的。</strong></p><p><img style="margin: 0 auto;display:block;" src="https://img-blog.csdn.net/20150923205314683"></p><p>在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ul><li>计算页号P(P=A/L)和页内偏移量W (W=A%L)。</li><li>比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行。</li><li>页号P对应的页表项地址 = F + P * M，取出该页表项内容b，即为物理块号。</li><li>物理地址：E = b * L + W。</li></ul><h4 id="TLB快表（translation-lookaside-buffer）"><a href="#TLB快表（translation-lookaside-buffer）" class="headerlink" title="TLB快表（translation lookaside buffer）"></a>TLB快表（translation lookaside buffer）</h4><p>TLB是并行查找能力的高速缓冲存储器，是页表号和物理块号一一映射的Key-Value映射表。根据逻辑地址中的页号找到对应的物理块地址，加上页内偏移量得到实际的物理地址。</p><p>一般快表的命中率可以达到90%以上，这样，分页带来的速度损失就降低到10%以下。快表的有效性是<strong>基于著名的局部性原理</strong>。</p><p>TLB使用关联存储（associated ），有一组key，可以并行地查找所有表项，得到匹配项。</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p><img style="margin: 0 auto;display:block;" src="https://img-blog.csdn.net/20150923204951914"></p><p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32 位，其中0-11位为页内地址，即每页大小为4KB；12-31位为页号，地址空间最多允许有2^20页。</p><p>一个页表项大小为4B，则页表最大可达2^20 * 4B = 4M。每一个进程都包含一个页表，显然内存开销过大。若采用二级页表的方式，则2^10个页表项即可映射所有的页框（Page Frame）。页表的大小也缩小为4k。</p><h4 id="X64系统中的四级页表"><a href="#X64系统中的四级页表" class="headerlink" title="X64系统中的四级页表"></a>X64系统中的四级页表</h4><p>在64位系统中，每个页框只能存储2^9(4KB/8B)个页表项，所以页表的<strong>寻址长度变成了9位</strong>。<br>在x64体系中只实现了48位的virtual address，高16位被用作符号扩展，这高16位要么全是0，要么全是1。<br>为了正确翻译x64的线性地址，其页表也从x86的2级变成了4级。<br><img style="margin: 0 auto;display:block;" src="https://images0.cnblogs.com/blog2015/624196/201508/162119168016989.png"></p><p>四级页表分别为：</p><ul><li>PT(Page Table)</li><li>PDT (Page Directory Table)</li><li>PDPT (Page Directory Pointer Table)</li><li>PML4T(Page Map Level4 Table)<br>每个页表项8个字节（64位）<br>前16为空，9 + 9 + 9 + 9 + 12 = 48（四级页表索引+页内偏移量）</li></ul><p><img style="margin: 0 auto;display:block;" src="https://qph.fs.quoracdn.net/main-qimg-0bcd46d62af1b35820a88f7afc4a50de.webp"></p><p>根据页框的大小不同，对应的页表索引结构也不通：</p><ul><li>4K页面：使用PML4T，PDPT，PDT和PT 四级页转化表结构</li><li>2M页面：使用PML4T，PDPT 和PDT三级页转化表结构</li><li>1G页面：使用PML4T和PDPT二级页表转化结构</li></ul><p>详细情况见<a href="https://www.cnblogs.com/lanrenxinxin/p/4735027.html" target="_blank" rel="noopener">x64 结构体系下的内存寻址</a></p><h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><p>反置页表（Inverted Page Table）<br>基于Hash映射值查找对应页表项中的帧号</p><ul><li>进程标识与页号的Hash值可能有冲突</li><li>页表项中包括保护位、修改位、访问位和存在位等标识</li><li>同时要维护一个外部页表(External Page Table)，用于记录那些没有被调入内存的物理块。</li></ul><p>查找过程：</p><ul><li>从逻辑地址中得到页号</li><li>根据页号和PID计算出Hash值</li><li>在反置页表中查找对应的页表项，核对页号是否一致，从中找出相应的物理帧号</li></ul><p>反置页表的Hash冲突<br>例子：在页表项中加入next项，指出全部冲突项的列表</p><h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><p>在段式存储管理基础上，给每个段加一级页表</p><ul><li>逻辑地址：段号+若干个页号+页内偏移</li><li>物理地址：帧号+页内偏移</li></ul><p>段页式存储管理中的内存共享：<br>通过指向相同的页表基址，实现进程间的段共享，共享段指向同一个页表</p><p>PS: <a href="https://zhanghuimeng.github.io/post/os-mooc-lecture-6-summary/" target="_blank" rel="noopener">习题</a></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="局部页面替换算法"><a href="#局部页面替换算法" class="headerlink" title="局部页面替换算法"></a>局部页面替换算法</h4><h5 id="OPT最优页面置换算法"><a href="#OPT最优页面置换算法" class="headerlink" title="OPT最优页面置换算法"></a>OPT最优页面置换算法</h5><p>最理想的状态下，我们给页面做个标记，挑选一个最远才会被再次用到的页面。当然，这样的算法不可能实现，因为不确定一个页面在何时会被用到。</p><h5 id="FIFO先进先出置换算法"><a href="#FIFO先进先出置换算法" class="headerlink" title="FIFO先进先出置换算法"></a>FIFO先进先出置换算法</h5><p>替换最早进入进入内存的页面<br><strong>存在Belady异常</strong>：随着可用于存储的物理块增多，缺页率反而上升。</p><h5 id="LRU（Least-Recently-Used）最近最久未使用置换算法"><a href="#LRU（Least-Recently-Used）最近最久未使用置换算法" class="headerlink" title="LRU（Least Recently Used）最近最久未使用置换算法"></a>LRU（Least Recently Used）最近最久未使用置换算法</h5><p>FIFO算法和OPT算法之间的主要差别是，FIFO算法利用页面进入内存后的时间长短作为置换依据，而OPT算法的依据是将来使用页面的时间。如果以最近的过去作为不久将来的近似，那么就可以把过去最长一段时间里不曾被使用的页面置换掉。它的实质是，当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以置换。</p><p>实现方法：</p><ol><li>计数器<br>给每个页面增加一个计数器，每次访问一个页面后，当前访问页面计数清零，其余页面计数加一，每次替换计数最大的页面</li><li>栈/双向链表<br>维护一个栈/双向链表，每次将当前访问页面号压入栈中，然后查找栈中是否已经存在，存在则删除。每次选择替换掉栈底（链表尾指针）的页面。</li></ol><h5 id="Clock置换算法（NRU）"><a href="#Clock置换算法（NRU）" class="headerlink" title="Clock置换算法（NRU）"></a>Clock置换算法（NRU）</h5><p>维护一个环形链表，当发生缺页中断时，算法检查表针指向的页面，如果R位是0就淘汰该页面，并把新的页面插入这个位置，然后表针前移一位，如果R位是1就清除R位并把表针前移一位，重复这个过程直到找到一个R位为0的页面为止。</p><p>同时可以对Clock算法进一步进行改进，再增加一个M位（修改位）</p><ul><li>最近未被访问，也未被修改(R=0, M=0)。</li><li>最近被访问，但未被修改(R=1, M=0)。</li><li>最近未被访问，但被修改(R=0, M=1)。</li><li>最近被访问，被修改(R=1, M=1)。</li></ul><p>循环遍历链表，查找第一个R和M位同时为0的页表进行替换，如果没有，则查找第一个R=0，M=1的页表，同时在查找过程中的页表的R位都置零。找到进行替换之前，还应将页表写回内存，因为页表进行过修改。</p><h5 id="LFU（Least-Frequently-Used）最不常用置换算法"><a href="#LFU（Least-Frequently-Used）最不常用置换算法" class="headerlink" title="LFU（Least Frequently Used）最不常用置换算法"></a>LFU（Least Frequently Used）最不常用置换算法</h5><p>相比LRU，LFU没有考虑时间因素，LFU算法只是是统计每个页面的使用频率，频率最低的页面被替换。</p><h4 id="全局页面替换算法"><a href="#全局页面替换算法" class="headerlink" title="全局页面替换算法"></a>全局页面替换算法</h4><p>局部页面替换算法往往适用于单个进程的页面替换。局部性原理只针对单个进程而言，而多个进程共享页面时，则会失效。因此全局页面替换算法则考虑到了多个进程共用缓存的物理块的情况。</p><h5 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h5><p>定义一个工作集$W(t, \Delta)$,代表在某一时刻$t$之前的$\Delta$个访问页面的集合。</p><p><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/work-set.jpg" alt=""></p><p>工作集算法指的是，在每次需要访问页面的时刻，都对当前物理块中的页面进行检查，不在当前工作集内的，从当前物理块中剔除（无论是否发生缺页）。</p><h5 id="缺页率算法"><a href="#缺页率算法" class="headerlink" title="缺页率算法"></a>缺页率算法</h5><p>工作集算法的工作集是固定不变的，缺页率算法的工作集是可以根据缺页率动态该表的。</p><ul><li>缺页率高，工作集增大</li><li>缺页率低，工作集减小</li></ul><p>定义$t_{last}$，$t_{current}$和$T$，发生缺页时：</p><ul><li>如果 $t_{current} - t_{last} &gt; T$，从工作集中一处没有在$[t_{last}, t_{current}]$被访问的页面。</li><li>如果 $t_{current} - t_{last} \leqslant T$，把当前页面直接加入工作集。</li></ul><p>缺页率算法和工作集算法在页面替换的时机也不同，工作集算法每次访问页面时都需要对当前物理块中的页面进行计算，而缺页率算法则只在发生缺页时才进行计算。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的状态转化"><a href="#进程的状态转化" class="headerlink" title="进程的状态转化"></a>进程的状态转化</h4><p><img style="margin: 0 auto;display:block;" src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/process_tran.png"></p><ol><li>新建状态：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必须的资源；最后把该进程转入到就绪状态。</li><li>就绪状态：进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到处理器即可运行。</li><li>运行状态：进程正在处理器上运行。在单处理器的环境下，每一时刻最多只有一个进程处于运行状态。</li><li>阻塞状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理器），或等待输入输出的完成。</li><li>结束状态：进程正在从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收工作。</li></ol><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h5><p>PCB存储在<strong>内核空间</strong>-表明只有操作系统内核才有权修改它。PCB是我们感知进程动态运行的一个实体。</p><ol><li>进程标识信息<ul><li>内部标识符：由操作系统赋予每个进程的一个<strong>唯一的数字标识符</strong></li><li>外部标识符：由创建者产生，是由字母和数字组成的字符串，为用户进程访问该进程提供方便。</li><li>进程之间的父子关系</li><li>用户名或用户标识号（表示该进程属于哪个用户）</li></ul></li><li>处理机状态信息<br>主要是由处理机各种寄存器中的内容所组成<ul><li>进程当前暂存信息</li><li>下一条指令地址信息</li><li>进程状态信息</li><li>过程和系统调用参数及调用地址信息</li></ul></li><li>进程调度信息<ul><li>进程状态: 标识进程的当前状态（就绪、运行、阻塞），作为进程调度的依据。</li><li>进程优先级: 表示进程获得处理机的优先程度。</li><li>为进程调度算法提供依据的其他信息: 例如，进程等待时间、进程已经获得处理器的总时间和进程占用内存的时间等。</li><li>事件: 是指进程由某一状态转变为另一状态所等待发生的事件。（比如等待I/O释放）</li></ul></li><li>进程控制信息<ul><li>程序和数据地址。 是指组成进程的程序和数据所在内存或外存中的首地址，以便在调度该进程时能从其PCB中找到相应的程序和数据。 </li><li>进程同步和通信机制。 指实现进程同步和通信时所采取的机制，如消息队列指针和信号量等，他们可以全部或部分存在PCB中。</li><li>资源清单。 列出了进程所需的全部资源 及 已经分配给该进程的资源，但不包括CPU.</li><li>链接指针。它给出了处于同一队列中的下一个PCB的首地址。</li></ul></li></ol><h5 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h5><ol><li>为新进程分配一个进程标示号，并申请一个空白的PCB。</li><li>为进程分配资源，为新进程的程序和数据，以及用户占分配必要的空间。</li><li>初始化PCB，主要包括初始化标识信息、初始化处理器状态信息和初始化处理器控制信息。</li><li>如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。</li></ol><h5 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h5><ol><li><p>根据被终止进程的标示符，检索PCB，从中读出该进程的状态。</p></li><li><p>若被终止进程处于执行状态，立即终止该进程的执行，将处理器资源分配给其他进程。</p></li><li>若该进程还有子进程，则应将其所有子进程终止。</li><li>将该进程所拥有的资源、或归还给父进程或归还给操作系统。</li><li>将该PCB从所在队列（链表）中删除。</li></ol><h5 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h5><p>找到将要被阻射进城的标识号对应的PCB，如果该进程为运行状态，则保护其现场，将其状态改为阻塞状态，停止运行，并把该PCB插入响应时间的等待队列中去；若为就绪状态，则将其状态改为阻塞状态，把它移出就绪队列，插入到等待队列中去。<strong>进程阻塞是自发的行为</strong>。</p><h5 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h5><p>在该事件的等待队列中找到相应进程的PCB，然后把该PCB插入到就绪队列中，等待调度程序调度。</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><ol><li>保存处理器上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某时间阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。更新内存管理的数据结构。</li><li>恢复处理器的上下文。</li></ol><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>共享内存允许多个进程共享一个给定的存储区，由于它们是共享一块内存数据，因此其速度非常快。但是需要另外提供手段来保证共享内存的同步访问，例如它可以用到前面所提到的信号量来实现访问同步。</p><h5 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h5><p>进程间的数据交换是以消息(message，在计算机网络中又称报文)为单位。程序员直接利用系统提供的一组通讯命令（原语）来实现通讯。在消息通信中，接收方和发送方之间有明确的协议和消息格式 。通常用消息缓存队列（链表）实现，<strong>现在基本不再使用，速度较慢。</strong></p><h5 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h5><p>（1） 无名管道</p><pre><code>int pipe(int fd[2])</code></pre><p>其中： fd[1]为写入端，fd[0]为读出端，用于<strong>父子或兄弟进程间</strong>通信。<br><img src="https://pic3.zhimg.com/80/v2-bcffaf9639c2d503743c3230f4f6f146_720w.jpg" alt=""></p><p>由于磁盘上的任何一个文件都需要一个文件名，所以在无名管道中建立的共享文件并没有保存到磁盘上，而是在<strong>Cache中建立一个缓存文件</strong>。</p><p>（2）有名管道</p><pre><code>int mkfifo(const char * pathname, mode_t mode)</code></pre><p>用于<strong>任意进程间</strong>通信（又称FIFO 通信）</p><p>普通文件在磁盘上除了有描述性的数据结构，同时还有相应的磁盘空间来存放内容。而管道文件只在通信的时候需要存储空间，在平时只有一个描述数据结构存放在磁盘上。比如说索引节点。有名管道文件一旦创建就会<strong>永远的存放在磁盘上</strong>，除非进程使用显示的方式删除这个文件。</p><h5 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h5><p>Sockets通常有<strong>UNIX域套接字</strong>和<strong>套接字</strong>。</p><ol><li><p>UNIX域套接字和套接字很相似，但是它有更高的效率，因为它不需要执行协议处理，例如计算校验和，发送确认报文等等，它仅仅复制数据。只能用于<strong>同一台机器</strong>上的进程通信。</p></li><li><p>使用TCP协议进行通信，可以用于<strong>不同机器</strong>之间。</p></li></ol><p>目前使用得最多的进程通信方式就是Sockets，相比其他通信方式有如下好处：</p><ol><li>可以跨主机</li><li>每个进程使用TCP协议创建连接需要独占一个port，可以起到锁的作用。</li><li>port由操作系统分配和自动回收（port和sockets都是文件描述符，进程终止，操作系统会自行关闭），发生异常，不会产生垃圾内存。</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计网复习</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/11/计网复习/</id>
    <published>2020-03-11T06:27:04.000Z</published>
    <updated>2020-03-11T08:06:40.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p><img src="https://img-blog.csdn.net/20160825152622511" alt=""></p><p><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/data-transport.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机网络的体系结构&quot;&gt;&lt;a href=&quot;#计算机网络的体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的体系结构&quot;&gt;&lt;/a&gt;计算机网络的体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20
      
    
    </summary>
    
    
      <category term="复习" scheme="http://yoursite.com/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree</title>
    <link href="http://yoursite.com/2020/02/20/AVL-Tree/"/>
    <id>http://yoursite.com/2020/02/20/AVL-Tree/</id>
    <published>2020-02-20T06:19:39.000Z</published>
    <updated>2020-02-20T09:11:06.188Z</updated>
    
    <content type="html"><![CDATA[<p>AVL树是一种自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1。</p><p>当插入一个新节点时，可能会破坏原有平衡状态，则需要通过Rotate（旋转）操作来保持树的平衡性。</p><p>插入一个新节点后，总共可能有如下四种可能的情况：</p><a id="more"></a><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>情况一：当新插入节点3时，AVL失衡，以节点1为基准左旋<br>伪代码：<code>if(newval &gt; root-&gt;right-&gt;val): rotateLeft(root)</code><br><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/AVL-%E5%B7%A6%E6%97%8B.jpg" alt=""></p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>情况二：当新插入节点1时，AVL失衡，以节点3为基准左旋<br>伪代码：<code>if(newval &lt; root-&gt;left-&gt;val): rotateRight(root)</code><br><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/AVL-%E5%8F%B3%E6%97%8B.jpg" alt=""></p><h3 id="左右旋"><a href="#左右旋" class="headerlink" title="左右旋"></a>左右旋</h3><p>情况三：当新插入节点2时，AVL失衡，先以节点1为基准左旋，后以3为基准右旋<br>伪代码：<code>if(newval &gt; root-&gt;left-&gt;val): { rotateLeft(root-&gt;left), rotateRight(root) }</code><br><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/AVL-%E5%B7%A6%E5%8F%B3%E6%97%8B.jpg" alt=""></p><h3 id="右左旋"><a href="#右左旋" class="headerlink" title="右左旋"></a>右左旋</h3><p>情况四：当新插入节点2时，AVL失衡，先以节点3为基准右旋，后以节点1为基准左旋<br>伪代码：<code>if(newval &gt; root-&gt;right-&gt;val): { rotateRight(root-&gt;right), rotateLeft(root) }</code><br><img src="http://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/AVL-%E5%8F%B3%E5%B7%A6%E6%97%8B.jpg" alt=""></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val, height;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lc</span>, *<span class="title">rc</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> : root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">rotateLeft</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">node *t = root-&gt;rc;</span><br><span class="line">root-&gt;rc = t-&gt;lc;</span><br><span class="line">t-&gt;lc = root;</span><br><span class="line"></span><br><span class="line">root-&gt;height = max(height(root-&gt;lc), height(root-&gt;rc)) + <span class="number">1</span>;</span><br><span class="line">t-&gt;height = max(height(t-&gt;lc), height(t-&gt;rc)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">rotateRight</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">node *t = root-&gt;lc;</span><br><span class="line">root-&gt;lc = t-&gt;rc;</span><br><span class="line">t-&gt;rc = root;</span><br><span class="line"></span><br><span class="line">root-&gt;height = max(height(root-&gt;lc), height(root-&gt;rc)) + <span class="number">1</span>;</span><br><span class="line">t-&gt;height = max(height(t-&gt;lc), height(t-&gt;rc)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node* <span class="title">insert</span><span class="params">(node *root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">root = <span class="keyword">new</span> node();</span><br><span class="line">root-&gt;val = x;</span><br><span class="line">root-&gt;lc = root-&gt;rc = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;val) &#123;</span><br><span class="line">root-&gt;lc = insert(root-&gt;lc, x);</span><br><span class="line"><span class="keyword">if</span>(height(root-&gt;lc) - height(root-&gt;rc) &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; root-&gt;lc-&gt;val) &#123; <span class="comment">//情况2：右旋</span></span><br><span class="line">root = rotateRight(root);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//情况3：左右旋</span></span><br><span class="line">root-&gt;lc = rotateLeft(root-&gt;lc);</span><br><span class="line">root = rotateRight(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root-&gt;rc = insert(root-&gt;rc, x);</span><br><span class="line"><span class="keyword">if</span>(height(root-&gt;lc) - height(root-&gt;rc) &lt; <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; root-&gt;rc-&gt;val) &#123; <span class="comment">//情况4：右左旋</span></span><br><span class="line">root-&gt;rc = rotateRight(root-&gt;rc);</span><br><span class="line">root = rotateLeft(root);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//情况1：左旋</span></span><br><span class="line">root = rotateLeft(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;height = max(height(root-&gt;lc), height(root-&gt;rc)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">node *root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n, x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">root = insert(root, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL树是一种自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1。&lt;/p&gt;
&lt;p&gt;当插入一个新节点时，可能会破坏原有平衡状态，则需要通过Rotate（旋转）操作来保持树的平衡性。&lt;/p&gt;
&lt;p&gt;插入一个新节点后，总共可能有如下四种可能的情况：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="http://yoursite.com/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/10/15/hexo搭建博客/</id>
    <published>2019-10-15T03:15:28.000Z</published>
    <updated>2019-10-19T08:45:43.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客是作为一个程序猿的标配，由于工作的原因，我们记录笔记的方式早已不是高中阶段的在笔记本上用手抄的形式。作为一个计算机的从业者，我们后面会接触到很多新的知识点和技术。我们应当学会在互联网上记录自己这些心得笔记，所以搭建一个属于自己的个人博客就显得很有必要了。</p><p>首先要明确一点，就是我们的目的不仅仅是学会搭建博客，博客只是一个个人平台。更重要的是养成定期写博客，更新技术笔记的习惯。</p><a id="more"></a><p><strong>注意：比较心急的同学可跳过介绍部分，直接按如下步骤进行配置即可：</strong></p><p><a href="#a">1.安装Git</a></p><p><a href="#b">2.安装NodeJs</a></p><p><a href="#c">3.安装Hexo</a></p><p><a href="#d">4.创建Github仓库</a></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="1-Git"><a href="#1-Git" class="headerlink" title="1.Git"></a>1.Git</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Git是当下<strong>全球</strong>计算机从业者使用最多一个代码版本控制工具，也是我们<strong>必须</strong>要掌握并熟练使用的一个工具。我们能够使用它进行代码的备份，回退。并且在多人开发时，能够进行代码合并。通常，大型的项目开发都必须使用Git进行版本控制，开发人员负责提交代码，项目经理负责代码的合并，这一切都是采用Git来完成的。</p><h4 id="Git和Github"><a href="#Git和Github" class="headerlink" title="Git和Github"></a>Git和Github</h4><p>目前有很多同学都不清楚Git和Github之间的区别，认为Git就等同于Github。实际上两者是完全不同的，Github只是一个网站，一个专门用于存储Git上传的代码仓库。我们将本地的代码使用Git上传到Github上面托管，我们所有的数据都存储在上面，多人开发时，也是大家同时使用Github上面的同一个仓库进行代码管理。</p><p>所以，Git是一个工具，Github是当下全球最大的一个开源代码托管平台。全世界的程序员都将代码放到上面进行托管，各种开源的语言、库都可以在上面找到源代码。国内也有类似的代码网站，由于Github是一个国外的网站，</p><p>所以国内访问加载和上传速度都很慢，所以我们有时候采用国内的<a href="https://gitee.com" title="码云" target="_blank" rel="noopener">码云</a>。功能和使用方法都是一样的，只不过一个在国内一个在国外。</p><p><a id="a"></a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Git是一个开源的工具，可以直接在官网下载然后通过一键安装即可。这里我们选择一个Git Bash一键安装Git，如果电脑不是windows系统自行下载相应的系统的版本即可。</p><ul><li><a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git下载地址</a></li><li><strong>安装步骤</strong>: 直接运行exe文件，全部next，不用修改任何配置即可</li><li>安装完成，在任意文件夹下右键即会出现Git Bash选项，点击进入Git Bash界面，输入<code>git version</code>指令出现Git的版本信息则表示安装成功</li></ul><h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>node.js是运行在服务端的JavaScript，通常我们知道的CSS/HTML/JS是网页前端开发的标准三件套。HTML负责搭建网页的主体框架和布局，CSS负责跳转每个版块之间的间距，各种控件的颜色大小等等，JS则用于实现网页上的一些动态元素，例如一些动画效果，并接受一些动态的参数。通常JS作为一种胶水语言都是用于前端开发的。</p><p>但是node.js为js搭建了一个平台，使得js也能像Java/Python/PHP一样用于后台开发。由于我们使用的hexo框架是基于node.js实现的一个博客框架，所以我们首先要搭建一个服务端的JS环境。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><a id="b"></a></p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJs下载地址</a>(下载LTS版本)</li><li>下载好msi文件后，也是一键安装，不过记得在Custom Setup这一步双击下面的<code>Add To PATH</code>，把node添加到你电脑的环境变量中</li><li>在任意文件夹下打开Git bash，输入<code>node -v</code>出现了node的版本信息即为安装成功</li></ul><p>如果安装时忘记勾选<code>Add to PATH</code>，可以在电脑左下角搜索编辑系统环境变量，点击打开，点击环境变量，然后再用户配置或者系统配置中<code>Path</code>点击编辑，将你的node.js的bin文件目录添加进去即可。</p><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://hexo.io/zh-cn/docs/index.html" title="Hexo文档" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>简单来说，就是一个别人写好的博客网站模板，你直接下载下来试用就可以了。并且hexo支持便捷的更换网站主题，就像你的电脑更换壁纸一样，你可以在网上下载一个hexo主题，复制到相应的文件夹下就可以一键更换你整个网站的界面和功能了。</p><p><a id="c"></a></p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><ul><li>创建一个文件夹用于存放整个博客网站的文件</li><li>进入该文件夹右键进入Git bash界面</li><li>先使用<code>git --version</code>和<code>node -v</code>确认都能正常出现版本信息没有报错方可进入下一步<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/git-node-version.png" alt="版本信息"></li><li>输入<code>npm install -g hexo-cli</code>，安装hexo指令<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/npm.png" alt="npm"></li><li>输入<code>hexo -v</code>确认指令安装成功<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexo.png" alt="npm"></li><li>确认上一步没有报错后，使用<code>hexo init</code>进行hexo博客框架的初始，完成后，会出现如下文件夹<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexoinit2.png" alt="npm"></li><li>解释一下<ul><li>node_modules：是node.js的依赖包</li><li>public：存放的是生成的网页前端页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：存放你的markdown博客文件</li><li>themes：网站主题，可自行下载，默认是<code>landscape</code></li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li></ul><p>到此我们的博客就已经在本地搭建完成了，依次输入下面三个指令可以在本地预览博客的效果：</p><ul><li><code>hexo clean</code> 清空hexo缓存</li><li><code>hexo generate</code>根据markdown文件生成相应的资源文件</li><li><code>hexo server</code>在电脑本地运行hexo服务<br>看到如下信息，就代表你的hexo博客已经在本地运行起来了，可以在浏览器中打开<code>http://localhost:4000</code>进入博客，按<code>Ctrl+c</code>关闭服务。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexos.png" alt="本地运行Hexo"></li></ul><h3 id="4-连接Github"><a href="#4-连接Github" class="headerlink" title="4.连接Github"></a>4.连接Github</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Github是全面全球最大的一个代码托管平台，他是有许许多多的代码仓库构成，每个人都可以创建仓库，并且仓库的所有代码都是公开的，因此我们能在上面找到各种项目各种语言的源代码。今后我们学习和工作会与它密不可分。学习世界上最顶尖的大牛、最优秀的开源框架的代码也是一种极快提升我们视野和能力的途径。</p><p>刚才我们只是本地运行了Hexo博客，这里我们要做的是将我们本地的hexo博客的文件夹上传到Github的仓库当中，让所有人都能访问到我们的博客。Github为我们每个注册的用户免费提供了一个<code>https://yourname.github.io</code>的域名，因此我们可以将Github当成服务器运行我们博客网站。每次我们需要写博客就在本地写好之后同步提交到Github，然后我们的博客也能自动更新。</p><p><a id="d"></a></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>首先你需要到<a href="https://github.com" target="_blank" rel="noopener">Github</a>使用邮箱注册一个账号</li><li>然后创建一个repository(仓库)<br>仓库的名字一定要是<code>yourname.github.io</code><br><strong>例如:</strong> 我的用户名是<code>ctguqmx</code>然后我们仓库名就是<code>ctguqmx.github.io</code><br>因为Github只为我们提供这一个可以访问的域名<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/github.png" alt="创建仓库"></li></ul><h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><p>网上有很多方法是使用ssh连接Github，但是由于初学者难以理解，这里我们采用在url链接中直接使用账号密码的方式连接Github</p><ul><li>打开的hexo博客文件夹，建议把它和仓库一样命名为<code>yourname.github.io</code>，右键进入Git Bash</li><li>输入<code>git init</code>，该指令用于将该文件夹初始化为一个Git仓库，会生成一个<code>.git</code>文件用于存储该仓库的一些信息</li><li>输入<code>git remote add origin https://用户名:密码@github.com/xxx/xxx.git</code>该指令用于指定远程仓库的地址。仓库的最上方可以查看该网址，每个仓库都有两个网址作为该仓库的唯一标识，分别是<code>https://xxx</code>和<code>git@github:xxx</code><br>这里我们使用https的这个并在链接的中间加入自己的账号密码，<strong>注意修改成你自己的github账号密码和仓库地址</strong>。最后我们是通过这个链接中的账号密码来登录Github的。<br><strong>例如:</strong> 我的是<code>git remote add origin https://ctguqmx:mypassword@github.com/ctguqmx/ctguqmx.github.io.git</code></li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/giturl.png" alt="github仓库的连接"></p><ul><li>输入<code>git config --global user.name &quot;yourname&quot;</code>和<code>git config --global user.email &quot;youremail&quot;</code><br>设置你的用户名和注册邮箱地址</li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/gitconfig.png" alt="本地git的配置"></p><ul><li><p>修改hexo配置文件，打开博客根目录下的<code>_config.yml</code>文件，翻到最下面，按照如下方式修改，注意用你的自己的仓库链接，并且<code>:</code>后面有一个空格，多了或者少了都会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>最后使用<code>npm install hexo-deployer-git --save</code>安装一个插件，hexo3不自带Git上传功能。</p></li></ul><p><strong>常见错误:</strong> </p><ol><li><code>fatal: remote origin already exits.</code><br>原因：你已经绑定过了远程仓库的链接<br>解决办法：<code>git remote rm origin</code>删除链接，然后再用<code>git remote add http://xxx</code></li><li><code>fatal: Authentication failed for &#39;https://github.com/xxx/xxx.git&#39;</code><br>原因：账号或者密码错误<br>解决办法：<code>git remote -v</code>查看的你绑定的链接中的账号密码是否正确</li><li><code>Template render error: (unknown path)</code><br>原因：你写的Markdown博客文件语法错误，无法解析<br>解决办法: 找到相应的语法错误并修正</li></ol><h3 id="5-开始动手写一篇博客吧"><a href="#5-开始动手写一篇博客吧" class="headerlink" title="5.开始动手写一篇博客吧"></a>5.开始动手写一篇博客吧</h3><p>下面我将展示写一篇博客的常规操作</p><ul><li><code>hexo new &quot;my_first_blog&quot;</code></li><li>进入到博客文件夹的<code>source/_posts</code>目录下应该可以看一个<code>my_first_blog.md</code>的文件</li><li>你可以使用markdown的语法开始编写一篇博客了。具体语法可以参考<a href="http://xianbai.me/learn-md/index.html" target="_blank" rel="noopener">markdown语法</a></li><li><code>hexo g -d</code>是上<code>hexo generate</code>和<code>hexo deploy</code>的简写，直接一键发布，这时你的博客应该已经同步上传到了Github的仓库。打开Github应该可以看到和你本地一样的文件。</li><li>在浏览器中打开<code>https://yourname.github.io</code> ，看到界面就代表你成功了。</li></ul><h3 id="6-换一个更好看的主题"><a href="#6-换一个更好看的主题" class="headerlink" title="6.换一个更好看的主题"></a>6.换一个更好看的主题</h3><p>hexo默认为我们提供了一个网站的主题，实际上我们可以自己在github上下载更多更加好看，并且功能强大的主题来替换掉我们原有的主题，并且更换起来十分方便，基本上是一键切换。</p><p>我们可以自行在网上搜索<strong>hexo主题</strong>，便会出来很多供我们选择，配置起来也很简单。例如我的博客就是在<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的hexo主题 -知乎</a>上面找到的。下面我将以我们所用的主题为例，来实验一下如何切换hexo主题。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia.png" alt="yilia"></p><ol><li>首先选定一款hexo主题找到他的github仓库地址。例如我的是：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a><br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia_github.png" alt="yilia_github"></li><li>进入到你的博客文件夹下的themes文件夹，里面初始应该只有一个<code>landscape</code>主题，也就是你当前博客所使用的主题</li><li><p>打开Git Bash输入<code>git clone http://xxx.git</code>，将仓库克隆到本地，也可以在仓库右上角直接下载压缩包解压到themes文件夹下，但是注意要修改文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git yilia</span><br></pre></td></tr></table></figure></li><li><p>修改博客根目录下的 _config.yml文件，修改themes: yilia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></li><li><p>进入<code>yilia</code>文件夹，修改_config.yml文件(不是根目录下面的那个)，内容参考<a href="https://github.com/litten/BlogBackup/blob/master/_config.yml" target="_blank" rel="noopener">yilia参考配置</a></p></li><li>OK，主题切换完成，写博客的基本步骤和原来一样</li></ol><h3 id="7-改进空间"><a href="#7-改进空间" class="headerlink" title="7.改进空间"></a>7.改进空间</h3><p>其实上面只是简单复制了别人写好的博客网站，实际上我们还有更大的开发空间和写博客的一些必备技能。我这里详细展开，仅提供一些可以自己学习的方向。</p><h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p>前面已经说过了，Hexo是一款专门针对markdown的博客框架，也就是说我们的博客必须都是用markdown文件，因此我们必须要学习markdown的基本语法来编写博客，实际上markdown的语法非常简单，总共的语法也只有几十条，在编写博客时顺带查询markdown语法即可。本文就是由markdown自动生成，无需任何手动排版。</p><h4 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h4><p>其实我们可以在原有的主题的基础上进行二次开发，增加一些新的功能，例如我们经常在别人博客中看到的一些动态水墨效果，点击出现爱心等特效，还有博客的点赞评论，网站的流量统计等等，网上都有相应的JS插件，配置也十分简单，网上也有大量的教程，可自行学习。</p><h4 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h4><p>后面大家在编写博客时肯定会出现一个问题，就是数学公式怎么编辑，实际上Markdown中可以直接使用Latex进行数学公式的编辑，Latex可以用编程的方式来编写出一个数学公式，同样的，用Latex编辑数学公式，也是我们学习计算机的一个基本技能。我建议和Markdown一样，大家都可以从需求出发，需用到什么就学相应的语法来完成你的需求，从用中学，从而达到熟能生巧。</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>我们在编写博客时，经常需要插入一些图片，我们可以在Source文件下新建一个文件专门用来存储图片，然后再Markdown博客中用<strong>相对路径</strong>来引入图片。图片会随着你的博客项目一起推送到Github当中，但是这种往往加载速度很慢，加上Github容量有限并且是国外的服务器。</p><p>这里我们可以单独将我们的图片文件上传到第三方的服务器上，然后直接通过图片的url来访问。目前常用的用阿里云和七牛云，新建一个存储空间用来存放图片，基本都有一定免费的存储额度。并且他们有专业的图片加速算法，通常加载速度都非常快。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>我们默认的使用的是Github提供给我们的域名，实际上我们可以自己申请一个域名，来替换掉这个域名，阿里云，腾讯云等等都能进行域名的申请，例如我使用<code>.top</code>的域名，一年只有几块钱，<code>.com</code>一年大概50~60。申请一个自己的个人域名后面也会大有用处，至于后续的域名备案，大家可自行摸索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客是作为一个程序猿的标配，由于工作的原因，我们记录笔记的方式早已不是高中阶段的在笔记本上用手抄的形式。作为一个计算机的从业者，我们后面会接触到很多新的知识点和技术。我们应当学会在互联网上记录自己这些心得笔记，所以搭建一个属于自己的个人博客就显得很有必要了。&lt;/p&gt;
&lt;p&gt;首先要明确一点，就是我们的目的不仅仅是学会搭建博客，博客只是一个个人平台。更重要的是养成定期写博客，更新技术笔记的习惯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>NFL定理</title>
    <link href="http://yoursite.com/2019/08/04/NPL%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/04/NPL定理/</id>
    <published>2019-08-04T03:28:52.000Z</published>
    <updated>2019-08-04T09:00:40.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>前提：<br>所有“问题”出现的机会相同，火速有问题同等重要(均匀分布)<br>NFL定理(No Free Lunch Theorem), 没有免费的午餐定理， 任意两个学习算法$\varepsilon_{a}$和$\varepsilon_{a}$,他们的期望性能相同。</p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><blockquote><p>假设样本空间$\chi$是离散的, 令$P(h|x,\varepsilon_{a})$代表算法$\varepsilon_{a}$基于训练数据X产生假设h的概率，再令$f$代表我们希望学习的真实目标函数</p></blockquote><p>则有：$\varepsilon_{a}$在训练集之外的所有样本上的误差为</p><script type="math/tex; mode=display">E_{ote}(\varepsilon_{a}|X,f)=\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})</script><p>其中：<br>$\sum_{h}$代表对算法$\varepsilon_{a}$所产生的多个假设的概率求和<br>$\sum_{x\in\chi-X}$代表训练集之外的所有样本<br>$P(x)$代表每个样本x被选中的概率<br>$\prod(h(x)\not=f(x))$代表当前的假设是否和期望值相等,若不等则取值为1,否则取值为0</p><p>考虑二分类问题，且真实目标函数可以是任何函数$\chi\rightarrow\{0,1\}$,函数空间为$\{0,1\}^{|x|}$,对所有可能的f按均匀分布对误差求和</p><script type="math/tex; mode=display">\begin{aligned}\sum_{f}E_{ote}(\varepsilon_{a}|X,f)&=\sum_{f}\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})\\&=\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,\varepsilon_{a})\sum_{f}\prod(h(x)\not=f(x))\\&=\sum_{x\in\chi-X}P(x)*1*\frac{1}{2}2^{\chi}\\&=2^{|\chi|-1}\sum_{x\in\chi-X}P(x)\end{aligned}</script><p>由上式可以看出，总误差和算法无关，也就是说任意两种算法的期望性能相同的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;p&gt;前提：&lt;br&gt;所有“问题”出现的机会相同，火速有问题同等重要(均匀分布)&lt;br&gt;NFL定理(No Free Lunch Theorem), 没有免费的午餐定理， 任意两个学习算法$\varepsilon_{a}$和$\varepsilon_{a}$,他们的期望性能相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://yoursite.com/2019/08/01/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/08/01/vim常用快捷键/</id>
    <published>2019-08-01T03:28:52.000Z</published>
    <updated>2019-08-04T08:37:57.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim的基础配置"><a href="#vim的基础配置" class="headerlink" title="vim的基础配置"></a>vim的基础配置</h2><p>Vim 的全局配置一般在<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效。用户个人的配置在<code>~/.vimrc</code></p><a id="more"></a><p>配置项一般都有”打开”和”关闭”两个设置。”关闭”就是在”打开”前面加上前缀”no”。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">" tab/缩进空格数</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> </span><br><span class="line"><span class="comment">" 整行左右缩进空格数, &lt;&lt;左缩进, &gt;&gt;右缩进, =取消全部缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="comment">" 在行首时tab缩进shiftwidth大小空格, 默认tab都缩进tabstop大小</span></span><br><span class="line"><span class="keyword">set</span> smarttab</span><br><span class="line"><span class="comment">" 采用C语言缩进风格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="comment">" 不进行备份</span></span><br><span class="line"><span class="keyword">set</span> nobackup</span><br><span class="line"><span class="comment">" 不产生swap文件（通常非正常退出都会产生.swap文件）</span></span><br><span class="line"><span class="keyword">set</span> noswapfile</span><br><span class="line"><span class="comment">" 支持使用鼠标</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span></span><br><span class="line"><span class="comment">" 背景风格</span></span><br><span class="line"><span class="keyword">colo</span> torte</span><br><span class="line"><span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br></pre></td></tr></table></figure><h2 id="vim的常用快捷键"><a href="#vim的常用快捷键" class="headerlink" title="vim的常用快捷键"></a>vim的常用快捷键</h2><p>快捷键都是normal模式下使用</p><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><blockquote><p><code>i</code> 切换到插入模式（编辑模式）<br><code>[esc]</code> 退出到normal模式<br><code>v</code> 切换到视图模式（可选中）</p></blockquote><h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h3><blockquote><p><code>:w</code> —&gt; 报错<br><code>:q</code> —&gt; 退出<br><code>:!</code> —&gt; 强制<br><code>:wq!</code> —&gt; 先保存后强制退出</p></blockquote><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><blockquote><p><code>y</code> —&gt; 复制<br><code>yy</code> —&gt; 复制当前行<br><code>p</code> —&gt; 粘贴<br><code>dd</code> —&gt; 删除当前行, 同时会复制<br><code>x</code> —&gt; 删除光标所在字符<br><code>u</code> —&gt; 撤销</p></blockquote><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><blockquote><p><code>hjkl</code> 分别对应 ←↑↓→<br><code>w</code> —&gt; 到下一个单词的开头<br><code>e</code> —&gt; 到下一个单词的结尾<br><code>0</code> —&gt; 到行头<br><code>$</code> —&gt; 到行尾<br><code>^</code> —&gt; 到本行第一个非blank字符<br><code>g_</code>—&gt; 到本行最后一个非blank字符<br><code>%</code> —&gt; 光标移动到最近的括号上,左右括号来回切换<br><code>#</code> —&gt; 到光标所在单词上一个相同单词<br><code>*</code> —&gt; 到光标所在单词下一个相同单词<br><code>gg</code>—&gt; 到文件开头<br><code>G</code> —&gt; 到文件结尾</p></blockquote><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><blockquote><p><code>split</code> 当前文件水平分屏<br><code>vplit</code> 当前文件垂直分屏<br><code>new</code> 水平分屏一个新文件<br><code>vnew</code> 垂直分屏一个新文件<br><code>Ctrl+w+hjkl</code> 切换分屏</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vim的基础配置&quot;&gt;&lt;a href=&quot;#vim的基础配置&quot; class=&quot;headerlink&quot; title=&quot;vim的基础配置&quot;&gt;&lt;/a&gt;vim的基础配置&lt;/h2&gt;&lt;p&gt;Vim 的全局配置一般在&lt;code&gt;/etc/vim/vimrc&lt;/code&gt;或者&lt;code&gt;/etc/vimrc&lt;/code&gt;，对所有用户生效。用户个人的配置在&lt;code&gt;~/.vimrc&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://yoursite.com/2019/02/21/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/背包问题/</id>
    <published>2019-02-21T03:41:51.000Z</published>
    <updated>2020-02-21T07:21:59.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>有n个物品，分别重w[i]，价值v[i]，现要从n个物品中挑选任意个，使得总重量不超过m，且价值最大。每个物品仅可挑选一次。</p></blockquote><a id="more"></a><h3 id="二维数组实现"><a href="#二维数组实现" class="headerlink" title="二维数组实现"></a>二维数组实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>][<span class="number">10001</span>], w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维数组实现"><a href="#一维数组实现" class="headerlink" title="一维数组实现"></a>一维数组实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>], w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; j--) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01背包变形"><a href="#01背包变形" class="headerlink" title="01背包变形"></a>01背包变形</h3><p>前面01背包的时间复杂度是O(nW)，当物品的重量较大时，问题的规模较大。如果每个物品的价值较小可以转换一种思路求解。<br>前面的DP思路时，求相同重量下能够装下的物品的最大价值，可以转换为：相同价值下，求所需背包的最小重量。最后dp数组中&lt;=W的最大价值即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">10001</span>], w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> n, m, MAXV = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) MAXV += v[i];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= MAXV; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; v[i]) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = min(dp[i][j], dp[i][j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXV; i++) <span class="keyword">if</span>(dp[n][i] &lt;= m) res = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><blockquote><p>有n中重量和价值分别为 $w_{i},v_{i}$ 的物品。从这些物品中挑选总重量不超过 $W$ 的物品，求出挑选物品价值总和的最大值。在这里，每种物品可以挑选任意多次。</p></blockquote><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>01背包的状态转移方程为：</p><script type="math/tex; mode=display">dp[i+1][j] = \left\{    \begin{array}{lr}    dp[i][j] & & (j<w[i])\\    max\{dp[i][j], dp[i][j-w[i]] + v[i]\} & & (j\geqslant w[i])    \end{array}\right.</script><p>完全背包的状态转移方程为：</p><script type="math/tex; mode=display">\begin{aligned}dp[i+1][j] &= max\{ dp[i][j-k\times w[i]] + k\times v[i] | 0 \leqslant k \} \\&=max( dp[i][j], dp[i][j-k\times w[i]] + k\times v[i] | 1 \leqslant k ) \\&=max( dp[i][j], dp[i][j-k\times w[i]-w[i]] + k\times v[i]+v[i] | 0 \leqslant k ) \\&=max( dp[i][j], d[i+1][j-w[i]]+v[i] )\end{aligned}</script><h3 id="二维数组实现-1"><a href="#二维数组实现-1" class="headerlink" title="二维数组实现"></a>二维数组实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>][<span class="number">10001</span>], w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; w[i]) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i + <span class="number">1</span>][j] = max(dp[i][j], dp[i + <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维数组实现-1"><a href="#一维数组实现-1" class="headerlink" title="一维数组实现"></a>一维数组实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10001</span>], w[<span class="number">10001</span>], v[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; j++) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01背包&quot;&gt;&lt;a href=&quot;#01背包&quot; class=&quot;headerlink&quot; title=&quot;01背包&quot;&gt;&lt;/a&gt;01背包&lt;/h2&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;有n个物品，分别重w[i]，价值v[i]，现要从n个物品中挑选任意个，使得总重量不超过m，且价值最大。每个物品仅可挑选一次。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Unicode与UTF-8编码</title>
    <link href="http://yoursite.com/2019/02/16/Unicode%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2019/02/16/Unicode与UTF-8编码/</id>
    <published>2019-02-16T04:01:18.000Z</published>
    <updated>2019-02-16T05:59:34.698Z</updated>
    
    <content type="html"><![CDATA[<p>首先确定一个问题,无论采用何种编码方式,最后在计算机当中一定是以二进制的形式存储的。至于编码方式,则是将具体的字符和二进制之间的一个对照关系。</p><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p><code>ASCII</code>是最早出现的编码方式,是美国用来将26个字母和一些英文字符和二进制对应起来的一种编码方式,<code>ASCII</code>一共规定了128个字符的二进制表示,只需要用到7位二进制数,首位统一规定为0.</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>由于世界上各地语言存在差异,因此存在着各种千奇百怪的符号,并且相同的符号在不同的地区可能表示不同的意思.因此一个字节8位的编码方式远远不能满足需求。因此有了<code>Unicode</code>,<code>Unicode</code>实际上是一个字符集，它是<code>ASCII</code>的一个扩充版,他将全世界所有的字符全部包含其中，并且规定所有字符的二进制表示。它共包含了100多万种字符的二进制表示方式。全世界出现的所有的字符都在这个表中有唯一的表示方法。因此解决各国字符不兼容的问题。</p><p><code>Unicode</code>实际上只规定每个字符的二进制表示方法,但并没有给出每个字符的具体存储方式。与此同时也带来一些问题。例如,如何将<code>Unicode</code>和其他的编码方式区分开来,<code>ASCII</code>用一个字节来表示字符,而<code>Unicode</code>可能采用多个字节来表示一个字符。如何知道我在表示一个字符时到底是采用的一位还是两位甚至更多呢？另外,如果把所有字符统一规定为四位甚至五位，那么必然会带来极大的内存浪费。</p><p>但是为了区分不同的字符,必然是需要唯一确定的二进制表示的,但是我们对<code>Unicode</code>可以采用不同的实现方式。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p><code>UTF-8</code>实际上就是目前最常用的一种<code>Unicode</code>的实现方式。他为了解决直接采用<code>Unicode</code>存储带来的内存浪费,采用了一个可变长编码的方式,就是<code>Unicode</code>编码的不同范围的字符采用不同的字节表示,例如小字符采用一个字节表示，大一点的采用两位。每个字符表示的字节数是可长可短的。具体采用几位字节表示在首位用1的个数给出。具体规则如下：</p><blockquote><p>1）对于<code>单字节</code>的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 <code>Unicode</code> 码。因此对于英语字母，<code>UTF-8</code> 编码和 <code>ASCII</code> 码是相同的。</p><p>2）对于<code>n</code>字节的符号(n &gt; 1)，第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 <code>Unicode</code> 码。</p></blockquote><p>具体编码方式如下：<br><table>   <thead>    <tr>      <th>Unicode符号范围(十六进制)</th>      <th>UTF-8编码方式(二进制)</th>    </tr>  </thead>  <tbody>    <tr>      <td>0000 0000-0000 007F</td>       <td>0xxxxxx</td>    </tr>    <tr>      <td>0000 0080-0000 07FF</td>      <td>110xxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0000 0800-0000 FFFF</td>      <td>1110xxxx 10xxxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0001 0000-0010 FFFF</td>      <td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>    </tr>  </tbody></table></p><p>如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>以<code>夏</code>为例,<code>夏</code>的<code>Unicode</code>表示为<code>590F</code>(‭<code>0101100100001111</code>‬),由上表可知,<code>夏</code>在第三行的范围当中,因此将<code>夏</code>的二进制数从右到左一次填入第三行的<code>x</code>当中,高位未填完的<code>x</code>补<code>0</code>,最后得到<code>夏</code>的<code>UTF-8</code>的二进制表示为<code>11100101 10100100 10001111</code>,十六进制表示为<code>‭E5A48F‬</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先确定一个问题,无论采用何种编码方式,最后在计算机当中一定是以二进制的形式存储的。至于编码方式,则是将具体的字符和二进制之间的一个对照关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="http://yoursite.com/2019/01/01/stl/"/>
    <id>http://yoursite.com/2019/01/01/stl/</id>
    <published>2019-01-01T10:32:41.000Z</published>
    <updated>2019-05-20T12:04:15.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stl-config-h中的各种组态-configuration"><a href="#stl-config-h中的各种组态-configuration" class="headerlink" title="stl_config.h中的各种组态(configuration)"></a>stl_config.h中的各种组态(configuration)</h2><h3 id="STL-STATIC-TEMPLATE-MEMBER-BUG"><a href="#STL-STATIC-TEMPLATE-MEMBER-BUG" class="headerlink" title="__STL_STATIC_TEMPLATE_MEMBER_BUG"></a>__STL_STATIC_TEMPLATE_MEMBER_BUG</h3><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试在class template 中拥有 static data members. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">int</span>&gt;::_data = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">char</span>&gt;::_data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">int</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">char</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">testClass&lt;<span class="keyword">int</span>&gt; obji1, obji2;</span><br><span class="line">testClass&lt;<span class="keyword">char</span>&gt; objc1, objc2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">obji1._data = <span class="number">3</span>;</span><br><span class="line">objc2._data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-CLASS-PARTIAL-SPECIALIZATION"><a href="#STL-CLASS-PARTIAL-SPECIALIZATION" class="headerlink" title="__STL_CLASS_PARTIAL_SPECIALIZATION"></a>__STL_CLASS_PARTIAL_SPECIALIZATION</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test __STL_FUNCTION__TMPL_PARTIAL_ORDER in &lt;stl_config.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;T, Alloc&gt;&amp;)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"swap()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,y;</span><br><span class="line">swap(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-MEMBER-TEMPLATES"><a href="#STL-MEMBER-TEMPLATES" class="headerlink" title="__STL_MEMBER_TEMPLATES"></a>__STL_MEMBER_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试class template 之内可否再有 template (members)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">iterator</span> <span class="title">position</span>, <span class="title">I</span> <span class="title">first</span>, <span class="title">I</span> <span class="title">last</span>) &#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"insert()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line">x.insert(ite, ia, ia+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-LIMITED-DEFAULT-TEMPLATES"><a href="#STL-LIMITED-DEFAULT-TEMPLATES" class="headerlink" title="__STL_LIMITED_DEFAULT_TEMPLATES"></a>__STL_LIMITED_DEFAULT_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 template 参数可否根据前一个 template 参数而设定默认值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; // for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">deque</span>() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deque"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; x; <span class="comment">//deque</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-NON-TYPE-TEMP-PARAM-BUG"><a href="#STL-NON-TYPE-TEMP-PARAM-BUG" class="headerlink" title="__STL_NON_TYPE_TEMP_PARAM_BUG"></a>__STL_NON_TYPE_TEMP_PARAM_BUG</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 class template 可否拥有 non-type template 参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; //for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)&#123;</span><br><span class="line"><span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//Iterator</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>,alloc,64&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、容器-container"><a href="#1、容器-container" class="headerlink" title="1、容器(container)"></a>1、容器(container)</h2><h2 id="2、算法-algorithm"><a href="#2、算法-algorithm" class="headerlink" title="2、算法(algorithm)"></a>2、算法(algorithm)</h2><h2 id="3、迭代器-iterators"><a href="#3、迭代器-iterators" class="headerlink" title="3、迭代器(iterators)"></a>3、迭代器(iterators)</h2><h2 id="4、仿函数-functors"><a href="#4、仿函数-functors" class="headerlink" title="4、仿函数(functors)"></a>4、仿函数(functors)</h2><h2 id="5、配接器-adapters"><a href="#5、配接器-adapters" class="headerlink" title="5、配接器(adapters)"></a>5、配接器(adapters)</h2><h2 id="6、配置器-allocators"><a href="#6、配置器-allocators" class="headerlink" title="6、配置器(allocators)"></a>6、配置器(allocators)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;stl-config-h中的各种组态-configuration&quot;&gt;&lt;a href=&quot;#stl-config-h中的各种组态-configuration&quot; class=&quot;headerlink&quot; title=&quot;stl_config.h中的各种组态(configuration)&quot;&gt;&lt;/a&gt;stl_config.h中的各种组态(configuration)&lt;/h2&gt;&lt;h3 id=&quot;STL-STATIC-TEMPLATE-MEMBER-BUG&quot;&gt;&lt;a href=&quot;#STL-STATIC-TEMPLATE-MEMBER-BUG&quot; class=&quot;headerlink&quot; title=&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG&quot;&gt;&lt;/a&gt;__STL_STATIC_TEMPLATE_MEMBER_BUG&lt;/h3&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="stl" scheme="http://yoursite.com/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>linux笔记</title>
    <link href="http://yoursite.com/2018/12/15/linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/15/linux笔记/</id>
    <published>2018-12-15T08:59:52.000Z</published>
    <updated>2019-10-16T11:11:20.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切换python优先级"><a href="#切换python优先级" class="headerlink" title="切换python优先级"></a>切换python优先级</h2><ol><li>设置优先级<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br></pre></td></tr></table></figure><ol><li>切换版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config python</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/linux-01.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;切换python优先级&quot;&gt;&lt;a href=&quot;#切换python优先级&quot; class=&quot;headerlink&quot; title=&quot;切换python优先级&quot;&gt;&lt;/a&gt;切换python优先级&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;设置优先级&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>随机数算法</title>
    <link href="http://yoursite.com/2018/10/24/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/24/随机数算法/</id>
    <published>2018-10-24T02:30:42.000Z</published>
    <updated>2018-10-24T09:02:04.535Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在给大一的新生出题，经常需要用到随机数生成后台数据，然后偶然间在网上看到了几个很有意思的随机数算法，这里记录一下。</p><a id="more"></a><h1 id="随机数算法改造"><a href="#随机数算法改造" class="headerlink" title="随机数算法改造"></a>随机数算法改造</h1><h2 id="1、01等概率"><a href="#1、01等概率" class="headerlink" title="1、01等概率"></a>1、01等概率</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数，设计一个新的随机函数要求以等概率生成0和1。</p></blockquote><p>生成零的概率是 <code>p</code> ,1的概率是 <code>(1-p)</code> ,那么两个数随机数,第一个为0第二个为1的概率为 <code>p(1-p)</code> ,第一个为1第二个为0的概率为 <code>(1-p)p</code> 。从而实现等概率。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> p = <span class="number">0.2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_p</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; p * <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">int</span> tmp2 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">if</span> (tmp1 == <span class="number">0</span> &amp;&amp; tmp2 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp1 == <span class="number">1</span> &amp;&amp; tmp2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rand_0_and_1_with_equal_prob();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、1-n随机数"><a href="#2、1-n随机数" class="headerlink" title="2、1~n随机数"></a>2、1~n随机数</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生 1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数 rand_0_and_1_with_p()，设计一个新的随机函数，要求以等概率产生 1  到 n 之间的随机数。</p></blockquote><p>用01生成一个随机的二进制数，n以内的二进制数最多有log2(n)位。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; <span class="number">5</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_to_n_minus_1_with_equal_prob</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>,res,m = n;</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line">k++;</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">res |= rand_0_and_1_with_equal_prob() &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt;= m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、由1-5生成1-7等概率随机数"><a href="#3、由1-5生成1-7等概率随机数" class="headerlink" title="3、由1-5生成1-7等概率随机数"></a>3、由1-5生成1-7等概率随机数</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand5() ，它能生成 1~5 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求据此实现 rand7()，能产生1～7 之间的随机数字。</p></blockquote><p>rand5()可以生成 0 ~ 4 的随机数，用相同的方法，我们可以生成一个等概率随机的五进制数，两位五进制数最多可以表示 0 ~ 24 共 25 个数，去掉 21 ~ 24 ，剩下 0 ~ 21 对 3 取模正好得到 0 ~ 6 的随机数加一等到 1 ~ 7 的随机数</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = x * <span class="number">5</span> + y;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> (res % <span class="number">7</span> ) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、随机数范围扩展"><a href="#4、随机数范围扩展" class="headerlink" title="4、随机数范围扩展"></a>4、随机数范围扩展</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand7(),它能生成 1 ~ 7 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求用rand7()实现rand10() 能产生 1 ~ 10 的随机数字。</p></blockquote><p>用相同的方法可以用rand7()构造出7进制的二位数，<code>( rand7() - 1 ) * 7 + rand7()</code>可以表示1 ~ 49的所有七进制数。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_10</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        x = <span class="number">7</span> * (rand7() - <span class="number">1</span>) + rand7();  </span><br><span class="line">    &#125;<span class="keyword">while</span>(x &gt; <span class="number">40</span>);  </span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span> + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="等概率随机数算法"><a href="#等概率随机数算法" class="headerlink" title="等概率随机数算法"></a>等概率随机数算法</h1><h2 id="1、由两个不同概率函数生成等概率函数"><a href="#1、由两个不同概率函数生成等概率函数" class="headerlink" title="1、由两个不同概率函数生成等概率函数"></a>1、由两个不同概率函数生成等概率函数</h2><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> beta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;<span class="number">10000</span>; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> big = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = rand() % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (val&lt;<span class="number">3</span>) small++;</span><br><span class="line"><span class="keyword">else</span> big++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (big&lt;<span class="number">7000</span>) alpha++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (big&gt;<span class="number">7000</span>) beta++;</span><br><span class="line"><span class="keyword">if</span> (big != <span class="number">7000</span>) total++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total - (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、Knuth-Durstenfeld-Shuffle算法"><a href="#2、Knuth-Durstenfeld-Shuffle算法" class="headerlink" title="/2、Knuth-Durstenfeld Shuffle算法"></a>/2、Knuth-Durstenfeld Shuffle算法</h2><blockquote><p>Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它与列表中最后一个元素交换</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p><img src="/images/shuffle.png" alt="shuffle算法"></p><p>代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">ll = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,len(ll))):</span><br><span class="line">    p = random.randrange(<span class="number">0</span>,i+<span class="number">1</span>)</span><br><span class="line">    ll[i], ll[p] = ll[p], ll[i]</span><br><span class="line"></span><br><span class="line">print(ll)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在给大一的新生出题，经常需要用到随机数生成后台数据，然后偶然间在网上看到了几个很有意思的随机数算法，这里记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2018年秋启明星工作室答辩</title>
    <link href="http://yoursite.com/2018/09/17/2018%E5%B9%B4%E7%A7%8B%E5%90%AF%E6%98%8E%E6%98%9F%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AD%94%E8%BE%A9/"/>
    <id>http://yoursite.com/2018/09/17/2018年秋启明星工作室答辩/</id>
    <published>2018-09-17T12:10:09.000Z</published>
    <updated>2018-09-17T12:13:59.495Z</updated>
    
    <content type="html"><![CDATA[<p>暑期因为想着去了解一下区块链，搭建一个小的区块链实战一下。结果中途需要用到一个web框架，去串联每个区块链节点。就去试着学习了一下flask这个web框架。结果发现这是一个非常好用的web框架，轻量化，拓展性行强，配套教程和拓展工具库丰富。用来快速搭建一个web十分方便。所以中途学到一半就跑去跟着国外大佬的一个博客教程，搭建一个小的微博网站项目。因为博主的对整个网站的全局的思路十分清晰，从前期开始预留各种借口，优化项目结构，使得整个web应用拓展性极高。收获最多还是他提供给我的全局部署的一个思路。从零开始建站，各种需要考虑的细节，和整体的一个清晰的思路让我受益匪浅。</p><a id="more"></a><p>我的整个web应用的源码已经上传到了我的github上面，大家有兴趣的可以下载了解一下。<a href="https://github.com/aoboxia/flask_web/archive/master.zip" target="_blank" rel="noopener">点击下载</a>。这个是我<a href="https://github.com/aoboxia/flask_web.git" target="_blank" rel="noopener">github链接</a>。</p><h2 id="开发环境和工具"><a href="#开发环境和工具" class="headerlink" title="开发环境和工具"></a>开发环境和工具</h2><p>我电脑windows本地是在pycharm上进行这个web项目的开发的。不需要我自己配置虚拟环境，各种库安装，文件的创建也十分方便，强烈推荐大家使用，如果是简单的爬虫，或者算法题目的编辑，使用一个简单的编辑器就可以了。总之pycharm进行项目开发十分方便。</p><p>服务器上面我是用的ubuntu16.x，linux操作系统也是非常好用，用多了真的会觉得很方便，也强烈推荐。服务器上面我是用的mysql数据库，Gunicorn和Nginx两个web服务器。</p><h2 id="包的分布"><a href="#包的分布" class="headerlink" title="包的分布"></a>包的分布</h2><p>flask框架的web项目有一个标准的文件分布方式。首先是一个<code>app</code>的包，这是整个项目的主体部分。前端后台的代码文件都分布在这个里面。下面是一个我的文件分布：</p><blockquote><p>Microbog</p><blockquote><p>app</p><blockquote><p>forms.py<br>routes.py<br>init.py<br>models.py<br>templates</p><blockquote><p>base.html<br>index.html<br>user.html</p></blockquote></blockquote><p>logs</p><blockquote><p>microblog1.log<br>microblog2.log</p></blockquote><p>venv<br>.env<br>config.py<br>microblog.py<br>tests.py</p></blockquote></blockquote><p>其中省略很多文件，但是列出了主体的核心部分。我们首先可以看到所有文件都分布在microblog这个文件夹下。</p><h3 id="app文件夹"><a href="#app文件夹" class="headerlink" title="app文件夹"></a>app文件夹</h3><p>app是我项目的主体文件夹，可以看到我的大部分python文件和前端的html代码都是分布在这个里面的。下面我一次说明app包下面的文件的功能。</p><h4 id="forms-py"><a href="#forms-py" class="headerlink" title="forms.py"></a>forms.py</h4><p>这是我的表单文件，我的网页界面上面的表单都是我在这个文件中编写的一个类，然后通过python的库调用这个类实例化一个对象来创建一个表单。所以我可以通过编写类的方式就可以创建表单了，而不需要去写前端的代码，这样我可以快速实现我的功能。</p><h4 id="routes-py"><a href="#routes-py" class="headerlink" title="routes.py"></a>routes.py</h4><p>这里面是我专门用来存放视图函数的文件，python的装饰器是一个非常神奇的东西，可以自行百度了解一下。简单来说就是，我可以通过装饰器把函数和一个url绑定起来，这个函数专门用来处理该函数所绑定的url链接中所传来的信息。每当用户访问或点击到某个url，装饰器会捕获到这个访问，然后调用相应的视图函数去处理该事情的数据。<br>因此我每添加一个页面就需要编写一个相应的视图函数去处理该页面对应的url传来的数据。</p><h4 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a>init.py</h4><p>简单来说这就是一个接口文件，因为我们的包是一个封装好的一个整体，比如我这里的app包，外界是访问不了我这个包里面的内容的，那么我们如何去运行这个包中的文件呢？这里我们得给外界开放一个接口，<code>init.py</code>就是用来暴露接口的。我们可以在这个文件里面导入app文件下面的包，然后外面要访问app这个包时，就去找它的<code>init.py</code>文件，然后顺着<code>init.py</code>文件中导入包依次深入进去。所以这个文件其实就是提供接口的一个文件，每个包如果需要给外界提供相应的接口都可以通过创建一个<code>init.py</code>文件来实现。</p><h4 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h4><p>这个里面有点像大家编写游戏代码中的游戏元素类，web项目里面同样需要编写这样的类，我需要编写一个用户类，然后每新增一个用户就相当于给这个类实例化一个对象。然后里面还有邮件类，需要发送邮件时就调用这个类来实例化一个对象编写一封邮件。</p><h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>这是一个专门用来存放html代码的文件夹。我的前端代码都是存放在这个里面的。这是flask一个特别有用的功能。我们知道flask底层其实还是由两个基础的模块实现的，一个模块是<code>jinjia2</code>和<code>Werkzeug</code>，其中<code>jinjia2</code>是一个模板引擎，而我们这里的templates下面的html代码都是依赖这种模板引擎来编写的，让我们可以在html代码中使用循环，条件语句来书写，还可以用一种类似于类的继承的方式来复用html代码。可以说是用一种面向对象的编程方式去编写html代码。</p><h2 id="logs文件夹"><a href="#logs文件夹" class="headerlink" title="logs文件夹"></a>logs文件夹</h2><p>这是一个常用的惯例，我们很多地方都可以看到这个东西，这是一个日志文件夹用来存放日志，那么日志是用来干什么的呢？我们知道我们在编写算法题目时遇到错误我们都能及时的反馈出来，但是当一个项目处于生产阶段时，我们无法预知很多错误，所以我们需要一个日志文件来记录下你的项目在生产过程中出现的一些问题，来帮助你及时得到反馈，处理并修复一些问题。</p><p>下面还有一些我就不一一解释了，其中venv是一个虚拟环境，来用隔离你的项目和你的其他应用之间不相互干扰。比如你在microblog这个项目当中导入一个python包，由于venv这个虚拟环境将本项目和外界隔离开来了，所以外面使用不了这个python包。这个虚拟环境保证了项目的独立性，还有microblog.py文件是相当于一个main函数，就是它去调用app包来运行整个项目。所以在服务器上也只需要运行并监听这个文件就可以部署整个项目了。tests.py是一个测试文件，用来及时测试你的项目的相应功能是否能正常运行，.env文件用来存放环境变量,config.py也是用来调用环境变量的文件。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>其实这一块我还只停留在操作部分，怎么在数据库中查询，删除数据，数据库的更新等部分。至于怎么设计关系部门我还是参照别人的方式去做的。理解一些简单的关系设计，我这项目当中的粉丝相互关注机制还是不太了解，等过一段时间专门学习了数据库再来填坑。</p><h2 id="邮件和搜索"><a href="#邮件和搜索" class="headerlink" title="邮件和搜索"></a>邮件和搜索</h2><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>我为了丰富一下网站功能的丰富性，添加了发送邮件和全文搜索的功能。发送邮件部分主要是本地存储一个写好的邮件模板，然后根据用户的相关信息来填写这个邮件，然后通过一个代理发送出去，这里的代理就是指的google或者腾讯的这种代理。用你的google或者腾讯邮箱的账号来发送这封邮件。填写相关的账号密码和代理服务器即可。<br>另外还需要一个代理发送邮件的机制，flask相应的拓展包中有相关的功能，这个邮件当中会附带一个url链接。当用户接受到邮件然后点击这个链接时，我的服务器上的视图函数的装饰器会捕捉到这个点击，然后进行相关的处理来重置用户的账号密码。另外还需要给这个url附带一个token令牌，这也是web应用中常用的一个东西，用来控制url的有效时长。当超过一定的时长之后这个令牌将会失效，也就是说之后的点击是无效的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>这里搜索功能的实现主要是利用elasticsearch的搜索引擎来实现的。elasticsearch是一个常用的开源搜索引擎。python有相应的客户端来调用这个搜索引擎。你需要给你的数据库中的数据创建相应的索引用来给elasticsearch检索。其中还有一些数据库中的数据更新对应的检索也需要修改，这之间也存在也写先后的逻辑问题。主要使用方法是将elasticsearch运行在服务器后台，然后用代码动态的对数据库中的元素进行增删查改相应的数据索引。</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>在界面美化这方面我做得比较差，因为我主要关注的是项目的框架和功能的拓展，加上我在前端方面了解比较少，所以前端这方面的工作基本处于空白状态。但是其中我还是用到了少量ajax的方法，通过js渲染了一些消息提示框。这部分工作也是网上找的方法。</p><p>前端这一部分确实很大的局限了我的web应用的拓展，因为我不能做出相应功能的界面也导致我的web应用无法继续延伸。所以如果这学期有机会我也打算去学习web前端相应的知识。</p><h2 id="时间统一和语言"><a href="#时间统一和语言" class="headerlink" title="时间统一和语言"></a>时间统一和语言</h2><h3 id="时间统一"><a href="#时间统一" class="headerlink" title="时间统一"></a>时间统一</h3><p>我们知道世界上每个地区之间是有时差的，那么我在不同的地方发送动态如果显示的本地的时间这样会带来一定的问题。所以我在时间上必须得统一起来。这里涉及到一个时区转换的问题,我们有一个UTC的国际统一时间，这个时间是国际统一的，也就是全世界所有地方都一样。但是这个时间不方便我们认知，我们无法从这个时间获知到我们本地的时间具体是什么，因此我们还需要将UTC时间转换为本地时间。也就是我们服务器接受用户发送的动态并存储的时间数据是使用的UTC的国际统一时间戳，但是我们在给用户解析的时候再将这个时间解析为用户本地的时间，这样就解决时区不统一的问题。</p><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>我们在翻墙浏览youtube等国外网站时经常会发现很多东西都是中文显示的，这样满足了多种语言用户的需求。因此我的web应用当中同样部署了这一方案，其实这个实现起来也比较简单，只需要把web应用当中的提示性语句标识一下，然后专门给一个文件用来翻译这些被标识的语句。这个文件就相当于一张表，给你的web应用当中的提示语句都给了一个对应的翻译语句，然后设置一下你的web应用使用哪种语言就可以显示不同的语言了。通常这个翻译的文件都是<code>xxx.po</code>，按照规定的格式编写即可，网上有专门编写<code>.po</code>文件的编辑器可以实现自动翻译，使用起来也比较方便，然后需要将<code>.po</code>文件编译一些生成一个<code>.mo</code>文件就可以使用了，服务器最后调用的就是这个<code>.mo</code>文件。</p><h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><p>这方面的东西都比较碎，有很多零零散散的问题。也不好一一说。简单说一下我使用的gunicorn和nginx服务器。首先是服务器的配置文件。这个真的有点麻烦，最好还是照着网上的标配吧，改起来真的好麻烦，一不下心就崩了。有些端口监听的问题照着网上的来就好。</p><p>这里为什么需要用到两个web服务器？<br>一个是python的web服务器gunicorn。一个是我们现在使用的比较多的web服务器nginx。这种双重的服务器的部署好像是一个很常用的方案。其实一个web服务器也是可行的，也能解决正常的服务请求。但是这里使用双重服务器的好处主要在于负载均衡的问题。这是一个很常见的名词，很多流量大的网站都需要考虑这个问题，不然就会出现访问量增多导致服务器无法处理而导致系统崩溃的问题。因此我们需要合理的分配和调节服务的资源分配。这就是我们需要解决的负载均衡问题。我这里是将我的web应用运行在本地的8000端口，使用gunicorn服务器来监听和处理这个端口的数据，然后对外开放两个端口使用的nginx服务器，外部的数据和请求传输给nginx服务器，经过nginx服务器的处理之后在传输给本地的gunicorn服务器。这样当外界访问量过大时，nginx给以展示缓存部分数据慢慢交给gunicorn处理，虽然访问速度会变慢但是不至于服务器直接崩溃。<br>另外nginx在流量统计，访问管理，端口分配方面更加便捷，也给我们在某些数据处理方面带来了好处。<br>其实原因不止有这些，但是负载均衡是一个主要的问题，其他的方面的原因等我深入了解一些服务器，操作系统相关的知识再去深入了解其中的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暑期因为想着去了解一下区块链，搭建一个小的区块链实战一下。结果中途需要用到一个web框架，去串联每个区块链节点。就去试着学习了一下flask这个web框架。结果发现这是一个非常好用的web框架，轻量化，拓展性行强，配套教程和拓展工具库丰富。用来快速搭建一个web十分方便。所以中途学到一半就跑去跟着国外大佬的一个博客教程，搭建一个小的微博网站项目。因为博主的对整个网站的全局的思路十分清晰，从前期开始预留各种借口，优化项目结构，使得整个web应用拓展性极高。收获最多还是他提供给我的全局部署的一个思路。从零开始建站，各种需要考虑的细节，和整体的一个清晰的思路让我受益匪浅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="答辩" scheme="http://yoursite.com/tags/%E7%AD%94%E8%BE%A9/"/>
    
  </entry>
  
  <entry>
    <title>题解</title>
    <link href="http://yoursite.com/2018/08/26/%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/26/题解/</id>
    <published>2018-08-26T10:48:46.000Z</published>
    <updated>2018-08-26T12:00:29.996Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现自己真的太菜了，每次刷题的时候都没感觉，到了真正的比赛都是两眼一抹黑，啥算法都不会了，看来还是学了不知道怎么灵活运用，模板题做多了，思维比较僵化，稍微变化一点的题型完全没有思路。还是决定要多做一些线上的练习赛的题目，不会的之后多看一些别人的思路，学着模仿再到自己的灵活运用。</p><a id="more"></a><h1 id="2018ccpc网赛"><a href="#2018ccpc网赛" class="headerlink" title="2018ccpc网赛"></a>2018ccpc网赛</h1><p>全程划水，很多英文题目都没有看懂，有些大概知道需要用什么做但是还是形成不了具体的思路。慢慢来吧，先补几道水体，难的就不花时间了。</p><h2 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h2><blockquote><p>题目大意是一个商人可以依次经过1到n个城市，每个城市对于同一个商品的价格都不同，商人可以从一个城市买入再到另一个卖出来赚取差价，每经过一个城市都需要花费一个单位的时间而且只能依次经过1到n号城市不能回头。现在问最大的利润和最小的时间是多少。</p></blockquote><p>这道题感觉还挺简单的，不知道为啥当时没做出来，当时一直想着是找最大差值对，但是没有想到去用一个数据结构去维护数据，结果每次都需要重新扫描，自然是超时了。这题用一个堆来维护数据非常简单，依次往后走，前面已经遇到的数据放进一个堆里面存起来，后面每次都在前面找最小的数据差值就是利润，每次减去了一个差值之后就把新的较大值放入堆中，代替原有的值，下次再更新就相当于再原有的基础上更新差值了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; p;</span><br><span class="line">priority_queue&lt;p, <span class="built_in">vector</span>&lt;p&gt;, greater&lt;p&gt; &gt; q;<span class="comment">//这里用一个优先队列模拟堆，注意初始情况优先队列是从大到排序的，这样可以指定为从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n, num, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;num);</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">                ll a = q.top().first;</span><br><span class="line">                <span class="keyword">if</span>(num - a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += num - a;</span><br><span class="line">                    cnt += q.top().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(p(num,<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(p(num,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,sum,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YJJ’s-Salesman"><a href="#YJJ’s-Salesman" class="headerlink" title="YJJ’s Salesman"></a>YJJ’s Salesman</h2><p>这道题感觉似曾相似，知道要用一个线段树或者树状数组来维护数据，但是就是不知道怎么去处理这些数据。。。之后才知道原来简单的dp一下那些数据就行，找到最优解，再用线段树或者树状数组求和。</p><blockquote><p>题意大概是有很多个村庄，告诉了村庄的坐标，每个村庄都有一个权值，去到某个村庄就可以拿到相应的钱，但是约束了一下只有右上角的村庄才能拿到钱，正上方和正右边的是拿不到钱的，问怎么走拿到的前最多</p></blockquote><p>当时一看这道题就有点像之前做过的那个数组数组的题，天上有很多星星，每个星星有一个level，右上角的星星level+1，但是那道题权值都是一样的，现在这道题每个星星多加了一个权值，需要用动态规划的思想处理一下再用树状数组去维护,因为数据比较大，还需要离散化一下，说起来都是刚刚学过的。。。。但是我试了一下，好像不用离散化也能过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tree[maxn],a[maxn],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=maxn)</span><br><span class="line">&#123;</span><br><span class="line">tree[k] = max(num,tree[k]);</span><br><span class="line">ans = max(ans,tree[k]);</span><br><span class="line">k += k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qmax</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res  =<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">res = max(tree[k],res);</span><br><span class="line">k -=k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x&lt;b.x) || (a.x==b.x&amp;&amp;a.y&gt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;p[i].x,&amp;p[i].y,&amp;p[i].val);</span><br><span class="line">a[i] = p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> size=unique(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-(a+<span class="number">1</span>);<span class="comment">// 去重求大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i].y = lower_bound(a+<span class="number">1</span>,a+size+<span class="number">1</span>,p[i].y)-(a+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll val = Qmax(p[i].y<span class="number">-1</span>)+p[i].val;</span><br><span class="line">add(p[i].y,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现自己真的太菜了，每次刷题的时候都没感觉，到了真正的比赛都是两眼一抹黑，啥算法都不会了，看来还是学了不知道怎么灵活运用，模板题做多了，思维比较僵化，稍微变化一点的题型完全没有思路。还是决定要多做一些线上的练习赛的题目，不会的之后多看一些别人的思路，学着模仿再到自己的灵活运用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LCA问题</title>
    <link href="http://yoursite.com/2018/08/24/LCA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/24/LCA问题/</id>
    <published>2018-08-24T08:25:45.000Z</published>
    <updated>2018-08-24T08:31:25.671Z</updated>
    
    <content type="html"><![CDATA[<p>LCA问题，即最近公共祖先，一般有在线的ST算法和离线的Tarjin算法还有什么倍增法，最近学算法学的有点懵逼，先写一个常用的离线tarjin算法，比较容易理解。其他的先留着，以后再填坑。</p><a id="more"></a><h2 id="Tarjin离线算法"><a href="#Tarjin离线算法" class="headerlink" title="Tarjin离线算法"></a>Tarjin离线算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">10001</span>],s[<span class="number">10001</span>],t[<span class="number">10001</span>],head[<span class="number">10001</span>],dis[<span class="number">10001</span>],vis[<span class="number">10001</span>],lca[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;es[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].to = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">x == par[x] ? x : par[x] == find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjin</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">par[u] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[s[i]] &amp;&amp; t[i] == u)&#123;</span><br><span class="line">lca[i] = find(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[t[i]] &amp;&amp; s[i] == u)&#123;</span><br><span class="line">lca[i] = find(t[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dis[v] = dis[u] + es[i].w;</span><br><span class="line">tarjin(v);</span><br><span class="line">par[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z,tt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tt;</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i] &gt;&gt; t[i];</span><br><span class="line">&#125;</span><br><span class="line">tarjin(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[s[i]] + dis[t[i]] - <span class="number">2</span>*dis[lca[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LCA问题，即最近公共祖先，一般有在线的ST算法和离线的Tarjin算法还有什么倍增法，最近学算法学的有点懵逼，先写一个常用的离线tarjin算法，比较容易理解。其他的先留着，以后再填坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="http://yoursite.com/2018/08/24/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2018/08/24/网络流/</id>
    <published>2018-08-24T06:12:57.000Z</published>
    <updated>2018-08-24T08:33:21.164Z</updated>
    
    <content type="html"><![CDATA[<p>网络流是一类基于贪心思想在有权图中寻找最优解的问题。最常见的就是最大流，最小费用流之类的问题。网络流的难度在于建模，怎么将问题转化为网络流的模型求解，如何构建边与边之间的关系，建立源汇点运行最大流算法求解。</p><a id="more"></a><h2 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h2><p>这种算法其实就是贪心思想加上个一点小的优化，每次选择一条通路，流过该条路径上满足的最小流量，不停选择下去就是纯粹的贪心思想，然后优化的一点就是增加了一个增广路径的东西，其实就是把每条路径设置成了双向的，逆向也有一个流量，有点像我们在处理迷宫问题一样，不停的往前走，直到发现走不通了，再回头看能不能找到其他的路径，这里的增广路径就是迷宫问题中回头的那一条路径，就是当每条边的容量没有完全用完时，则可以回流看能不能找到更大的流量。和迷宫问题一样，可以用dfs解决。理解起来比较容易，时间复杂度较高。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap,rev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">g[u].push_back((edge)&#123;v, w, g[v].size()&#125;);</span><br><span class="line">g[v].push_back((edge)&#123;u, <span class="number">0</span>, g[u].size()<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == t)<span class="keyword">return</span> f;</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line">edge &amp;e = g[v][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[e.to] &amp;&amp; e.cap &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> d = dfs(e.to,t,min(f,e.cap));</span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">e.cap -= d;</span><br><span class="line">g[e.to][e.rev].cap += d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> f =  dfs(s,t,INF);</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">flow += f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>由于前一种用dfs深度优先搜索的时候，如果出现路径的容量比较大的情况则增广路径十分大，递归层数也很多，所以我们可以考虑用广度优先搜索来优化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> cap[maxn][maxn],cur_flow[maxn],prev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edmonds_karp</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(prev,<span class="number">0</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cur_flow, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur_flow));</span><br><span class="line"></span><br><span class="line">cur_flow[src] = inf;</span><br><span class="line">q.push(src);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!cur_flow[i] &amp;&amp; cap[cur][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">if</span> (cur_flow[cur] &gt; cap[cur][i])</span><br><span class="line">cur_flow[i] = cap[cur][i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur_flow[i] = cur_flow[cur];</span><br><span class="line">prev[i] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur_flow[dest] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dest; i != src; i = prev[i])&#123;</span><br><span class="line">cap[prev[i]][i] -= cur_flow[dest];</span><br><span class="line">cap[i][prev[i]] += cur_flow[dest];</span><br><span class="line">&#125;</span><br><span class="line">flow_sum += cur_flow[dest];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>, d = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(cap));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;d, &amp;c);</span><br><span class="line">cap[s][d] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, edmonds_karp(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>Dinic算法是EK算法的一种优化，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">///oo表示无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">///mm表示边的最大数量，因为要双向建边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mm = <span class="number">111111</span>;</span><br><span class="line"><span class="comment">///点的最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">///node:节点数,src:源点,dest:汇点,edge:边数</span></span><br><span class="line"><span class="keyword">int</span> node, src, dest, edge;</span><br><span class="line"><span class="comment">///ver:边指向的结点,flow:边的流量,next:链表的下一条边</span></span><br><span class="line"><span class="keyword">int</span> ver[mm], flow[mm], next[mm];</span><br><span class="line"><span class="comment">///head:节点的链表头,work:用于算法中的临时链表头,dis:距离</span></span><br><span class="line"><span class="keyword">int</span> head[mn], work[mn], dis[mn], q[mn];</span><br><span class="line"></span><br><span class="line"><span class="comment">///初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> _node, <span class="keyword">int</span> _src, <span class="keyword">int</span> _dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node = _node, src = _src, dest = _dest;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    edge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///增加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[edge]=v,flow[edge]=c,next[edge]=head[u],head[u]=edge++;</span><br><span class="line">    ver[edge]=u,flow[edge]=<span class="number">0</span>,next[edge]=head[v],head[v]=edge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///广搜计算出每个点与源点的最短距离，如果不能到达汇点说明算法结束</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dinic_bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, l, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[q[r++]=src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l=<span class="number">0</span>; l&lt;r; l++)</span><br><span class="line">        <span class="keyword">for</span>(i=head[u=q[l]]; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">            <span class="keyword">if</span>(flow[i] &amp;&amp; dis[v=ver[i]]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///这条边必须有剩余流量</span></span><br><span class="line">                dis[q[r++]=v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///寻找可行流的增广路算法，按节点的距离来找，加快速度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="comment">///work 是临时链表头，这里用 i 引用它，这样寻找过的边不再寻找*</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=work[u],v,tmp; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[i]&amp;&amp;dis[v=ver[i]]==dis[u]+<span class="number">1</span>&amp;&amp;(tmp=Dinic_dfs(v,min(<span class="built_in">exp</span>,flow[i])))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">///正反向边容量改变</span></span><br><span class="line">            flow[i] -= tmp;</span><br><span class="line">            flow[i^<span class="number">1</span>] += tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///求最大流，直到没有可行流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_flow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret=<span class="number">0</span>, data;</span><br><span class="line">    <span class="keyword">while</span>(Dinic_bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">            work[i] = head[i];</span><br><span class="line">        <span class="keyword">while</span>(data = Dinic_dfs(src, oo))</span><br><span class="line">            ret += data;<span class="comment">//cout&lt;&lt;666&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///套模板</span></span><br><span class="line">    <span class="keyword">int</span> m, n, u, v, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        Init(m+<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            addedge(u, v, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic_flow());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加一个模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_v = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，容量，反向边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>  </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cap;</span><br><span class="line"><span class="keyword">int</span> rev;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[max_v];<span class="comment">//图的邻接表表示  </span></span><br><span class="line"><span class="keyword">int</span> level[max_v];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//向图中增加一条从s到t容量为cap的边  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> cap)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    G[from].push_back((edge)&#123;to,cap,G[to].size()&#125;);  </span><br><span class="line">    G[to].push_back((edge)&#123;from,<span class="number">0</span>,G[from].size()<span class="number">-1</span>&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    level[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=que.front();  que.pop();</span><br><span class="line">        <span class="keyword">if</span>(v==t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (e.cap&gt;<span class="number">0</span>&amp;&amp;level[e.to]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">                que.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过DFS寻找增广路  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">long</span> <span class="keyword">long</span> f)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(v==t)    <span class="keyword">return</span> f;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        edge &amp;e=G[v][i];  </span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;<span class="number">0</span>&amp;&amp;level[v]+<span class="number">1</span>==level[e.to])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d=dfs(e.to,t,min(f,e.cap));  </span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                e.cap-=d;  </span><br><span class="line">                G[e.to][e.rev].cap+=d;  </span><br><span class="line">                <span class="keyword">return</span> d;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//求解从s到t的最大流  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> flow=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">    flow+=dfs(s, t, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tt,x,y,z,cnt=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; max_v; i++)G[i].clear();</span></span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add_edge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt++,max_flow(<span class="number">1</span>,n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">后面还有最小费用流，和各种最大流的变形。。。。有时间慢慢写。。。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络流是一类基于贪心思想在有权图中寻找最优解的问题。最常见的就是最大流，最小费用流之类的问题。网络流的难度在于建模，怎么将问题转化为网络流的模型求解，如何构建边与边之间的关系，建立源汇点运行最大流算法求解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分</title>
    <link href="http://yoursite.com/2018/08/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://yoursite.com/2018/08/24/树链剖分/</id>
    <published>2018-08-24T00:37:19.000Z</published>
    <updated>2018-08-24T06:12:30.534Z</updated>
    
    <content type="html"><![CDATA[<p>树链剖分之前一直不知道是个什么东西，最近才学到，发现也是一种很神奇的数据结构，主要是对树上的操作，将树剖分成不同的部分串联起来，再用其他的数据结构去维护他剖分的这些树链。</p><a id="more"></a><p>通常我们采用的是轻重链剖分，也就是将一棵树按照轻链和重链来划分成不同的部分。这里我们只需要知道六个个概念就足够了。</p><blockquote><p>重儿子：重儿子是指某个节点的所有子节点中子孙节点数目最多的儿子节点<br>轻儿子：某个节点的所有子节点中除重儿子之外的所有节点都是轻儿子<br>轻边：由连个亲儿子相连的边称为轻边<br>重链：由两个重儿子相连的边称为重边<br>轻链：轻边<br>重链：由重边连接而成的链称为重链</p></blockquote><p>树链剖分大多数对树的操作用其他的算法都能实现，而且时间复杂度也相当，而树链剖分的最独特的功能就是对树的路径上的值的修改，也就是，要修改在树上连续的节点值，这是其他的数据结构无法完成的。而通过树链剖分的方式则很好的解决这个问题。所以说树链剖分的主要功能是:<strong>修改树的路径上的值</strong></p><p>树链剖分主要分为三个部分：</p><h2 id="划分数据"><a href="#划分数据" class="headerlink" title="划分数据"></a>划分数据</h2><p>这一部分主要是找到树的轻重儿子，确定他们的关系，确定他们在树中的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d; <span class="comment">//深度</span></span><br><span class="line">fa[u] = pre; <span class="comment">//父亲节点</span></span><br><span class="line">ve[u] = <span class="number">1</span>; <span class="comment">//子孙节点个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];<span class="comment">//当前节点个数加上子节点所连的节点个数 </span></span><br><span class="line"><span class="keyword">if</span>(son == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;<span class="comment">//如果当前节点的重儿子为空或者出现子节点个数多于重儿子的则改变重儿子 </span></span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="连接轻重链"><a href="#连接轻重链" class="headerlink" title="连接轻重链"></a>连接轻重链</h2><p>前面找到了轻重儿子，然后就需要把他们连接起来形成链，并把他们一次编号，方便用线段树去维护。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);<span class="comment">//有重儿子则连接重链</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);<span class="comment">//遇到轻儿子则以轻儿子为顶点新开一条链</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查询和修改"><a href="#查询和修改" class="headerlink" title="查询和修改"></a>查询和修改</h2><p>通常我们用线段树来维护这些轻重链，利用前面已经编号的编号建树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span><br><span class="line">        update(p[top[x]], p[x], val, <span class="number">1</span>, n, <span class="number">1</span>);<span class="comment">//修改深度较大的重链上值</span></span><br><span class="line">        x = fa[top[x]];<span class="comment">//重链修改完成，上升到重链头结点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; dep[y]) swap(x,y);</span><br><span class="line">    update(p[x], p[y], val, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询u,v之间的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(<span class="number">1</span>, p[f1], p[u]));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(<span class="number">1</span>, p[son[u]], p[v]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="修改单点，查询最值模板"><a href="#修改单点，查询最值模板" class="headerlink" title="修改单点，查询最值模板"></a>修改单点，查询最值模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> deep[N],fa[N],p[N],fp[N],son[N],ve[N],top[N],col[N];</span><br><span class="line"><span class="keyword">int</span> head[N],sum[N*<span class="number">4</span>],from[N],to[N],value[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt,siz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;es[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].v = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d;</span><br><span class="line">fa[u] = pre;</span><br><span class="line">ve[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];</span><br><span class="line"><span class="keyword">if</span>(son[u] == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">sum[k] = max(sum[k&lt;&lt;<span class="number">1</span>],sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[k] = e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= pos)update(pos,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>update(pos,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res = max(res,query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res = max(res,query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void change(int x,int y,int val)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    while(top[x] != top[y])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span></span><br><span class="line"><span class="comment">//        update(p[top[x]], p[x], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//        x = fa[top[x]];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if(deep[x] &gt; dep[y]) swap(x,y);</span></span><br><span class="line"><span class="comment">//    update(p[x], p[y], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(p[f1], p[u], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(p[son[u]], p[v], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y,z;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp; t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">-1</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">siz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from[i],&amp;to[i],&amp;value[i]);</span><br><span class="line">add(from[i],to[i],value[i]);</span><br><span class="line">add(to[i],from[i],value[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[to[i]] &lt; deep[from[i]])swap(to[i],from[i]);</span><br><span class="line">update(p[to[i]],value[i],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s))&#123;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'D'</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">update(p[to[x]],y,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树链剖分之前一直不知道是个什么东西，最近才学到，发现也是一种很神奇的数据结构，主要是对树上的操作，将树剖分成不同的部分串联起来，再用其他的数据结构去维护他剖分的这些树链。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>块状链表</title>
    <link href="http://yoursite.com/2018/08/22/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/08/22/块状链表/</id>
    <published>2018-08-22T03:46:29.000Z</published>
    <updated>2018-08-23T00:53:26.744Z</updated>
    
    <content type="html"><![CDATA[<p>块状链表应该算一个额外拓展的知识吧，貌似不属于正规的算法，也算是一种比较中庸的数据结构，中和了一下数组和链表的优缺点，形成了一个新的数据结构就是块状链表。</p><a id="more"></a><p><strong>数组</strong> 在数组中修改或删除元素需要位移前后部分，需要的平均时间复杂度为<code>O(n)</code>，查询某个元素的时间复杂度是<code>O(1)</code>。</p><p><strong>链表</strong> 链表删除和修改元素，可以直接修改节点，时间复杂度为<code>O(1)</code>,查询需要遍历节点，平均时间复杂度是<code>O(n)</code></p><p><strong>块状链表</strong> 块状链表是把一个数组中的元素，分成多个数组，每个数组当成一个节点，普通的链表的节点是单个元素，而块状链表的节点是一个数组。它的查询和修改时间复杂度都是<code>O(sqrt(n))</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块大小和块数设为比sqrt(n)稍大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000000</span> + <span class="number">10</span>, block_sz = <span class="number">4000</span> + <span class="number">100</span>, block_num = <span class="number">4000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sz, next;<span class="comment">//sz:块内大小，next:下一个块位置</span></span><br><span class="line">    <span class="keyword">bool</span> rev;<span class="comment">//翻转标记</span></span><br><span class="line">    <span class="keyword">char</span> s[block_sz];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>, next = <span class="number">-1</span>, rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g[block_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_block</span><span class="params">()</span> <span class="comment">//新建块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = que.front();que.pop();</span><br><span class="line">    g[t].init();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_block</span><span class="params">(<span class="keyword">int</span> t)</span> <span class="comment">//删除块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.push(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_update</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//翻转块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[idx].rev)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(g[idx].s, g[idx].s + g[idx].sz);</span><br><span class="line">        g[idx].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_split</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> k)</span> <span class="comment">//把第idx块分裂成两个，前k个元素划分到第一块，其余元素划分到第二块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span> || k == g[idx].sz) <span class="keyword">return</span>;</span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="keyword">int</span> tot = new_block();</span><br><span class="line">    <span class="built_in">memcpy</span>(g[tot].s, g[idx].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (g[idx].sz - k));</span><br><span class="line">    g[tot].sz = g[idx].sz - k, g[idx].sz = k;</span><br><span class="line">    g[tot].next = g[idx].next, g[idx].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_merge</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//合并维护块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = g[i].next; j != <span class="number">-1</span>; j = g[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i].sz + g[j].sz &lt;= block_sz)</span><br><span class="line">            &#123;</span><br><span class="line">                block_update(i), block_update(j);<span class="comment">//确定合并两块时，查看是否翻转</span></span><br><span class="line">                <span class="built_in">memcpy</span>(g[i].s + g[i].sz, g[j].s, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * g[j].sz);</span><br><span class="line">                g[i].sz += g[j].sz, g[i].next = g[j].next;</span><br><span class="line">                del_block(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_init</span><span class="params">()</span> <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(! que.empty()) que.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) que.push(i);</span><br><span class="line">    head = new_block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_locate</span><span class="params">(<span class="keyword">int</span> &amp;idx, <span class="keyword">int</span> &amp;k)</span> <span class="comment">//查询全局第k个元素在某个块的某个位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(idx != <span class="number">-1</span> &amp;&amp; k &gt; g[idx].sz) k -= g[idx].sz, idx = g[idx].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//在全局的第k个元素后插入长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);<span class="comment">//先定位</span></span><br><span class="line">    block_split(idx, k); <span class="comment">//分裂</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = min(block_sz, n - i);</span><br><span class="line">        <span class="keyword">int</span> tot = new_block();</span><br><span class="line">        <span class="built_in">memcpy</span>(g[tot].s, str + i, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        g[tot].sz = sz;</span><br><span class="line">        g[tot].next = g[idx].next, g[idx].next = tot, idx = g[idx].next;</span><br><span class="line">        i += sz;</span><br><span class="line">    &#125;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_delete</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//删去全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next) del_block(i);</span><br><span class="line">    g[st].next = en_next;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_rev</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//翻转全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp[block_num], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].rev ^= <span class="number">1</span>;</span><br><span class="line">        tmp[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[++cnt] = st, tmp[<span class="number">0</span>] = en_next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) g[tmp[i]].next = tmp[i<span class="number">-1</span>];</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//打印全局的第k个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">if</span>(k == g[idx].sz) idx = g[idx].next, k = <span class="number">0</span>;<span class="comment">//输出字符时特判一下，用下面的输出函数不用特判</span></span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, g[idx].s[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//打印全局的第k个元素后的长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">0</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        block_update(i);</span><br><span class="line">        <span class="keyword">int</span> sz = min(n, g[i].sz - k);</span><br><span class="line">        <span class="built_in">memcpy</span>(str + len, g[i].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        len += sz, n -= sz;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cur = <span class="number">0</span>;<span class="comment">//光标位置，初始为0</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    block_init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len) &#123;<span class="keyword">char</span> ch = getchar();<span class="keyword">if</span>(ch &gt;= <span class="number">32</span> &amp;&amp; ch &lt;= <span class="number">126</span>) str[i++] = ch;&#125;</span><br><span class="line">            str[i++] = <span class="string">'\0'</span>;</span><br><span class="line">            block_insert(cur, len, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_delete(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'R'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_rev(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'G'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            block_print(cur);</span><br><span class="line">            <span class="comment">//block_print(cur, 1, str);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>) cur--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'N'</span>) cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;块状链表应该算一个额外拓展的知识吧，貌似不属于正规的算法，也算是一种比较中庸的数据结构，中和了一下数组和链表的优缺点，形成了一个新的数据结构就是块状链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分图</title>
    <link href="http://yoursite.com/2018/08/21/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/08/21/二分图/</id>
    <published>2018-08-21T05:40:02.000Z</published>
    <updated>2018-08-26T12:00:34.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图的判断"><a href="#二分图的判断" class="headerlink" title="二分图的判断"></a>二分图的判断</h2><p>二分图的判断主要是利用染色法来判断所有相连的边是否有回路，依次给每个点染色，每个相邻的点染的颜色不同，如果发现，两个颜色颜色一样了则说明有回路。则不是二分图。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">color[v] = c;<span class="comment">//给当前节点染色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == c)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果两个直接相连的点颜色相同则有回路</span></span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == <span class="number">0</span> &amp;&amp; !dfs(g[v][i],-c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//0表示还没有染色的点，1，-1交替染色</span></span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i] &amp;&amp; !dfs(i,<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果一个点没有染色的点发现了回路则不是二分图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分最大匹配"><a href="#二分最大匹配" class="headerlink" title="二分最大匹配"></a>二分最大匹配</h2><p>二分图的最大匹配实际上可以转换为网络流里面的最大流问题，每个相连的边可以看成一个容量为1的一条边，然后增加一个源点和汇点分别连一条容量为1的边到二分图的左边和右边节点。最后最大匹配数就是源点和汇点的最大流。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  g[x].size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u = g[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[u] == <span class="number">-1</span> || find(match[u]))&#123;</span><br><span class="line">match[u] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(find(i))res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带权二分图"><a href="#带权二分图" class="headerlink" title="带权二分图"></a>带权二分图</h2><p>匈牙利算法只能解决最大二分匹配数目的问题，如果遇上了每条边都带有权值，那么就需要用到km算法，来计算权值最大的二分匹配方案。</p><p>实际上，二分匹配的算法都是基于贪心的思想，通过搜索找到当前最优解，不停搜索下去，遇到搜索失败再回头寻找新的匹配方案。这里的km算法就是基于这种思想。首先二分图的两边都有一个期望值，然后把左边的期望初始化为与它相连所有边的最大权值，右边都初始化为零，然后开始匹配，如果找到左右期望最大的匹配方案则匹配成功。否则所有左边尝试匹配过的节点都降低一个期望，右边尝试匹配过的节点都增加相同的期望，这样保证了期望和不变。然后继续搜索，匹配不成功就降低期望，直到匹配成功。时间复杂度为<code>O(n^3)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//左右两边的匹配数目</span></span><br><span class="line"><span class="keyword">int</span> match[<span class="number">10001</span>],slack[<span class="number">10001</span>],e[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> lx[<span class="number">10001</span>],ly[<span class="number">10001</span>],visx[<span class="number">10001</span>],visy[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">visx[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;<span class="comment">//右边的节点值每次搜索只匹配一次</span></span><br><span class="line"><span class="keyword">int</span> gap = lx[v] + ly[i] - e[v][i];<span class="comment">//左右期望值之和和相连边的差值</span></span><br><span class="line"><span class="keyword">if</span>(!gap)&#123;</span><br><span class="line">visy[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[i] == <span class="number">-1</span> || dfs(match[i]))&#123;<span class="comment">//如果右边没有匹配成功或者尝试调整和它匹配成功的左节点</span></span><br><span class="line">match[i] = v;<span class="comment">//匹配成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">slack[i] = min(slack[i],gap);<span class="comment">//记录一下期望和实际的差值，如果匹配失败就减去最小的一个差值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));<span class="comment">//右边期望初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">lx[i] = -INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">lx[i] = max(lx[i],e[i][j]);<span class="comment">//左边期望初始化为所有与之相连边中的最大权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//依次给每个左节点匹配</span></span><br><span class="line"><span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span>(slack));<span class="comment">//差值初始化为无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//不断匹配，直到匹配成功</span></span><br><span class="line"><span class="built_in">memset</span>(visx,<span class="number">0</span>,<span class="keyword">sizeof</span>(visx));</span><br><span class="line"><span class="built_in">memset</span>(visy,<span class="number">0</span>,<span class="keyword">sizeof</span>(visy));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dfs(i))<span class="keyword">break</span>;<span class="comment">//匹配成功退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visy[j])</span><br><span class="line">d = min(d,slack[j]);<span class="comment">//找到最小的期望和实际的差值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visx[j])lx[j] -= d;<span class="comment">//匹配失败左边降低期望</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[j])ly[j] += d;<span class="comment">//右边增加期望</span></span><br><span class="line"><span class="keyword">else</span>slack[j] -= d;<span class="comment">//因为左边期望降低，所以没有访问过的期望差值也降低</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[i] != <span class="number">-1</span>)</span><br><span class="line">res += e[match[i]][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//返回所有最大权值边之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二分图的判断&quot;&gt;&lt;a href=&quot;#二分图的判断&quot; class=&quot;headerlink&quot; title=&quot;二分图的判断&quot;&gt;&lt;/a&gt;二分图的判断&lt;/h2&gt;&lt;p&gt;二分图的判断主要是利用染色法来判断所有相连的边是否有回路，依次给每个点染色，每个相邻的点染的颜色不同，如果发现，两个颜色颜色一样了则说明有回路。则不是二分图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
</feed>
