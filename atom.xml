<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.tree</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T04:50:05.694Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>aoboxia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="http://yoursite.com/2019/10/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/10/15/hexo搭建博客/</id>
    <published>2019-10-15T03:15:28.000Z</published>
    <updated>2019-10-17T04:50:05.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客是作为一个程序猿的标配，由于工作的原因，我们记录笔记的方式早已不是高中阶段的在笔记本上用手抄的形式。作为一个计算机的从业者，我们后面会接触到很多新的知识点和技术。我们应当学会在互联网上记录自己这些心得笔记，所以搭建一个属于自己的个人博客就显得很有必要了。</p><p>首先要明确一点，就是我们的目的不仅仅是学会搭建博客，博客只是一个个人平台。更重要的是养成定期写博客，更新技术笔记的习惯。</p><a id="more"></a><p><strong>注意：比较心急的同学可跳过介绍部分，直接按如下步骤进行配置即可：</strong></p><p><a href="#1">1.安装Git</a><br><a href="#2">2.安装NodeJs</a><br><a href="#3">3.安装Hexo</a><br><a href="#4">4.创建Github仓库</a></p><!-- > [我的Hexo博客地址](https://aoboxia.github.io) --><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="1-Git"><a href="#1-Git" class="headerlink" title="1.Git"></a>1.Git</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Git是当下<strong>全球</strong>计算机从业者使用最多一个代码版本控制工具，也是我们<strong>必须</strong>要掌握并熟练使用的一个工具。我们能够使用它进行代码的备份，回退。并且在多人开发时，能够进行代码合并。通常，大型的项目开发都必须使用Git进行版本控制，开发人员负责提交代码，项目经理负责代码的合并，这一切都是采用Git来完成的。</p><h4 id="Git和Github"><a href="#Git和Github" class="headerlink" title="Git和Github"></a>Git和Github</h4><p>目前有很多同学都不清楚Git和Github之间的区别，认为Git就等同于Github。实际上两者是完全不同的，Github只是一个网站，一个专门用于存储Git上传的代码仓库。我们将本地的代码使用Git上传到Github上面托管，我们所有的数据都存储在上面，多人开发时，也是大家同时使用Github上面的同一个仓库进行代码管理。</p><p>所以，<a href="https://baike.baidu.com/item/Git/12647237" title="Git" target="_blank" rel="noopener">Git</a>是一个工具，<a href="https://github.com" title="Github" target="_blank" rel="noopener">Github</a>是当下全球最大的一个开源代码托管平台。全世界的程序员都将代码放到上面进行托管，各种开源的语言、库都可以在上面找到源代码。国内也有类似的代码网站，由于Github是一个国外的网站，</p><p>所以国内访问加载和上传速度都很慢，所以我们有时候采用国内的<a href="https://gitee.com" title="码云" target="_blank" rel="noopener">码云</a>。功能和使用方法都是一样的，只不过一个在国内一个在国外。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a id="1"></a><br>Git是一个开源的工具，可以直接在官网下载然后通过一键安装即可。这里我们选择一个Git Bash一键安装Git，如果电脑不是windows系统自行下载相应的系统的版本即可。</p><ul><li><a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git下载地址</a></li><li><strong>安装步骤</strong>: 直接运行exe文件，全部next，不用修改任何配置即可</li><li>安装完成，在任意文件夹下右键即会出现Git Bash选项，点击进入Git Bash界面，输入<code>git version</code>指令出现Git的版本信息则表示安装成功</li></ul><h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>node.js是运行在服务端的JavaScript，通常我们知道的CSS/HTML/JS是网页前端开发的标准三件套。HTML负责搭建网页的主体框架和布局，CSS负责跳转每个版块之间的间距，各种控件的颜色大小等等，JS则用于实现网页上的一些动态元素，例如一些动画效果，并接受一些动态的参数。通常JS作为一种胶水语言都是用于前端开发的。</p><p>但是node.js为js搭建了一个平台，使得js也能像Java/Python/PHP一样用于后台开发。由于我们使用的hexo框架是基于node.js实现的一个博客框架，所以我们首先要搭建一个服务端的JS环境。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><a id="2"></a></p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJs下载地址</a>(下载LTS版本)</li><li>下载好msi文件后，也是一键安装，不过记得在Custom Setup这一步勾选下面的<code>Add To PATH</code>，把node添加到你电脑的环境变量中</li><li>在任意文件夹下打开Git bash，输入<code>node -v</code>出现了node的版本信息即为安装成功</li></ul><p>如果安装时忘记勾选<code>Add to PATH</code>，可以在电脑左下角搜索编辑系统环境变量，点击打开，点击环境变量，然后再用户配置或者系统配置中<code>Path</code>点击编辑，将你的node.js的bin文件目录添加进去即可。</p><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://hexo.io/zh-cn/docs/index.html" title="Hexo文档" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>简单来说，就是一个别人写好的博客网站模板，你直接下载下来试用就可以了。并且hexo支持便捷的更换网站主题，就像你的电脑更换壁纸一样，你可以在网上下载一个hexo主题，复制到相应的文件夹下就可以一键更换你整个网站的界面和功能了。</p><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><p><a id="3"></a></p><ul><li>创建一个文件夹用于存放整个博客网站的文件，建议和你的仓库一样命名为<code>yourname.github.io</code></li><li>进入该文件夹右键进入Git bash界面</li><li>先使用<code>git --version</code>和<code>node -v</code>确认都能正常出现版本信息没有报错方可进入下一步<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/git-node-version.png" alt="版本信息"></li><li>输入<code>npm install -g hexo-cli</code>，安装hexo指令<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/npm.png" alt="npm"></li><li>输入<code>hexo -v</code>确认指令安装成功<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexo.png" alt="npm"></li><li>确认上一步没有报错后，使用<code>hexo init</code>进行hexo博客框架的初始化<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexoinit.png" alt="npm"><br>安装完成后，会出现如下文件夹<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexoinit2.png" alt="npm"></li><li>解释一下<ul><li>node_modules：是node.js的依赖包</li><li>public：存放的是生成的网页前端页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：存放你的markdown博客文件</li><li>themes：网站主题，可自行下载，默认是<code>landscape</code></li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li></ul><p>到此我们的博客就已经在本地搭建完成了，依次输入下面三个指令可以在本地预览博客的效果：</p><ul><li><code>hexo clean</code> 清空hexo缓存</li><li><code>hexo generate</code>根据markdown文件生成相应的资源文件</li><li><code>hexo server</code>在电脑本地运行hexo服务<br>看到如下信息，就代表你的hexo博客已经在本地运行起来了，可以在浏览器中打开<code>http://localhost:4000</code>进入博客，按<code>Ctrl+c</code>关闭服务。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/hexos.png" alt="本地运行Hexo"></li></ul><h3 id="4-连接Github"><a href="#4-连接Github" class="headerlink" title="4.连接Github"></a>4.连接Github</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>Github是全面全球最大的一个代码托管平台，他是有许许多多的代码仓库构成，每个人都可以创建仓库，并且仓库的所有代码都是公开的，因此我们能在上面找到各种项目各种语言的源代码。今后我们学习和工作会与它密不可分。学习世界上最顶尖的大牛、最优秀的开源框架的代码也是一种极快提升我们视野和能力的途径。</p><p>刚才我们只是本地运行了Hexo博客，这里我们要做的是将我们本地的hexo博客的文件夹上传到Github的仓库当中，让所有人都能访问到我们的博客。Github为我们每个注册的用户免费提供了一个<code>https://yourname.github.io</code>的域名，因此我们可以将Github当成服务器运行我们博客网站。每次我们需要写博客就在本地写好之后同步提交到Github，然后我们的博客也能自动更新。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><a id="4"></a></p><ul><li>首先你需要到<a href="https://github.com" target="_blank" rel="noopener">Github</a>使用邮箱注册一个账号</li><li>然后创建一个repository(仓库)<br>仓库的名字一定要是<code>yourname.github.io</code><br><strong>例如:</strong> 我的用户名是<code>ctguqmx</code>然后我们仓库名就是<code>ctguqmx.github.io</code><br>因为Github只为我们提供这一个可以访问的域名<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/github.png" alt="创建仓库"></li></ul><h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><p>网上有很多方法是使用ssh连接Github，但是由于初学者难以理解，这里我们采用在url链接中直接使用账号密码的方式连接Github</p><ul><li>打开的hexo博客文件夹，右键进入Git Bash</li><li>输入<code>git init</code>，该指令用于将该文件夹初始化为一个Git仓库，会生成一个<code>.git</code>文件用于存储该仓库的一些信息</li><li>输入<code>git remote add origin https://用户名:密码@github.com/xxx/xxx.git</code>该指令用于指定远程仓库的地址。仓库的最上方可以查看该网址，每个仓库都有两个网址作为该仓库的唯一标识，分别是<code>https://xxx</code>和<code>git@github:xxx</code><br>这里我们使用https的这个并在链接的中间加入自己的账号密码，<strong>注意修改成你自己的github账号密码和仓库地址</strong>。最后我们是通过这个链接中的账号密码来登录Github的。<br><strong>例如:</strong> 我的是<code>git remote add origin https://ctguqmx:mypassword@github.com/ctguqmx/ctguqmx.github.io.git</code></li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/giturl.png" alt="github仓库的连接"></p><ul><li>输入<code>git config --global user.name &quot;yourname&quot;</code>和<code>git config --global user.email &quot;youremail&quot;</code><br>设置你的用户名和注册邮箱地址</li></ul><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/gitconfig.png" alt="本地git的配置"></p><ul><li><p>修改hexo配置文件，打开博客根目录下的<code>_config.yml</code>文件，翻到最下面，按照如下方式修改，注意用你的自己的仓库链接，并且<code>:</code>后面有一个空格，多了或者少了都会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>最后使用<code>npm install hexo-deployer-git --save</code>安装一个插件，hexo3不自带Git上传功能。</p></li></ul><p><strong>常见错误:</strong> </p><ol><li><code>fatal: remote origin already exits.</code><br>原因：你已经绑定过了远程仓库的链接<br>解决办法：<code>git remote rm origin</code>删除链接，然后再用<code>git remote add http://xxx</code></li><li><code>fatal: Authentication failed for &#39;https://github.com/xxx/xxx.git&#39;</code><br>原因：账号或者密码错误<br>解决办法：<code>git remote -v</code>查看的你绑定的链接中的账号密码是否正确</li><li><code>Template render error: (unknown path)</code><br>原因：你写的Markdown博客文件语法错误，无法解析<br>解决办法: 找到相应的语法错误并修正</li></ol><h4 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h4><p>现在我们可以开始部署我们的博客了</p><ul><li>在浏览器中打开<code>http://localhost:4000</code></li><li>看到界面就代表你成功了</li><li>最后按<code>Ctrl+c</code>停止本地服务</li><li>使用<code>hexo deploy</code>将项目发布到github上</li><li>在浏览器中打开<code>https://yourname.github.io</code></li><li>看到界面就代表你真的成功了</li></ul><h3 id="5-开始动手写一篇博客吧"><a href="#5-开始动手写一篇博客吧" class="headerlink" title="5.开始动手写一篇博客吧"></a>5.开始动手写一篇博客吧</h3><p>下面我将展示写一篇博客的常规操作</p><ul><li><code>hexo new &quot;my_first_blog&quot;</code></li><li>进入到博客文件夹的<code>source/_posts</code>目录下应该可以看一个<code>my_first_blog.md</code>的文件</li><li>你可以使用markdown的语法开始编写一篇博客了。具体语法可以参考<a href="http://xianbai.me/learn-md/index.html" target="_blank" rel="noopener">markdown语法</a></li><li><code>hexo g -d</code>是上<code>hexo generate</code>和<code>hexo deploy</code>的简写，直接一键发布</li></ul><h3 id="6-换一个更好看的主题"><a href="#6-换一个更好看的主题" class="headerlink" title="6.换一个更好看的主题"></a>6.换一个更好看的主题</h3><p>hexo默认为我们提供了一个网站的主题，实际上我们可以自己在github上下载更多更加好看，并且功能强大的主题来替换掉我们原有的主题，并且更换起来十分方便，基本上是一键切换。</p><p>我们可以自行在网上搜索<strong>hexo主题</strong>，便会出来很多供我们选择，配置起来也很简单。例如我的博客就是在<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的hexo主题 -知乎</a>上面找到的。下面我将以我们所用的主题为例，来实验一下如何切换hexo主题。<br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia.png" alt="yilia"></p><ol><li>首先选定一款hexo主题找到他的github仓库地址。例如我的是：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a><br><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/yilia_github.png" alt="yilia_github"></li><li>进入到你的博客文件夹下的themes文件夹，里面初始应该只有一个<code>landscape</code>主题，也就是你当前博客所使用的主题</li><li><p>打开Git Bash输入<code>git clone http://xxx.git</code>，将仓库克隆到本地，也可以在仓库右上角直接下载压缩包解压到themes文件夹下，但是注意要修改文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git yilia</span><br></pre></td></tr></table></figure></li><li><p>修改博客根目录下的 _config.yml文件，修改themes: yilia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia</span><br></pre></td></tr></table></figure></li><li><p>进入<code>yilia</code>文件夹，修改_config.yml文件(不是根目录下面的那个)，内容参考<a href="https://github.com/litten/BlogBackup/blob/master/_config.yml" target="_blank" rel="noopener">yilia参考配置</a></p></li><li>OK，主题切换完成，写博客的基本步骤和原来一样</li></ol><h3 id="7-改进空间"><a href="#7-改进空间" class="headerlink" title="7.改进空间"></a>7.改进空间</h3><p>其实上面只是简单复制了别人写好的博客网站，实际上我们还有更大的开发空间和写博客的一些必备技能。我这里详细展开，仅提供一些可以自己学习的方向。</p><h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p>前面已经说过了，Hexo是一款专门针对markdown的博客框架，也就是说我们的博客必须都是用markdown文件，因此我们必须要学习markdown的基本语法来编写博客，实际上markdown的语法非常简单，总共的语法也只有几十条，在编写博客时顺带查询markdown语法即可。本文就是由markdown自动生成，无需任何手动排版。</p><h4 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h4><p>其实我们可以在原有的主题的基础上进行二次开发，增加一些新的功能，例如我们经常在别人博客中看到的一些动态水墨效果，点击出现爱心等特效，还有博客的点赞评论，网站的流量统计等等，网上都有相应的JS插件，配置也十分简单，网上也有大量的教程，可自行学习。</p><h4 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h4><p>后面大家在编写博客时肯定会出现一个问题，就是数学公式怎么编辑，实际上Markdown中可以直接使用Latex进行数学公式的编辑，Latex可以用编程的方式来编写出一个数学公式，同样的，用Latex编辑数学公式，也是我们学习计算机的一个基本技能。我建议和Markdown一样，大家都可以从需求出发，需用到什么就学相应的语法来完成你的需求，从用中学，从而达到熟能生巧。</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>我们在编写博客时，经常需要插入一些图片，我们可以在Source文件下新建一个文件专门用来存储图片，然后再Markdown博客中用<strong>相对路径</strong>来引入图片。图片会随着你的博客项目一起推送到Github当中，但是这种往往加载速度很慢，加上Github容量有限并且是国外的服务器。</p><p>这里我们可以单独将我们的图片文件上传到第三方的服务器上，然后直接通过图片的url来访问。目前常用的用阿里云和七牛云，新建一个存储空间用来存放图片，基本都有一定免费的存储额度。并且他们有专业的图片加速算法，通常加载速度都非常快。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>我们默认的使用的是Github提供给我们的域名，实际上我们可以自己申请一个域名，来替换掉这个域名，阿里云，腾讯云等等都能进行域名的申请，例如我使用<code>.top</code>的域名，一年只有几块钱，<code>.com</code>一年大概50~60。申请一个自己的个人域名后面也会大有用处，至于后续的域名备案，大家可自行摸索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客是作为一个程序猿的标配，由于工作的原因，我们记录笔记的方式早已不是高中阶段的在笔记本上用手抄的形式。作为一个计算机的从业者，我们后面会接触到很多新的知识点和技术。我们应当学会在互联网上记录自己这些心得笔记，所以搭建一个属于自己的个人博客就显得很有必要了。&lt;/p&gt;
&lt;p&gt;首先要明确一点，就是我们的目的不仅仅是学会搭建博客，博客只是一个个人平台。更重要的是养成定期写博客，更新技术笔记的习惯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>NFL定理</title>
    <link href="http://yoursite.com/2019/08/04/NPL%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/04/NPL定理/</id>
    <published>2019-08-04T03:28:52.000Z</published>
    <updated>2019-08-04T09:00:40.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>前提：<br>所有“问题”出现的机会相同，火速有问题同等重要(均匀分布)<br>NFL定理(No Free Lunch Theorem), 没有免费的午餐定理， 任意两个学习算法$\varepsilon_{a}$和$\varepsilon_{a}$,他们的期望性能相同。</p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><blockquote><p>假设样本空间$\chi$是离散的, 令$P(h|x,\varepsilon_{a})$代表算法$\varepsilon_{a}$基于训练数据X产生假设h的概率，再令$f$代表我们希望学习的真实目标函数</p></blockquote><p>则有：$\varepsilon_{a}$在训练集之外的所有样本上的误差为</p><script type="math/tex; mode=display">E_{ote}(\varepsilon_{a}|X,f)=\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})</script><p>其中：<br>$\sum_{h}$代表对算法$\varepsilon_{a}$所产生的多个假设的概率求和<br>$\sum_{x\in\chi-X}$代表训练集之外的所有样本<br>$P(x)$代表每个样本x被选中的概率<br>$\prod(h(x)\not=f(x))$代表当前的假设是否和期望值相等,若不等则取值为1,否则取值为0</p><p>考虑二分类问题，且真实目标函数可以是任何函数$\chi\rightarrow\{0,1\}$,函数空间为$\{0,1\}^{|x|}$,对所有可能的f按均匀分布对误差求和</p><script type="math/tex; mode=display">\begin{aligned}\sum_{f}E_{ote}(\varepsilon_{a}|X,f)&=\sum_{f}\sum_{h}\sum_{x\in\chi-X}P(x)\prod(h(x)\not=f(x))P(h|X,\varepsilon_{a})\\&=\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,\varepsilon_{a})\sum_{f}\prod(h(x)\not=f(x))\\&=\sum_{x\in\chi-X}P(x)*1*\frac{1}{2}2^{\chi}\\&=2^{|\chi|-1}\sum_{x\in\chi-X}P(x)\end{aligned}</script><p>由上式可以看出，总误差和算法无关，也就是说任意两种算法的期望性能相同的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;p&gt;前提：&lt;br&gt;所有“问题”出现的机会相同，火速有问题同等重要(均匀分布)&lt;br&gt;NFL定理(No Free Lunch Theorem), 没有免费的午餐定理， 任意两个学习算法$\varepsilon_{a}$和$\varepsilon_{a}$,他们的期望性能相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vim编辑器</title>
    <link href="http://yoursite.com/2019/08/01/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/08/01/vim常用快捷键/</id>
    <published>2019-08-01T03:28:52.000Z</published>
    <updated>2019-08-04T08:37:57.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim的基础配置"><a href="#vim的基础配置" class="headerlink" title="vim的基础配置"></a>vim的基础配置</h2><p>Vim 的全局配置一般在<code>/etc/vim/vimrc</code>或者<code>/etc/vimrc</code>，对所有用户生效。用户个人的配置在<code>~/.vimrc</code></p><a id="more"></a><p>配置项一般都有”打开”和”关闭”两个设置。”关闭”就是在”打开”前面加上前缀”no”。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 显示行号</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="comment">" tab/缩进空格数</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> </span><br><span class="line"><span class="comment">" 整行左右缩进空格数, &lt;&lt;左缩进, &gt;&gt;右缩进, =取消全部缩进</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"><span class="comment">" 在行首时tab缩进shiftwidth大小空格, 默认tab都缩进tabstop大小</span></span><br><span class="line"><span class="keyword">set</span> smarttab</span><br><span class="line"><span class="comment">" 采用C语言缩进风格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span></span><br><span class="line"><span class="comment">" 不进行备份</span></span><br><span class="line"><span class="keyword">set</span> nobackup</span><br><span class="line"><span class="comment">" 不产生swap文件（通常非正常退出都会产生.swap文件）</span></span><br><span class="line"><span class="keyword">set</span> noswapfile</span><br><span class="line"><span class="comment">" 支持使用鼠标</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span></span><br><span class="line"><span class="comment">" 背景风格</span></span><br><span class="line"><span class="keyword">colo</span> torte</span><br><span class="line"><span class="comment">" 开启语法高亮</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br></pre></td></tr></table></figure><h2 id="vim的常用快捷键"><a href="#vim的常用快捷键" class="headerlink" title="vim的常用快捷键"></a>vim的常用快捷键</h2><p>快捷键都是normal模式下使用</p><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><blockquote><p><code>i</code> 切换到插入模式（编辑模式）<br><code>[esc]</code> 退出到normal模式<br><code>v</code> 切换到视图模式（可选中）</p></blockquote><h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h3><blockquote><p><code>:w</code> —&gt; 报错<br><code>:q</code> —&gt; 退出<br><code>:!</code> —&gt; 强制<br><code>:wq!</code> —&gt; 先保存后强制退出</p></blockquote><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><blockquote><p><code>y</code> —&gt; 复制<br><code>yy</code> —&gt; 复制当前行<br><code>p</code> —&gt; 粘贴<br><code>dd</code> —&gt; 删除当前行, 同时会复制<br><code>x</code> —&gt; 删除光标所在字符<br><code>u</code> —&gt; 撤销</p></blockquote><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><blockquote><p><code>hjkl</code> 分别对应 ←↑↓→<br><code>w</code> —&gt; 到下一个单词的开头<br><code>e</code> —&gt; 到下一个单词的结尾<br><code>0</code> —&gt; 到行头<br><code>$</code> —&gt; 到行尾<br><code>^</code> —&gt; 到本行第一个非blank字符<br><code>g_</code>—&gt; 到本行最后一个非blank字符<br><code>%</code> —&gt; 光标移动到最近的括号上,左右括号来回切换<br><code>#</code> —&gt; 到光标所在单词上一个相同单词<br><code>*</code> —&gt; 到光标所在单词下一个相同单词<br><code>gg</code>—&gt; 到文件开头<br><code>G</code> —&gt; 到文件结尾</p></blockquote><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><blockquote><p><code>split</code> 当前文件水平分屏<br><code>vplit</code> 当前文件垂直分屏<br><code>new</code> 水平分屏一个新文件<br><code>vnew</code> 垂直分屏一个新文件<br><code>Ctrl+w+hjkl</code> 切换分屏</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vim的基础配置&quot;&gt;&lt;a href=&quot;#vim的基础配置&quot; class=&quot;headerlink&quot; title=&quot;vim的基础配置&quot;&gt;&lt;/a&gt;vim的基础配置&lt;/h2&gt;&lt;p&gt;Vim 的全局配置一般在&lt;code&gt;/etc/vim/vimrc&lt;/code&gt;或者&lt;code&gt;/etc/vimrc&lt;/code&gt;，对所有用户生效。用户个人的配置在&lt;code&gt;~/.vimrc&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Unicode与UTF-8编码</title>
    <link href="http://yoursite.com/2019/02/16/Unicode%E4%B8%8EUTF-8%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2019/02/16/Unicode与UTF-8编码/</id>
    <published>2019-02-16T04:01:18.000Z</published>
    <updated>2019-02-16T05:59:34.698Z</updated>
    
    <content type="html"><![CDATA[<p>首先确定一个问题,无论采用何种编码方式,最后在计算机当中一定是以二进制的形式存储的。至于编码方式,则是将具体的字符和二进制之间的一个对照关系。</p><a id="more"></a><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p><code>ASCII</code>是最早出现的编码方式,是美国用来将26个字母和一些英文字符和二进制对应起来的一种编码方式,<code>ASCII</code>一共规定了128个字符的二进制表示,只需要用到7位二进制数,首位统一规定为0.</p><h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>由于世界上各地语言存在差异,因此存在着各种千奇百怪的符号,并且相同的符号在不同的地区可能表示不同的意思.因此一个字节8位的编码方式远远不能满足需求。因此有了<code>Unicode</code>,<code>Unicode</code>实际上是一个字符集，它是<code>ASCII</code>的一个扩充版,他将全世界所有的字符全部包含其中，并且规定所有字符的二进制表示。它共包含了100多万种字符的二进制表示方式。全世界出现的所有的字符都在这个表中有唯一的表示方法。因此解决各国字符不兼容的问题。</p><p><code>Unicode</code>实际上只规定每个字符的二进制表示方法,但并没有给出每个字符的具体存储方式。与此同时也带来一些问题。例如,如何将<code>Unicode</code>和其他的编码方式区分开来,<code>ASCII</code>用一个字节来表示字符,而<code>Unicode</code>可能采用多个字节来表示一个字符。如何知道我在表示一个字符时到底是采用的一位还是两位甚至更多呢？另外,如果把所有字符统一规定为四位甚至五位，那么必然会带来极大的内存浪费。</p><p>但是为了区分不同的字符,必然是需要唯一确定的二进制表示的,但是我们对<code>Unicode</code>可以采用不同的实现方式。</p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p><code>UTF-8</code>实际上就是目前最常用的一种<code>Unicode</code>的实现方式。他为了解决直接采用<code>Unicode</code>存储带来的内存浪费,采用了一个可变长编码的方式,就是<code>Unicode</code>编码的不同范围的字符采用不同的字节表示,例如小字符采用一个字节表示，大一点的采用两位。每个字符表示的字节数是可长可短的。具体采用几位字节表示在首位用1的个数给出。具体规则如下：</p><blockquote><p>1）对于<code>单字节</code>的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 <code>Unicode</code> 码。因此对于英语字母，<code>UTF-8</code> 编码和 <code>ASCII</code> 码是相同的。</p><p>2）对于<code>n</code>字节的符号(n &gt; 1)，第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 <code>Unicode</code> 码。</p></blockquote><p>具体编码方式如下：<br><table>   <thead>    <tr>      <th>Unicode符号范围(十六进制)</th>      <th>UTF-8编码方式(二进制)</th>    </tr>  </thead>  <tbody>    <tr>      <td>0000 0000-0000 007F</td>       <td>0xxxxxx</td>    </tr>    <tr>      <td>0000 0080-0000 07FF</td>      <td>110xxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0000 0800-0000 FFFF</td>      <td>1110xxxx 10xxxxxx 10xxxxxx</td>    </tr>    <tr>      <td>0001 0000-0010 FFFF</td>      <td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>    </tr>  </tbody></table></p><p>如果一个字节的第一位是<code>0</code>，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个<code>1</code>，就表示当前字符占用多少个字节。</p><p>以<code>夏</code>为例,<code>夏</code>的<code>Unicode</code>表示为<code>590F</code>(‭<code>0101100100001111</code>‬),由上表可知,<code>夏</code>在第三行的范围当中,因此将<code>夏</code>的二进制数从右到左一次填入第三行的<code>x</code>当中,高位未填完的<code>x</code>补<code>0</code>,最后得到<code>夏</code>的<code>UTF-8</code>的二进制表示为<code>11100101 10100100 10001111</code>,十六进制表示为<code>‭E5A48F‬</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先确定一个问题,无论采用何种编码方式,最后在计算机当中一定是以二进制的形式存储的。至于编码方式,则是将具体的字符和二进制之间的一个对照关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="http://yoursite.com/2019/01/01/stl/"/>
    <id>http://yoursite.com/2019/01/01/stl/</id>
    <published>2019-01-01T10:32:41.000Z</published>
    <updated>2019-05-20T12:04:15.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stl-config-h中的各种组态-configuration"><a href="#stl-config-h中的各种组态-configuration" class="headerlink" title="stl_config.h中的各种组态(configuration)"></a>stl_config.h中的各种组态(configuration)</h2><h3 id="STL-STATIC-TEMPLATE-MEMBER-BUG"><a href="#STL-STATIC-TEMPLATE-MEMBER-BUG" class="headerlink" title="__STL_STATIC_TEMPLATE_MEMBER_BUG"></a>__STL_STATIC_TEMPLATE_MEMBER_BUG</h3><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试在class template 中拥有 static data members. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">int</span>&gt;::_data = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> testClass&lt;<span class="keyword">char</span>&gt;::_data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">int</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; testClass&lt;<span class="keyword">char</span>&gt;::_data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">testClass&lt;<span class="keyword">int</span>&gt; obji1, obji2;</span><br><span class="line">testClass&lt;<span class="keyword">char</span>&gt; objc1, objc2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">obji1._data = <span class="number">3</span>;</span><br><span class="line">objc2._data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; obji2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc1._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; objc2._data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-CLASS-PARTIAL-SPECIALIZATION"><a href="#STL-CLASS-PARTIAL-SPECIALIZATION" class="headerlink" title="__STL_CLASS_PARTIAL_SPECIALIZATION"></a>__STL_CLASS_PARTIAL_SPECIALIZATION</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test __STL_FUNCTION__TMPL_PARTIAL_ORDER in &lt;stl_config.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;T, Alloc&gt;&amp;)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"swap()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x,y;</span><br><span class="line">swap(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-MEMBER-TEMPLATES"><a href="#STL-MEMBER-TEMPLATES" class="headerlink" title="__STL_MEMBER_TEMPLATES"></a>__STL_MEMBER_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试class template 之内可否再有 template (members)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insert</span>(<span class="title">iterator</span> <span class="title">position</span>, <span class="title">I</span> <span class="title">first</span>, <span class="title">I</span> <span class="title">last</span>) &#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"insert()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line">x.insert(ite, ia, ia+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-LIMITED-DEFAULT-TEMPLATES"><a href="#STL-LIMITED-DEFAULT-TEMPLATES" class="headerlink" title="__STL_LIMITED_DEFAULT_TEMPLATES"></a>__STL_LIMITED_DEFAULT_TEMPLATES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 template 参数可否根据前一个 template 参数而设定默认值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; // for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">deque</span>() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deque"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; x; <span class="comment">//deque</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-NON-TYPE-TEMP-PARAM-BUG"><a href="#STL-NON-TYPE-TEMP-PARAM-BUG" class="headerlink" title="__STL_NON_TYPE_TEMP_PARAM_BUG"></a>__STL_NON_TYPE_TEMP_PARAM_BUG</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 class template 可否拥有 non-type template 参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstddef&gt; //for size_t</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)&#123;</span><br><span class="line"><span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//Iterator</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>,alloc,64&gt;::iterator::buffer_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1、容器-container"><a href="#1、容器-container" class="headerlink" title="1、容器(container)"></a>1、容器(container)</h2><h2 id="2、算法-algorithm"><a href="#2、算法-algorithm" class="headerlink" title="2、算法(algorithm)"></a>2、算法(algorithm)</h2><h2 id="3、迭代器-iterators"><a href="#3、迭代器-iterators" class="headerlink" title="3、迭代器(iterators)"></a>3、迭代器(iterators)</h2><h2 id="4、仿函数-functors"><a href="#4、仿函数-functors" class="headerlink" title="4、仿函数(functors)"></a>4、仿函数(functors)</h2><h2 id="5、配接器-adapters"><a href="#5、配接器-adapters" class="headerlink" title="5、配接器(adapters)"></a>5、配接器(adapters)</h2><h2 id="6、配置器-allocators"><a href="#6、配置器-allocators" class="headerlink" title="6、配置器(allocators)"></a>6、配置器(allocators)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;stl-config-h中的各种组态-configuration&quot;&gt;&lt;a href=&quot;#stl-config-h中的各种组态-configuration&quot; class=&quot;headerlink&quot; title=&quot;stl_config.h中的各种组态(configuration)&quot;&gt;&lt;/a&gt;stl_config.h中的各种组态(configuration)&lt;/h2&gt;&lt;h3 id=&quot;STL-STATIC-TEMPLATE-MEMBER-BUG&quot;&gt;&lt;a href=&quot;#STL-STATIC-TEMPLATE-MEMBER-BUG&quot; class=&quot;headerlink&quot; title=&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG&quot;&gt;&lt;/a&gt;__STL_STATIC_TEMPLATE_MEMBER_BUG&lt;/h3&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="stl" scheme="http://yoursite.com/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>linux笔记</title>
    <link href="http://yoursite.com/2018/12/15/linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/15/linux笔记/</id>
    <published>2018-12-15T08:59:52.000Z</published>
    <updated>2019-10-16T11:11:20.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切换python优先级"><a href="#切换python优先级" class="headerlink" title="切换python优先级"></a>切换python优先级</h2><ol><li>设置优先级<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 <span class="number">100</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150</span><br></pre></td></tr></table></figure><ol><li>切换版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config python</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://aoboxia.oss-cn-hongkong.aliyuncs.com/github.io/linux-01.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;切换python优先级&quot;&gt;&lt;a href=&quot;#切换python优先级&quot; class=&quot;headerlink&quot; title=&quot;切换python优先级&quot;&gt;&lt;/a&gt;切换python优先级&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;设置优先级&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>随机数算法</title>
    <link href="http://yoursite.com/2018/10/24/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/24/随机数算法/</id>
    <published>2018-10-24T02:30:42.000Z</published>
    <updated>2018-10-24T09:02:04.535Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在给大一的新生出题，经常需要用到随机数生成后台数据，然后偶然间在网上看到了几个很有意思的随机数算法，这里记录一下。</p><a id="more"></a><h1 id="随机数算法改造"><a href="#随机数算法改造" class="headerlink" title="随机数算法改造"></a>随机数算法改造</h1><h2 id="1、01等概率"><a href="#1、01等概率" class="headerlink" title="1、01等概率"></a>1、01等概率</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数，设计一个新的随机函数要求以等概率生成0和1。</p></blockquote><p>生成零的概率是 <code>p</code> ,1的概率是 <code>(1-p)</code> ,那么两个数随机数,第一个为0第二个为1的概率为 <code>p(1-p)</code> ,第一个为1第二个为0的概率为 <code>(1-p)p</code> 。从而实现等概率。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> p = <span class="number">0.2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_p</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; p * <span class="number">10</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">int</span> tmp2 = rand_0_and_1_with_p();</span><br><span class="line"><span class="keyword">if</span> (tmp1 == <span class="number">0</span> &amp;&amp; tmp2 == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp1 == <span class="number">1</span> &amp;&amp; tmp2 == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rand_0_and_1_with_equal_prob();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、1-n随机数"><a href="#2、1-n随机数" class="headerlink" title="2、1~n随机数"></a>2、1~n随机数</h2><p><strong>已知</strong></p><blockquote><p>有一个随机函数 rand_0_and_1_with_p(), 这个随机数生成器，它能够以概率 <code>p</code> 产生0，以概率 <code>(1-p)</code> 产生 1。</p></blockquote><p><strong>要求</strong></p><blockquote><p>使用这个随机函数 rand_0_and_1_with_p()，设计一个新的随机函数，要求以等概率产生 1  到 n 之间的随机数。</p></blockquote><p>用01生成一个随机的二进制数，n以内的二进制数最多有log2(n)位。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_and_1_with_equal_prob</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % <span class="number">10</span> &lt; <span class="number">5</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_0_to_n_minus_1_with_equal_prob</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>,res,m = n;</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line">k++;</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">res |= rand_0_and_1_with_equal_prob() &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt;= m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、由1-5生成1-7等概率随机数"><a href="#3、由1-5生成1-7等概率随机数" class="headerlink" title="3、由1-5生成1-7等概率随机数"></a>3、由1-5生成1-7等概率随机数</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand5() ，它能生成 1~5 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求据此实现 rand7()，能产生1～7 之间的随机数字。</p></blockquote><p>rand5()可以生成 0 ~ 4 的随机数，用相同的方法，我们可以生成一个等概率随机的五进制数，两位五进制数最多可以表示 0 ~ 24 共 25 个数，去掉 21 ~ 24 ，剩下 0 ~ 21 对 3 取模正好得到 0 ~ 6 的随机数加一等到 1 ~ 7 的随机数</p><p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = rand5() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = x * <span class="number">5</span> + y;</span><br><span class="line">&#125; <span class="keyword">while</span>(res &gt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> (res % <span class="number">7</span> ) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、随机数范围扩展"><a href="#4、随机数范围扩展" class="headerlink" title="4、随机数范围扩展"></a>4、随机数范围扩展</h2><p><strong>已知</strong></p><blockquote><p>给定函数 rand7(),它能生成 1 ~ 7 之间的随机数字。</p></blockquote><p><strong>要求</strong></p><blockquote><p>要求用rand7()实现rand10() 能产生 1 ~ 10 的随机数字。</p></blockquote><p>用相同的方法可以用rand7()构造出7进制的二位数，<code>( rand7() - 1 ) * 7 + rand7()</code>可以表示1 ~ 49的所有七进制数。</p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand_10</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        x = <span class="number">7</span> * (rand7() - <span class="number">1</span>) + rand7();  </span><br><span class="line">    &#125;<span class="keyword">while</span>(x &gt; <span class="number">40</span>);  </span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span> + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="等概率随机数算法"><a href="#等概率随机数算法" class="headerlink" title="等概率随机数算法"></a>等概率随机数算法</h1><h2 id="1、由两个不同概率函数生成等概率函数"><a href="#1、由两个不同概率函数生成等概率函数" class="headerlink" title="1、由两个不同概率函数生成等概率函数"></a>1、由两个不同概率函数生成等概率函数</h2><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> beta = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t&lt;<span class="number">10000</span>; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> small = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> big = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = rand() % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (val&lt;<span class="number">3</span>) small++;</span><br><span class="line"><span class="keyword">else</span> big++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (big&lt;<span class="number">7000</span>) alpha++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (big&gt;<span class="number">7000</span>) beta++;</span><br><span class="line"><span class="keyword">if</span> (big != <span class="number">7000</span>) total++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">float</span>)alpha / (<span class="keyword">float</span>)total - (<span class="keyword">float</span>)beta / (<span class="keyword">float</span>)total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2、Knuth-Durstenfeld-Shuffle算法"><a href="#2、Knuth-Durstenfeld-Shuffle算法" class="headerlink" title="/2、Knuth-Durstenfeld Shuffle算法"></a>/2、Knuth-Durstenfeld Shuffle算法</h2><blockquote><p>Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p></blockquote><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它与列表中最后一个元素交换</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p><img src="/images/shuffle.png" alt="shuffle算法"></p><p>代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">ll = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">0</span>,len(ll))):</span><br><span class="line">    p = random.randrange(<span class="number">0</span>,i+<span class="number">1</span>)</span><br><span class="line">    ll[i], ll[p] = ll[p], ll[i]</span><br><span class="line"></span><br><span class="line">print(ll)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在给大一的新生出题，经常需要用到随机数生成后台数据，然后偶然间在网上看到了几个很有意思的随机数算法，这里记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2018年秋启明星工作室答辩</title>
    <link href="http://yoursite.com/2018/09/17/2018%E5%B9%B4%E7%A7%8B%E5%90%AF%E6%98%8E%E6%98%9F%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AD%94%E8%BE%A9/"/>
    <id>http://yoursite.com/2018/09/17/2018年秋启明星工作室答辩/</id>
    <published>2018-09-17T12:10:09.000Z</published>
    <updated>2018-09-17T12:13:59.495Z</updated>
    
    <content type="html"><![CDATA[<p>暑期因为想着去了解一下区块链，搭建一个小的区块链实战一下。结果中途需要用到一个web框架，去串联每个区块链节点。就去试着学习了一下flask这个web框架。结果发现这是一个非常好用的web框架，轻量化，拓展性行强，配套教程和拓展工具库丰富。用来快速搭建一个web十分方便。所以中途学到一半就跑去跟着国外大佬的一个博客教程，搭建一个小的微博网站项目。因为博主的对整个网站的全局的思路十分清晰，从前期开始预留各种借口，优化项目结构，使得整个web应用拓展性极高。收获最多还是他提供给我的全局部署的一个思路。从零开始建站，各种需要考虑的细节，和整体的一个清晰的思路让我受益匪浅。</p><a id="more"></a><p>我的整个web应用的源码已经上传到了我的github上面，大家有兴趣的可以下载了解一下。<a href="https://github.com/aoboxia/flask_web/archive/master.zip" target="_blank" rel="noopener">点击下载</a>。这个是我<a href="https://github.com/aoboxia/flask_web.git" target="_blank" rel="noopener">github链接</a>。</p><h2 id="开发环境和工具"><a href="#开发环境和工具" class="headerlink" title="开发环境和工具"></a>开发环境和工具</h2><p>我电脑windows本地是在pycharm上进行这个web项目的开发的。不需要我自己配置虚拟环境，各种库安装，文件的创建也十分方便，强烈推荐大家使用，如果是简单的爬虫，或者算法题目的编辑，使用一个简单的编辑器就可以了。总之pycharm进行项目开发十分方便。</p><p>服务器上面我是用的ubuntu16.x，linux操作系统也是非常好用，用多了真的会觉得很方便，也强烈推荐。服务器上面我是用的mysql数据库，Gunicorn和Nginx两个web服务器。</p><h2 id="包的分布"><a href="#包的分布" class="headerlink" title="包的分布"></a>包的分布</h2><p>flask框架的web项目有一个标准的文件分布方式。首先是一个<code>app</code>的包，这是整个项目的主体部分。前端后台的代码文件都分布在这个里面。下面是一个我的文件分布：</p><blockquote><p>Microbog</p><blockquote><p>app</p><blockquote><p>forms.py<br>routes.py<br>init.py<br>models.py<br>templates</p><blockquote><p>base.html<br>index.html<br>user.html</p></blockquote></blockquote><p>logs</p><blockquote><p>microblog1.log<br>microblog2.log</p></blockquote><p>venv<br>.env<br>config.py<br>microblog.py<br>tests.py</p></blockquote></blockquote><p>其中省略很多文件，但是列出了主体的核心部分。我们首先可以看到所有文件都分布在microblog这个文件夹下。</p><h3 id="app文件夹"><a href="#app文件夹" class="headerlink" title="app文件夹"></a>app文件夹</h3><p>app是我项目的主体文件夹，可以看到我的大部分python文件和前端的html代码都是分布在这个里面的。下面我一次说明app包下面的文件的功能。</p><h4 id="forms-py"><a href="#forms-py" class="headerlink" title="forms.py"></a>forms.py</h4><p>这是我的表单文件，我的网页界面上面的表单都是我在这个文件中编写的一个类，然后通过python的库调用这个类实例化一个对象来创建一个表单。所以我可以通过编写类的方式就可以创建表单了，而不需要去写前端的代码，这样我可以快速实现我的功能。</p><h4 id="routes-py"><a href="#routes-py" class="headerlink" title="routes.py"></a>routes.py</h4><p>这里面是我专门用来存放视图函数的文件，python的装饰器是一个非常神奇的东西，可以自行百度了解一下。简单来说就是，我可以通过装饰器把函数和一个url绑定起来，这个函数专门用来处理该函数所绑定的url链接中所传来的信息。每当用户访问或点击到某个url，装饰器会捕获到这个访问，然后调用相应的视图函数去处理该事情的数据。<br>因此我每添加一个页面就需要编写一个相应的视图函数去处理该页面对应的url传来的数据。</p><h4 id="init-py"><a href="#init-py" class="headerlink" title="init.py"></a>init.py</h4><p>简单来说这就是一个接口文件，因为我们的包是一个封装好的一个整体，比如我这里的app包，外界是访问不了我这个包里面的内容的，那么我们如何去运行这个包中的文件呢？这里我们得给外界开放一个接口，<code>init.py</code>就是用来暴露接口的。我们可以在这个文件里面导入app文件下面的包，然后外面要访问app这个包时，就去找它的<code>init.py</code>文件，然后顺着<code>init.py</code>文件中导入包依次深入进去。所以这个文件其实就是提供接口的一个文件，每个包如果需要给外界提供相应的接口都可以通过创建一个<code>init.py</code>文件来实现。</p><h4 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h4><p>这个里面有点像大家编写游戏代码中的游戏元素类，web项目里面同样需要编写这样的类，我需要编写一个用户类，然后每新增一个用户就相当于给这个类实例化一个对象。然后里面还有邮件类，需要发送邮件时就调用这个类来实例化一个对象编写一封邮件。</p><h4 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h4><p>这是一个专门用来存放html代码的文件夹。我的前端代码都是存放在这个里面的。这是flask一个特别有用的功能。我们知道flask底层其实还是由两个基础的模块实现的，一个模块是<code>jinjia2</code>和<code>Werkzeug</code>，其中<code>jinjia2</code>是一个模板引擎，而我们这里的templates下面的html代码都是依赖这种模板引擎来编写的，让我们可以在html代码中使用循环，条件语句来书写，还可以用一种类似于类的继承的方式来复用html代码。可以说是用一种面向对象的编程方式去编写html代码。</p><h2 id="logs文件夹"><a href="#logs文件夹" class="headerlink" title="logs文件夹"></a>logs文件夹</h2><p>这是一个常用的惯例，我们很多地方都可以看到这个东西，这是一个日志文件夹用来存放日志，那么日志是用来干什么的呢？我们知道我们在编写算法题目时遇到错误我们都能及时的反馈出来，但是当一个项目处于生产阶段时，我们无法预知很多错误，所以我们需要一个日志文件来记录下你的项目在生产过程中出现的一些问题，来帮助你及时得到反馈，处理并修复一些问题。</p><p>下面还有一些我就不一一解释了，其中venv是一个虚拟环境，来用隔离你的项目和你的其他应用之间不相互干扰。比如你在microblog这个项目当中导入一个python包，由于venv这个虚拟环境将本项目和外界隔离开来了，所以外面使用不了这个python包。这个虚拟环境保证了项目的独立性，还有microblog.py文件是相当于一个main函数，就是它去调用app包来运行整个项目。所以在服务器上也只需要运行并监听这个文件就可以部署整个项目了。tests.py是一个测试文件，用来及时测试你的项目的相应功能是否能正常运行，.env文件用来存放环境变量,config.py也是用来调用环境变量的文件。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>其实这一块我还只停留在操作部分，怎么在数据库中查询，删除数据，数据库的更新等部分。至于怎么设计关系部门我还是参照别人的方式去做的。理解一些简单的关系设计，我这项目当中的粉丝相互关注机制还是不太了解，等过一段时间专门学习了数据库再来填坑。</p><h2 id="邮件和搜索"><a href="#邮件和搜索" class="headerlink" title="邮件和搜索"></a>邮件和搜索</h2><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>我为了丰富一下网站功能的丰富性，添加了发送邮件和全文搜索的功能。发送邮件部分主要是本地存储一个写好的邮件模板，然后根据用户的相关信息来填写这个邮件，然后通过一个代理发送出去，这里的代理就是指的google或者腾讯的这种代理。用你的google或者腾讯邮箱的账号来发送这封邮件。填写相关的账号密码和代理服务器即可。<br>另外还需要一个代理发送邮件的机制，flask相应的拓展包中有相关的功能，这个邮件当中会附带一个url链接。当用户接受到邮件然后点击这个链接时，我的服务器上的视图函数的装饰器会捕捉到这个点击，然后进行相关的处理来重置用户的账号密码。另外还需要给这个url附带一个token令牌，这也是web应用中常用的一个东西，用来控制url的有效时长。当超过一定的时长之后这个令牌将会失效，也就是说之后的点击是无效的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>这里搜索功能的实现主要是利用elasticsearch的搜索引擎来实现的。elasticsearch是一个常用的开源搜索引擎。python有相应的客户端来调用这个搜索引擎。你需要给你的数据库中的数据创建相应的索引用来给elasticsearch检索。其中还有一些数据库中的数据更新对应的检索也需要修改，这之间也存在也写先后的逻辑问题。主要使用方法是将elasticsearch运行在服务器后台，然后用代码动态的对数据库中的元素进行增删查改相应的数据索引。</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>在界面美化这方面我做得比较差，因为我主要关注的是项目的框架和功能的拓展，加上我在前端方面了解比较少，所以前端这方面的工作基本处于空白状态。但是其中我还是用到了少量ajax的方法，通过js渲染了一些消息提示框。这部分工作也是网上找的方法。</p><p>前端这一部分确实很大的局限了我的web应用的拓展，因为我不能做出相应功能的界面也导致我的web应用无法继续延伸。所以如果这学期有机会我也打算去学习web前端相应的知识。</p><h2 id="时间统一和语言"><a href="#时间统一和语言" class="headerlink" title="时间统一和语言"></a>时间统一和语言</h2><h3 id="时间统一"><a href="#时间统一" class="headerlink" title="时间统一"></a>时间统一</h3><p>我们知道世界上每个地区之间是有时差的，那么我在不同的地方发送动态如果显示的本地的时间这样会带来一定的问题。所以我在时间上必须得统一起来。这里涉及到一个时区转换的问题,我们有一个UTC的国际统一时间，这个时间是国际统一的，也就是全世界所有地方都一样。但是这个时间不方便我们认知，我们无法从这个时间获知到我们本地的时间具体是什么，因此我们还需要将UTC时间转换为本地时间。也就是我们服务器接受用户发送的动态并存储的时间数据是使用的UTC的国际统一时间戳，但是我们在给用户解析的时候再将这个时间解析为用户本地的时间，这样就解决时区不统一的问题。</p><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>我们在翻墙浏览youtube等国外网站时经常会发现很多东西都是中文显示的，这样满足了多种语言用户的需求。因此我的web应用当中同样部署了这一方案，其实这个实现起来也比较简单，只需要把web应用当中的提示性语句标识一下，然后专门给一个文件用来翻译这些被标识的语句。这个文件就相当于一张表，给你的web应用当中的提示语句都给了一个对应的翻译语句，然后设置一下你的web应用使用哪种语言就可以显示不同的语言了。通常这个翻译的文件都是<code>xxx.po</code>，按照规定的格式编写即可，网上有专门编写<code>.po</code>文件的编辑器可以实现自动翻译，使用起来也比较方便，然后需要将<code>.po</code>文件编译一些生成一个<code>.mo</code>文件就可以使用了，服务器最后调用的就是这个<code>.mo</code>文件。</p><h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><p>这方面的东西都比较碎，有很多零零散散的问题。也不好一一说。简单说一下我使用的gunicorn和nginx服务器。首先是服务器的配置文件。这个真的有点麻烦，最好还是照着网上的标配吧，改起来真的好麻烦，一不下心就崩了。有些端口监听的问题照着网上的来就好。</p><p>这里为什么需要用到两个web服务器？<br>一个是python的web服务器gunicorn。一个是我们现在使用的比较多的web服务器nginx。这种双重的服务器的部署好像是一个很常用的方案。其实一个web服务器也是可行的，也能解决正常的服务请求。但是这里使用双重服务器的好处主要在于负载均衡的问题。这是一个很常见的名词，很多流量大的网站都需要考虑这个问题，不然就会出现访问量增多导致服务器无法处理而导致系统崩溃的问题。因此我们需要合理的分配和调节服务的资源分配。这就是我们需要解决的负载均衡问题。我这里是将我的web应用运行在本地的8000端口，使用gunicorn服务器来监听和处理这个端口的数据，然后对外开放两个端口使用的nginx服务器，外部的数据和请求传输给nginx服务器，经过nginx服务器的处理之后在传输给本地的gunicorn服务器。这样当外界访问量过大时，nginx给以展示缓存部分数据慢慢交给gunicorn处理，虽然访问速度会变慢但是不至于服务器直接崩溃。<br>另外nginx在流量统计，访问管理，端口分配方面更加便捷，也给我们在某些数据处理方面带来了好处。<br>其实原因不止有这些，但是负载均衡是一个主要的问题，其他的方面的原因等我深入了解一些服务器，操作系统相关的知识再去深入了解其中的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暑期因为想着去了解一下区块链，搭建一个小的区块链实战一下。结果中途需要用到一个web框架，去串联每个区块链节点。就去试着学习了一下flask这个web框架。结果发现这是一个非常好用的web框架，轻量化，拓展性行强，配套教程和拓展工具库丰富。用来快速搭建一个web十分方便。所以中途学到一半就跑去跟着国外大佬的一个博客教程，搭建一个小的微博网站项目。因为博主的对整个网站的全局的思路十分清晰，从前期开始预留各种借口，优化项目结构，使得整个web应用拓展性极高。收获最多还是他提供给我的全局部署的一个思路。从零开始建站，各种需要考虑的细节，和整体的一个清晰的思路让我受益匪浅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="答辩" scheme="http://yoursite.com/tags/%E7%AD%94%E8%BE%A9/"/>
    
  </entry>
  
  <entry>
    <title>题解</title>
    <link href="http://yoursite.com/2018/08/26/%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/26/题解/</id>
    <published>2018-08-26T10:48:46.000Z</published>
    <updated>2018-08-26T12:00:29.996Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现自己真的太菜了，每次刷题的时候都没感觉，到了真正的比赛都是两眼一抹黑，啥算法都不会了，看来还是学了不知道怎么灵活运用，模板题做多了，思维比较僵化，稍微变化一点的题型完全没有思路。还是决定要多做一些线上的练习赛的题目，不会的之后多看一些别人的思路，学着模仿再到自己的灵活运用。</p><a id="more"></a><h1 id="2018ccpc网赛"><a href="#2018ccpc网赛" class="headerlink" title="2018ccpc网赛"></a>2018ccpc网赛</h1><p>全程划水，很多英文题目都没有看懂，有些大概知道需要用什么做但是还是形成不了具体的思路。慢慢来吧，先补几道水体，难的就不花时间了。</p><h2 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h2><blockquote><p>题目大意是一个商人可以依次经过1到n个城市，每个城市对于同一个商品的价格都不同，商人可以从一个城市买入再到另一个卖出来赚取差价，每经过一个城市都需要花费一个单位的时间而且只能依次经过1到n号城市不能回头。现在问最大的利润和最小的时间是多少。</p></blockquote><p>这道题感觉还挺简单的，不知道为啥当时没做出来，当时一直想着是找最大差值对，但是没有想到去用一个数据结构去维护数据，结果每次都需要重新扫描，自然是超时了。这题用一个堆来维护数据非常简单，依次往后走，前面已经遇到的数据放进一个堆里面存起来，后面每次都在前面找最小的数据差值就是利润，每次减去了一个差值之后就把新的较大值放入堆中，代替原有的值，下次再更新就相当于再原有的基础上更新差值了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; p;</span><br><span class="line">priority_queue&lt;p, <span class="built_in">vector</span>&lt;p&gt;, greater&lt;p&gt; &gt; q;<span class="comment">//这里用一个优先队列模拟堆，注意初始情况优先队列是从大到排序的，这样可以指定为从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n, num, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty())  q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;num);</span><br><span class="line">            <span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">                ll a = q.top().first;</span><br><span class="line">                <span class="keyword">if</span>(num - a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    sum += num - a;</span><br><span class="line">                    cnt += q.top().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(p(num,<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(p(num,<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,sum,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YJJ’s-Salesman"><a href="#YJJ’s-Salesman" class="headerlink" title="YJJ’s Salesman"></a>YJJ’s Salesman</h2><p>这道题感觉似曾相似，知道要用一个线段树或者树状数组来维护数据，但是就是不知道怎么去处理这些数据。。。之后才知道原来简单的dp一下那些数据就行，找到最优解，再用线段树或者树状数组求和。</p><blockquote><p>题意大概是有很多个村庄，告诉了村庄的坐标，每个村庄都有一个权值，去到某个村庄就可以拿到相应的钱，但是约束了一下只有右上角的村庄才能拿到钱，正上方和正右边的是拿不到钱的，问怎么走拿到的前最多</p></blockquote><p>当时一看这道题就有点像之前做过的那个数组数组的题，天上有很多星星，每个星星有一个level，右上角的星星level+1，但是那道题权值都是一样的，现在这道题每个星星多加了一个权值，需要用动态规划的思想处理一下再用树状数组去维护,因为数据比较大，还需要离散化一下，说起来都是刚刚学过的。。。。但是我试了一下，好像不用离散化也能过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tree[maxn],a[maxn],ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,val;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=maxn)</span><br><span class="line">&#123;</span><br><span class="line">tree[k] = max(num,tree[k]);</span><br><span class="line">ans = max(ans,tree[k]);</span><br><span class="line">k += k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Qmax</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res  =<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(k)</span><br><span class="line">&#123;</span><br><span class="line">res = max(tree[k],res);</span><br><span class="line">k -=k&amp;(-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.x&lt;b.x) || (a.x==b.x&amp;&amp;a.y&gt;b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;p[i].x,&amp;p[i].y,&amp;p[i].val);</span><br><span class="line">a[i] = p[i].y;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> size=unique(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-(a+<span class="number">1</span>);<span class="comment">// 去重求大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i].y = lower_bound(a+<span class="number">1</span>,a+size+<span class="number">1</span>,p[i].y)-(a+<span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll val = Qmax(p[i].y<span class="number">-1</span>)+p[i].val;</span><br><span class="line">add(p[i].y,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现自己真的太菜了，每次刷题的时候都没感觉，到了真正的比赛都是两眼一抹黑，啥算法都不会了，看来还是学了不知道怎么灵活运用，模板题做多了，思维比较僵化，稍微变化一点的题型完全没有思路。还是决定要多做一些线上的练习赛的题目，不会的之后多看一些别人的思路，学着模仿再到自己的灵活运用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LCA问题</title>
    <link href="http://yoursite.com/2018/08/24/LCA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/24/LCA问题/</id>
    <published>2018-08-24T08:25:45.000Z</published>
    <updated>2018-08-24T08:31:25.671Z</updated>
    
    <content type="html"><![CDATA[<p>LCA问题，即最近公共祖先，一般有在线的ST算法和离线的Tarjin算法还有什么倍增法，最近学算法学的有点懵逼，先写一个常用的离线tarjin算法，比较容易理解。其他的先留着，以后再填坑。</p><a id="more"></a><h2 id="Tarjin离线算法"><a href="#Tarjin离线算法" class="headerlink" title="Tarjin离线算法"></a>Tarjin离线算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">int</span> par[<span class="number">10001</span>],s[<span class="number">10001</span>],t[<span class="number">10001</span>],head[<span class="number">10001</span>],dis[<span class="number">10001</span>],vis[<span class="number">10001</span>],lca[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,w;</span><br><span class="line">&#125;es[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].to = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">x == par[x] ? x : par[x] == find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjin</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">par[u] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[s[i]] &amp;&amp; t[i] == u)&#123;</span><br><span class="line">lca[i] = find(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[t[i]] &amp;&amp; s[i] == u)&#123;</span><br><span class="line">lca[i] = find(t[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].to;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dis[v] = dis[u] + es[i].w;</span><br><span class="line">tarjin(v);</span><br><span class="line">par[v] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z,tt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tt;</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s[i] &gt;&gt; t[i];</span><br><span class="line">&#125;</span><br><span class="line">tarjin(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[s[i]] + dis[t[i]] - <span class="number">2</span>*dis[lca[i]] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LCA问题，即最近公共祖先，一般有在线的ST算法和离线的Tarjin算法还有什么倍增法，最近学算法学的有点懵逼，先写一个常用的离线tarjin算法，比较容易理解。其他的先留着，以后再填坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="http://yoursite.com/2018/08/24/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2018/08/24/网络流/</id>
    <published>2018-08-24T06:12:57.000Z</published>
    <updated>2018-08-24T08:33:21.164Z</updated>
    
    <content type="html"><![CDATA[<p>网络流是一类基于贪心思想在有权图中寻找最优解的问题。最常见的就是最大流，最小费用流之类的问题。网络流的难度在于建模，怎么将问题转化为网络流的模型求解，如何构建边与边之间的关系，建立源汇点运行最大流算法求解。</p><a id="more"></a><h2 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h2><p>这种算法其实就是贪心思想加上个一点小的优化，每次选择一条通路，流过该条路径上满足的最小流量，不停选择下去就是纯粹的贪心思想，然后优化的一点就是增加了一个增广路径的东西，其实就是把每条路径设置成了双向的，逆向也有一个流量，有点像我们在处理迷宫问题一样，不停的往前走，直到发现走不通了，再回头看能不能找到其他的路径，这里的增广路径就是迷宫问题中回头的那一条路径，就是当每条边的容量没有完全用完时，则可以回流看能不能找到更大的流量。和迷宫问题一样，可以用dfs解决。理解起来比较容易，时间复杂度较高。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap,rev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">g[u].push_back((edge)&#123;v, w, g[v].size()&#125;);</span><br><span class="line">g[v].push_back((edge)&#123;u, <span class="number">0</span>, g[u].size()<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == t)<span class="keyword">return</span> f;</span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line">edge &amp;e = g[v][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[e.to] &amp;&amp; e.cap &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> d = dfs(e.to,t,min(f,e.cap));</span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">e.cap -= d;</span><br><span class="line">g[e.to][e.rev].cap += d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> f =  dfs(s,t,INF);</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">flow += f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h2><p>由于前一种用dfs深度优先搜索的时候，如果出现路径的容量比较大的情况则增广路径十分大，递归层数也很多，所以我们可以考虑用广度优先搜索来优化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> cap[maxn][maxn],cur_flow[maxn],prev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edmonds_karp</span><span class="params">(<span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(prev,<span class="number">0</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cur_flow, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur_flow));</span><br><span class="line"></span><br><span class="line">cur_flow[src] = inf;</span><br><span class="line">q.push(src);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!cur_flow[i] &amp;&amp; cap[cur][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">if</span> (cur_flow[cur] &gt; cap[cur][i])</span><br><span class="line">cur_flow[i] = cap[cur][i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur_flow[i] = cur_flow[cur];</span><br><span class="line">prev[i] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur_flow[dest] == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dest; i != src; i = prev[i])&#123;</span><br><span class="line">cap[prev[i]][i] -= cur_flow[dest];</span><br><span class="line">cap[i][prev[i]] += cur_flow[dest];</span><br><span class="line">&#125;</span><br><span class="line">flow_sum += cur_flow[dest];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>, d = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line"><span class="built_in">memset</span>(cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(cap));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;d, &amp;c);</span><br><span class="line">cap[s][d] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, edmonds_karp(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2><p>Dinic算法是EK算法的一种优化，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">///oo表示无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> oo = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">///mm表示边的最大数量，因为要双向建边</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mm = <span class="number">111111</span>;</span><br><span class="line"><span class="comment">///点的最大数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">///node:节点数,src:源点,dest:汇点,edge:边数</span></span><br><span class="line"><span class="keyword">int</span> node, src, dest, edge;</span><br><span class="line"><span class="comment">///ver:边指向的结点,flow:边的流量,next:链表的下一条边</span></span><br><span class="line"><span class="keyword">int</span> ver[mm], flow[mm], next[mm];</span><br><span class="line"><span class="comment">///head:节点的链表头,work:用于算法中的临时链表头,dis:距离</span></span><br><span class="line"><span class="keyword">int</span> head[mn], work[mn], dis[mn], q[mn];</span><br><span class="line"></span><br><span class="line"><span class="comment">///初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> _node, <span class="keyword">int</span> _src, <span class="keyword">int</span> _dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node = _node, src = _src, dest = _dest;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    edge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///增加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[edge]=v,flow[edge]=c,next[edge]=head[u],head[u]=edge++;</span><br><span class="line">    ver[edge]=u,flow[edge]=<span class="number">0</span>,next[edge]=head[v],head[v]=edge++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///广搜计算出每个点与源点的最短距离，如果不能到达汇点说明算法结束</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dinic_bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, l, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">        dis[i] = <span class="number">-1</span>;</span><br><span class="line">    dis[q[r++]=src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(l=<span class="number">0</span>; l&lt;r; l++)</span><br><span class="line">        <span class="keyword">for</span>(i=head[u=q[l]]; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">            <span class="keyword">if</span>(flow[i] &amp;&amp; dis[v=ver[i]]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///这条边必须有剩余流量</span></span><br><span class="line">                dis[q[r++]=v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == dest)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///寻找可行流的增广路算法，按节点的距离来找，加快速度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>;</span><br><span class="line">    <span class="comment">///work 是临时链表头，这里用 i 引用它，这样寻找过的边不再寻找*</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=work[u],v,tmp; i&gt;=<span class="number">0</span>; i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flow[i]&amp;&amp;dis[v=ver[i]]==dis[u]+<span class="number">1</span>&amp;&amp;(tmp=Dinic_dfs(v,min(<span class="built_in">exp</span>,flow[i])))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">///正反向边容量改变</span></span><br><span class="line">            flow[i] -= tmp;</span><br><span class="line">            flow[i^<span class="number">1</span>] += tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///求最大流，直到没有可行流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic_flow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ret=<span class="number">0</span>, data;</span><br><span class="line">    <span class="keyword">while</span>(Dinic_bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;node; i++)</span><br><span class="line">            work[i] = head[i];</span><br><span class="line">        <span class="keyword">while</span>(data = Dinic_dfs(src, oo))</span><br><span class="line">            ret += data;<span class="comment">//cout&lt;&lt;666&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///套模板</span></span><br><span class="line">    <span class="keyword">int</span> m, n, u, v, c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        Init(m+<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            addedge(u, v, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic_flow());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再加一个模板<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_v = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，容量，反向边）  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>  </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cap;</span><br><span class="line"><span class="keyword">int</span> rev;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[max_v];<span class="comment">//图的邻接表表示  </span></span><br><span class="line"><span class="keyword">int</span> level[max_v];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//向图中增加一条从s到t容量为cap的边  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> cap)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    G[from].push_back((edge)&#123;to,cap,G[to].size()&#125;);  </span><br><span class="line">    G[to].push_back((edge)&#123;from,<span class="number">0</span>,G[from].size()<span class="number">-1</span>&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    level[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=que.front();  que.pop();</span><br><span class="line">        <span class="keyword">if</span>(v==t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e=G[v][i];</span><br><span class="line">            <span class="keyword">if</span> (e.cap&gt;<span class="number">0</span>&amp;&amp;level[e.to]&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">                que.push(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过DFS寻找增广路  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">long</span> <span class="keyword">long</span> f)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(v==t)    <span class="keyword">return</span> f;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        edge &amp;e=G[v][i];  </span><br><span class="line">        <span class="keyword">if</span>(e.cap&gt;<span class="number">0</span>&amp;&amp;level[v]+<span class="number">1</span>==level[e.to])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d=dfs(e.to,t,min(f,e.cap));  </span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                e.cap-=d;  </span><br><span class="line">                G[e.to][e.rev].cap+=d;  </span><br><span class="line">                <span class="keyword">return</span> d;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//求解从s到t的最大流  </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> flow=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">    flow+=dfs(s, t, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tt,x,y,z,cnt=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tt);</span><br><span class="line"><span class="keyword">while</span>(tt--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; max_v; i++)G[i].clear();</span></span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add_edge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cnt++,max_flow(<span class="number">1</span>,n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">后面还有最小费用流，和各种最大流的变形。。。。有时间慢慢写。。。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络流是一类基于贪心思想在有权图中寻找最优解的问题。最常见的就是最大流，最小费用流之类的问题。网络流的难度在于建模，怎么将问题转化为网络流的模型求解，如何构建边与边之间的关系，建立源汇点运行最大流算法求解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>树链剖分</title>
    <link href="http://yoursite.com/2018/08/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://yoursite.com/2018/08/24/树链剖分/</id>
    <published>2018-08-24T00:37:19.000Z</published>
    <updated>2018-08-24T06:12:30.534Z</updated>
    
    <content type="html"><![CDATA[<p>树链剖分之前一直不知道是个什么东西，最近才学到，发现也是一种很神奇的数据结构，主要是对树上的操作，将树剖分成不同的部分串联起来，再用其他的数据结构去维护他剖分的这些树链。</p><a id="more"></a><p>通常我们采用的是轻重链剖分，也就是将一棵树按照轻链和重链来划分成不同的部分。这里我们只需要知道六个个概念就足够了。</p><blockquote><p>重儿子：重儿子是指某个节点的所有子节点中子孙节点数目最多的儿子节点<br>轻儿子：某个节点的所有子节点中除重儿子之外的所有节点都是轻儿子<br>轻边：由连个亲儿子相连的边称为轻边<br>重链：由两个重儿子相连的边称为重边<br>轻链：轻边<br>重链：由重边连接而成的链称为重链</p></blockquote><p>树链剖分大多数对树的操作用其他的算法都能实现，而且时间复杂度也相当，而树链剖分的最独特的功能就是对树的路径上的值的修改，也就是，要修改在树上连续的节点值，这是其他的数据结构无法完成的。而通过树链剖分的方式则很好的解决这个问题。所以说树链剖分的主要功能是:<strong>修改树的路径上的值</strong></p><p>树链剖分主要分为三个部分：</p><h2 id="划分数据"><a href="#划分数据" class="headerlink" title="划分数据"></a>划分数据</h2><p>这一部分主要是找到树的轻重儿子，确定他们的关系，确定他们在树中的位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d; <span class="comment">//深度</span></span><br><span class="line">fa[u] = pre; <span class="comment">//父亲节点</span></span><br><span class="line">ve[u] = <span class="number">1</span>; <span class="comment">//子孙节点个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];<span class="comment">//当前节点个数加上子节点所连的节点个数 </span></span><br><span class="line"><span class="keyword">if</span>(son == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;<span class="comment">//如果当前节点的重儿子为空或者出现子节点个数多于重儿子的则改变重儿子 </span></span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="连接轻重链"><a href="#连接轻重链" class="headerlink" title="连接轻重链"></a>连接轻重链</h2><p>前面找到了轻重儿子，然后就需要把他们连接起来形成链，并把他们一次编号，方便用线段树去维护。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);<span class="comment">//有重儿子则连接重链</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);<span class="comment">//遇到轻儿子则以轻儿子为顶点新开一条链</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查询和修改"><a href="#查询和修改" class="headerlink" title="查询和修改"></a>查询和修改</h2><p>通常我们用线段树来维护这些轻重链，利用前面已经编号的编号建树。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span><br><span class="line">        update(p[top[x]], p[x], val, <span class="number">1</span>, n, <span class="number">1</span>);<span class="comment">//修改深度较大的重链上值</span></span><br><span class="line">        x = fa[top[x]];<span class="comment">//重链修改完成，上升到重链头结点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &gt; dep[y]) swap(x,y);</span><br><span class="line">    update(p[x], p[y], val, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询u,v之间的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(<span class="number">1</span>, p[f1], p[u]));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(<span class="number">1</span>, p[son[u]], p[v]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="修改单点，查询最值模板"><a href="#修改单点，查询最值模板" class="headerlink" title="修改单点，查询最值模板"></a>修改单点，查询最值模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> deep[N],fa[N],p[N],fp[N],son[N],ve[N],top[N],col[N];</span><br><span class="line"><span class="keyword">int</span> head[N],sum[N*<span class="number">4</span>],from[N],to[N],value[N];</span><br><span class="line"><span class="keyword">int</span> n,cnt,siz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;es[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">es[cnt].v = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">deep[u] = d;</span><br><span class="line">fa[u] = pre;</span><br><span class="line">ve[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = es[i].v;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u])<span class="keyword">continue</span>;</span><br><span class="line">dfs1(v,u,d+<span class="number">1</span>);</span><br><span class="line">ve[u] += ve[v];</span><br><span class="line"><span class="keyword">if</span>(son[u] == <span class="number">-1</span> ||  ve[v] &gt; ve[son[u]])&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    p[u] = ++siz;</span><br><span class="line">    <span class="keyword">if</span>(son[u] != <span class="number">-1</span>) dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = es[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = es[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">sum[k] = max(sum[k&lt;&lt;<span class="number">1</span>],sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[k] = e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= pos)update(pos,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>update(pos,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">pushup(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res = max(res,query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res = max(res,query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void change(int x,int y,int val)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    while(top[x] != top[y])</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if(deep[top[x]] &lt; deep[top[y]]) swap(x,y);</span></span><br><span class="line"><span class="comment">//        update(p[top[x]], p[x], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//        x = fa[top[x]];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if(deep[x] &gt; dep[y]) swap(x,y);</span></span><br><span class="line"><span class="comment">//    update(p[x], p[y], val, 1, n, 1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = top[u], f2 = top[v];</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[f1] &lt; deep[f2])   &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = max(tmp, query(p[f1], p[u], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">        u = fa[f1];</span><br><span class="line">        f1 = top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">return</span> max(tmp, query(p[son[u]], p[v], <span class="number">1</span>, n, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,x,y,z;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp; t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">-1</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">siz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;from[i],&amp;to[i],&amp;value[i]);</span><br><span class="line">add(from[i],to[i],value[i]);</span><br><span class="line">add(to[i],from[i],value[i]);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deep[to[i]] &lt; deep[from[i]])swap(to[i],from[i]);</span><br><span class="line">update(p[to[i]],value[i],<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s))&#123;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'D'</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'C'</span>)&#123;</span><br><span class="line">update(p[to[x]],y,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,find(x,y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树链剖分之前一直不知道是个什么东西，最近才学到，发现也是一种很神奇的数据结构，主要是对树上的操作，将树剖分成不同的部分串联起来，再用其他的数据结构去维护他剖分的这些树链。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>块状链表</title>
    <link href="http://yoursite.com/2018/08/22/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/08/22/块状链表/</id>
    <published>2018-08-22T03:46:29.000Z</published>
    <updated>2018-08-23T00:53:26.744Z</updated>
    
    <content type="html"><![CDATA[<p>块状链表应该算一个额外拓展的知识吧，貌似不属于正规的算法，也算是一种比较中庸的数据结构，中和了一下数组和链表的优缺点，形成了一个新的数据结构就是块状链表。</p><a id="more"></a><p><strong>数组</strong> 在数组中修改或删除元素需要位移前后部分，需要的平均时间复杂度为<code>O(n)</code>，查询某个元素的时间复杂度是<code>O(1)</code>。</p><p><strong>链表</strong> 链表删除和修改元素，可以直接修改节点，时间复杂度为<code>O(1)</code>,查询需要遍历节点，平均时间复杂度是<code>O(n)</code></p><p><strong>块状链表</strong> 块状链表是把一个数组中的元素，分成多个数组，每个数组当成一个节点，普通的链表的节点是单个元素，而块状链表的节点是一个数组。它的查询和修改时间复杂度都是<code>O(sqrt(n))</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块大小和块数设为比sqrt(n)稍大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000000</span> + <span class="number">10</span>, block_sz = <span class="number">4000</span> + <span class="number">100</span>, block_num = <span class="number">4000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sz, next;<span class="comment">//sz:块内大小，next:下一个块位置</span></span><br><span class="line">    <span class="keyword">bool</span> rev;<span class="comment">//翻转标记</span></span><br><span class="line">    <span class="keyword">char</span> s[block_sz];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sz = <span class="number">0</span>, next = <span class="number">-1</span>, rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g[block_num];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_block</span><span class="params">()</span> <span class="comment">//新建块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = que.front();que.pop();</span><br><span class="line">    g[t].init();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_block</span><span class="params">(<span class="keyword">int</span> t)</span> <span class="comment">//删除块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.push(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_update</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//翻转块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(g[idx].rev)</span><br><span class="line">    &#123;</span><br><span class="line">        reverse(g[idx].s, g[idx].s + g[idx].sz);</span><br><span class="line">        g[idx].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_split</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> k)</span> <span class="comment">//把第idx块分裂成两个，前k个元素划分到第一块，其余元素划分到第二块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span> || k == g[idx].sz) <span class="keyword">return</span>;</span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="keyword">int</span> tot = new_block();</span><br><span class="line">    <span class="built_in">memcpy</span>(g[tot].s, g[idx].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (g[idx].sz - k));</span><br><span class="line">    g[tot].sz = g[idx].sz - k, g[idx].sz = k;</span><br><span class="line">    g[tot].next = g[idx].next, g[idx].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_merge</span><span class="params">(<span class="keyword">int</span> idx)</span> <span class="comment">//合并维护块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = g[i].next; j != <span class="number">-1</span>; j = g[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i].sz + g[j].sz &lt;= block_sz)</span><br><span class="line">            &#123;</span><br><span class="line">                block_update(i), block_update(j);<span class="comment">//确定合并两块时，查看是否翻转</span></span><br><span class="line">                <span class="built_in">memcpy</span>(g[i].s + g[i].sz, g[j].s, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * g[j].sz);</span><br><span class="line">                g[i].sz += g[j].sz, g[i].next = g[j].next;</span><br><span class="line">                del_block(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_init</span><span class="params">()</span> <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(! que.empty()) que.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; block_num; i++) que.push(i);</span><br><span class="line">    head = new_block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_locate</span><span class="params">(<span class="keyword">int</span> &amp;idx, <span class="keyword">int</span> &amp;k)</span> <span class="comment">//查询全局第k个元素在某个块的某个位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(idx != <span class="number">-1</span> &amp;&amp; k &gt; g[idx].sz) k -= g[idx].sz, idx = g[idx].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_insert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//在全局的第k个元素后插入长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);<span class="comment">//先定位</span></span><br><span class="line">    block_split(idx, k); <span class="comment">//分裂</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = min(block_sz, n - i);</span><br><span class="line">        <span class="keyword">int</span> tot = new_block();</span><br><span class="line">        <span class="built_in">memcpy</span>(g[tot].s, str + i, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        g[tot].sz = sz;</span><br><span class="line">        g[tot].next = g[idx].next, g[idx].next = tot, idx = g[idx].next;</span><br><span class="line">        i += sz;</span><br><span class="line">    &#125;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_delete</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//删去全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next) del_block(i);</span><br><span class="line">    g[st].next = en_next;</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_rev</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span><span class="comment">//翻转全局的[l,r]内所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, l);</span><br><span class="line">    block_split(idx, l);</span><br><span class="line">    <span class="keyword">int</span> st = idx, st_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    idx = head;</span><br><span class="line">    block_locate(idx, r);</span><br><span class="line">    block_split(idx, r);</span><br><span class="line">    <span class="keyword">int</span> en = idx, en_next = g[idx].next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp[block_num], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = st_next; i != en_next; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i].rev ^= <span class="number">1</span>;</span><br><span class="line">        tmp[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[++cnt] = st, tmp[<span class="number">0</span>] = en_next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; i--) g[tmp[i]].next = tmp[i<span class="number">-1</span>];</span><br><span class="line">    block_merge(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">//打印全局的第k个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">if</span>(k == g[idx].sz) idx = g[idx].next, k = <span class="number">0</span>;<span class="comment">//输出字符时特判一下，用下面的输出函数不用特判</span></span><br><span class="line">    block_update(idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, g[idx].s[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_print</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> <span class="comment">//打印全局的第k个元素后的长度为n的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = head;</span><br><span class="line">    block_locate(idx, k);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i != <span class="number">-1</span> &amp;&amp; n &gt; <span class="number">0</span>; i = g[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        block_update(i);</span><br><span class="line">        <span class="keyword">int</span> sz = min(n, g[i].sz - k);</span><br><span class="line">        <span class="built_in">memcpy</span>(str + len, g[i].s + k, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * sz);</span><br><span class="line">        len += sz, n -= sz;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cur = <span class="number">0</span>;<span class="comment">//光标位置，初始为0</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    block_init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cur);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len) &#123;<span class="keyword">char</span> ch = getchar();<span class="keyword">if</span>(ch &gt;= <span class="number">32</span> &amp;&amp; ch &lt;= <span class="number">126</span>) str[i++] = ch;&#125;</span><br><span class="line">            str[i++] = <span class="string">'\0'</span>;</span><br><span class="line">            block_insert(cur, len, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_delete(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'R'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">            block_rev(cur, cur + len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'G'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            block_print(cur);</span><br><span class="line">            <span class="comment">//block_print(cur, 1, str);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'P'</span>) cur--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'N'</span>) cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;块状链表应该算一个额外拓展的知识吧，貌似不属于正规的算法，也算是一种比较中庸的数据结构，中和了一下数组和链表的优缺点，形成了一个新的数据结构就是块状链表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>二分图</title>
    <link href="http://yoursite.com/2018/08/21/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/08/21/二分图/</id>
    <published>2018-08-21T05:40:02.000Z</published>
    <updated>2018-08-26T12:00:34.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图的判断"><a href="#二分图的判断" class="headerlink" title="二分图的判断"></a>二分图的判断</h2><p>二分图的判断主要是利用染色法来判断所有相连的边是否有回路，依次给每个点染色，每个相邻的点染的颜色不同，如果发现，两个颜色颜色一样了则说明有回路。则不是二分图。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">color[v] = c;<span class="comment">//给当前节点染色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == c)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果两个直接相连的点颜色相同则有回路</span></span><br><span class="line"><span class="keyword">if</span>(color[g[v][i]] == <span class="number">0</span> &amp;&amp; !dfs(g[v][i],-c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//0表示还没有染色的点，1，-1交替染色</span></span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i] &amp;&amp; !dfs(i,<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果一个点没有染色的点发现了回路则不是二分图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分最大匹配"><a href="#二分最大匹配" class="headerlink" title="二分最大匹配"></a>二分最大匹配</h2><p>二分图的最大匹配实际上可以转换为网络流里面的最大流问题，每个相连的边可以看成一个容量为1的一条边，然后增加一个源点和汇点分别连一条容量为1的边到二分图的左边和右边节点。最后最大匹配数就是源点和汇点的最大流。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  g[x].size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u = g[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[u])&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[u] == <span class="number">-1</span> || find(match[u]))&#123;</span><br><span class="line">match[u] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sol</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(find(i))res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带权二分图"><a href="#带权二分图" class="headerlink" title="带权二分图"></a>带权二分图</h2><p>匈牙利算法只能解决最大二分匹配数目的问题，如果遇上了每条边都带有权值，那么就需要用到km算法，来计算权值最大的二分匹配方案。</p><p>实际上，二分匹配的算法都是基于贪心的思想，通过搜索找到当前最优解，不停搜索下去，遇到搜索失败再回头寻找新的匹配方案。这里的km算法就是基于这种思想。首先二分图的两边都有一个期望值，然后把左边的期望初始化为与它相连所有边的最大权值，右边都初始化为零，然后开始匹配，如果找到左右期望最大的匹配方案则匹配成功。否则所有左边尝试匹配过的节点都降低一个期望，右边尝试匹配过的节点都增加相同的期望，这样保证了期望和不变。然后继续搜索，匹配不成功就降低期望，直到匹配成功。时间复杂度为<code>O(n^3)</code></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//左右两边的匹配数目</span></span><br><span class="line"><span class="keyword">int</span> match[<span class="number">10001</span>],slack[<span class="number">10001</span>],e[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> lx[<span class="number">10001</span>],ly[<span class="number">10001</span>],visx[<span class="number">10001</span>],visy[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">visx[v] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[i])<span class="keyword">continue</span>;<span class="comment">//右边的节点值每次搜索只匹配一次</span></span><br><span class="line"><span class="keyword">int</span> gap = lx[v] + ly[i] - e[v][i];<span class="comment">//左右期望值之和和相连边的差值</span></span><br><span class="line"><span class="keyword">if</span>(!gap)&#123;</span><br><span class="line">visy[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[i] == <span class="number">-1</span> || dfs(match[i]))&#123;<span class="comment">//如果右边没有匹配成功或者尝试调整和它匹配成功的左节点</span></span><br><span class="line">match[i] = v;<span class="comment">//匹配成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">slack[i] = min(slack[i],gap);<span class="comment">//记录一下期望和实际的差值，如果匹配失败就减去最小的一个差值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">km</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="keyword">sizeof</span>(ly));<span class="comment">//右边期望初始化为0</span></span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">lx[i] = -INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">lx[i] = max(lx[i],e[i][j]);<span class="comment">//左边期望初始化为所有与之相连边中的最大权值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//依次给每个左节点匹配</span></span><br><span class="line"><span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span>(slack));<span class="comment">//差值初始化为无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//不断匹配，直到匹配成功</span></span><br><span class="line"><span class="built_in">memset</span>(visx,<span class="number">0</span>,<span class="keyword">sizeof</span>(visx));</span><br><span class="line"><span class="built_in">memset</span>(visy,<span class="number">0</span>,<span class="keyword">sizeof</span>(visy));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dfs(i))<span class="keyword">break</span>;<span class="comment">//匹配成功退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visy[j])</span><br><span class="line">d = min(d,slack[j]);<span class="comment">//找到最小的期望和实际的差值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visx[j])lx[j] -= d;<span class="comment">//匹配失败左边降低期望</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visy[j])ly[j] += d;<span class="comment">//右边增加期望</span></span><br><span class="line"><span class="keyword">else</span>slack[j] -= d;<span class="comment">//因为左边期望降低，所以没有访问过的期望差值也降低</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(match[i] != <span class="number">-1</span>)</span><br><span class="line">res += e[match[i]][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;<span class="comment">//返回所有最大权值边之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二分图的判断&quot;&gt;&lt;a href=&quot;#二分图的判断&quot; class=&quot;headerlink&quot; title=&quot;二分图的判断&quot;&gt;&lt;/a&gt;二分图的判断&lt;/h2&gt;&lt;p&gt;二分图的判断主要是利用染色法来判断所有相连的边是否有回路，依次给每个点染色，每个相邻的点染的颜色不同，如果发现，两个颜色颜色一样了则说明有回路。则不是二分图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>线段树和树状数组</title>
    <link href="http://yoursite.com/2018/08/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/08/14/线段树和树状数组/</id>
    <published>2018-08-14T14:03:16.000Z</published>
    <updated>2018-08-24T00:35:39.293Z</updated>
    
    <content type="html"><![CDATA[<p>线段树和树状数组有很多相似之处，都可以解决RMQ(区间最值查询)问题。都是通过维护一个特殊的数据结构来达到高效的查找，时间复杂度都是<code>O(log n)</code></p><a id="more"></a><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="1-单点更新"><a href="#1-单点更新" class="headerlink" title="1.单点更新"></a>1.单点更新</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">k += n - <span class="number">1</span>;</span><br><span class="line">dat[k] = e;</span><br><span class="line"><span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">k = (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">dat[k] = min(dat[k*<span class="number">2</span>+<span class="number">1</span>], dat[k*<span class="number">2</span>+<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= a || b &lt;= l)<span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(a &lt;= l &amp;&amp;  r &lt;= b)<span class="keyword">return</span> dat[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> vl = query(a, b, k * <span class="number">2</span> + <span class="number">1</span>, l, (l+r)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> vr = query(a, b, k * <span class="number">2</span> + <span class="number">2</span>, (l+r)/<span class="number">2</span>, r);</span><br><span class="line"><span class="keyword">return</span> min(vl,vr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sum[k];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid)built(l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid)built(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = min(sum[k&lt;&lt;<span class="number">1</span>], sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">sum[k] += e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid)update(pos,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>update(pos,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = min(sum[k&lt;&lt;<span class="number">1</span>],sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = INF;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L) res = min(res,query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid)res = min(res,query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间更新"><a href="#2-区间更新" class="headerlink" title="2.区间更新"></a>2.区间更新</h2><p>这里是以区间求和为例，至于区间替换，区间求最值，可以直接把求和数组换成相应的数组就行，求最值就存放最值，区间替换就把累加变成赋值。有些题目中可不用建树，或者查询，直接更新数据，得到区间和数组即可，根据实际情况更改，至于扫描线，求面积交之类的题目，只不过把更新的对象从点变成了线段而已，最后还是转换利用点进行更新，思想基本相同。</p><p>线段树区间更新有一个很重要的思想就是<code>lazy</code>，本来我们进行区间更新的时候，应该更新所有被当前新加入的节点影响的节点，这样的递归层数比较大，时间复杂度较高，实际上我们很多节点我们并不需要知道他的数据，因此线段树的区间更新就采用了<code>lazy</code>思想，只更新需要用到的节点，也就是当前层数的数据，当前节点下面的子树不继续更新，而是用一个数据记录记录当前节点的子树需要更新的值，当我们下次递归到了他的子树时，我们检查这个节点是否有<code>lazy</code>标记，如果我们发现<code>lazy</code>标记，我们就把当前数据加上相应的标记值，然后把当前的<code>lazy</code>传递给子节点，然后取消当前标记。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll sum[<span class="number">1000000</span>],add[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下传递lazy标记，如果是单点更新则不用乘上区间长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里为什么都是用的+而不是=，是因为虽然父节点已经更新了lazy标记，但是可能当前节点还有部分未更新</span></span><br><span class="line">sum[k&lt;&lt;<span class="number">1</span>] += add[k] * (ll)(len - (len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">add[k&lt;&lt;<span class="number">1</span>] += add[k];</span><br><span class="line">sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[k] * (ll)(len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">add[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += add[k];</span><br><span class="line">add[k] = <span class="number">0</span>;<span class="comment">//取消lazy标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,ll e,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;<span class="comment">//更新当前节点的lazy标记</span></span><br><span class="line">sum[k] += e * (ll)(r-l+<span class="number">1</span>);</span><br><span class="line">add[k] += e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(add[k])pushdown(k,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L)update(L,R,e,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)update(L,R,e,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = sum[k&lt;&lt;<span class="number">1</span>] + sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">add[rt] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sum[rt];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">built(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">built(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(add[k])pushdown(k,r-l+<span class="number">1</span>);<span class="comment">//只有需要用到那个区间才更新那个区间的lazy标记</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res += query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res += query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line">ll e;</span><br><span class="line"><span class="built_in">string</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">built(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span>(q == <span class="string">"Q"</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(l,r,<span class="number">1</span>,n,<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; e;</span><br><span class="line">update(l,r,e,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-离散化"><a href="#3-离散化" class="headerlink" title="3.离散化"></a>3.离散化</h2><p>当我们要更新的区间比较大超出了我们的数组的储存空间时，我们可以通过离散化来将每个区间编号。然后遍历区间的编号，并通过二分搜索找到改变编号区间的左右范围。通常我们将所有区间按照一定的规律排序便于按照我们的要求更新数据，另外还可以用去重，减少不必要的数据更新。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//将左右区间的值都放入一个数组</span></span><br><span class="line">dat[k++] = es[i].x;</span><br><span class="line">dat[k++] = es[i].y;</span><br><span class="line">&#125;</span><br><span class="line">sort(dat,dat+k);</span><br><span class="line"><span class="keyword">int</span> cnt = unique(dat,dat+k) - dat;<span class="comment">//去重 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l = lower_bound(dat,dat+cnt,es[i].x) - dat;<span class="comment">//二分找到每个区间的范围</span></span><br><span class="line"><span class="keyword">int</span> r = lower_bound(dat,dat+cnt,es[i].y) - dat;</span><br><span class="line"><span class="comment">//在[l,r]的范围内更新相应的数据，可以根据具体的区间开闭要求更改l,r的值</span></span><br><span class="line">update(l,r,es[i].value,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>最近做题看到一个比较特别的区间求和，这里求的是所有值的<code>sin</code>函数之和，每次更新数据不再是简单的加法，需要每次都记录一下<code>sin x</code>和<code>cos x</code>的值。然后利用求和公式计算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;double, double&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pdd sum[<span class="number">200000</span>],f[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">pdd <span class="keyword">operator</span>+(pdd x, pdd y)&#123;</span><br><span class="line"><span class="keyword">return</span> make_pair(x.first+y.first, x.second+y.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(pdd &amp;x, <span class="keyword">double</span> u,<span class="keyword">double</span> v)</span></span>&#123;</span><br><span class="line">x = make_pair(x.first*v + x.second*u, x.second*v - x.first*u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> z,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">double</span> u = <span class="built_in">sin</span>(z);</span><br><span class="line"><span class="keyword">double</span> v = <span class="built_in">cos</span>(z);</span><br><span class="line">add(f[k],u,v);</span><br><span class="line">add(sum[k],u,v);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= L)update(L,R,z,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)update(L,R,z,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[k] = sum[k&lt;&lt;<span class="number">1</span>] + sum[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">add(sum[k],f[k].first,f[k].second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">f[rt].second = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">sum[rt] = make_pair(<span class="built_in">sin</span>(e),<span class="built_in">cos</span>(e));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">built(l,mid,rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">built(mid+<span class="number">1</span>,r,rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">sum[rt] = sum[rt&lt;&lt;<span class="number">1</span>] + sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pdd <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line"><span class="keyword">return</span> sum[k];</span><br><span class="line">&#125;</span><br><span class="line">pdd res = make_pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid)res = query(L,R,l,mid,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; R)res = res + query(L,R,mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">add(res,f[k].first,f[k].second);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,l,r,q,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">built(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">if</span>(q == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,query(l,r,<span class="number">1</span>,n,<span class="number">1</span>).first);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;e);</span><br><span class="line"><span class="keyword">if</span>(l &lt;= <span class="number">0</span> || l &gt; n || r &lt;= <span class="number">0</span> || r &gt; n)<span class="keyword">continue</span>;</span><br><span class="line">update(l,r,e,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="1-单点更新-1"><a href="#1-单点更新-1" class="headerlink" title="1.单点更新"></a>1.单点更新</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">bit[i] += x;</span><br><span class="line">i += lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">res += bit[i];</span><br><span class="line">i -= lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间更新-1"><a href="#2-区间更新-1" class="headerlink" title="2.区间更新"></a>2.区间更新</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和为 Σbit1[i]*i + Σbit0[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bit0[MAX_N],bit1[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *bit,<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">bit[i] += k;</span><br><span class="line">i += lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *bit,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">res += bit[i];</span><br><span class="line">i -= lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//在区间[l,r]加上x</span></span><br><span class="line">add(bit0,l,(<span class="number">1</span>-l)*x);</span><br><span class="line">add(bit1,l,x);</span><br><span class="line">add(bit0,r+<span class="number">1</span>,r*x);</span><br><span class="line">add(bit1,r+<span class="number">1</span>,-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二维形式"><a href="#3-二维形式" class="headerlink" title="3.二维形式"></a>3.二维形式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,bit[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &lt;= n; j += lowbit(j))&#123;</span><br><span class="line">bit[i][j] += k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &gt; <span class="number">0</span>; j -= lowbit(j))&#123;</span><br><span class="line">res += bit[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;<span class="comment">//查询某个矩阵内元素之和,sum(x,y)代表(x,y)左上角矩阵之和</span></span><br><span class="line">    <span class="keyword">return</span> sum(x2,y2) - sum(x1<span class="number">-1</span>,y2) - sum(x2,y1<span class="number">-1</span>) + sum(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树和树状数组有很多相似之处，都可以解决RMQ(区间最值查询)问题。都是通过维护一个特殊的数据结构来达到高效的查找，时间复杂度都是&lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>polya计数</title>
    <link href="http://yoursite.com/2018/08/13/polya%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2018/08/13/polya计数/</id>
    <published>2018-08-13T09:32:13.000Z</published>
    <updated>2018-08-14T14:06:31.948Z</updated>
    
    <content type="html"><![CDATA[<p>当我们遇到一些具有对称性的图形时，我们通常为了保证计数方案的唯一性，需要去掉一些被重复计算的方案数，<code>polya计算定理</code>就是用来解决这样的问题的，他是先计算出所有重复的方案数，将每个重复的方案计算相同的次数，最后再统一除以重复的次数，最后得到唯一的计数方案。</p><a id="more"></a><p>有一个很经典的问题就是，石头染色方案的问题。</p><blockquote><p>现有n块石头围成一圈。要用m种颜色染这n块石头，问一共有多少种不同的方法。旋转和翻转之后的方案视作一种。</p></blockquote><p>首先考虑旋转的种类，显然总共有旋转0个位置、1个位置、2个位置。。。n-1个位置等n种旋转方法。</p><p>下面计算旋转k个位置之后和原来相同的方案数。首先我们按照顺时针顺序从0。。。n-1个给石头编号。由于旋转k个位置后和原来的位置相同，所以第i个石头和第(i+k)个石头颜色相同。这么递推下去可以知道第i个石头和第(i+k<em>t)mod n个石头的颜色相同。求解`k</em>t=0(mod n)<code>最小的t。很显然，</code>t = n/gcd(k,n)`满足条件，并且是最小的。</p><p>因此我们得到了颜色相同的石头的旋转轨迹：</p><pre><code>i --&gt; (i+k) mod n --&gt; (i+2*k) mod n --&gt; ... --&gt; (i+t*k) mod n</code></pre><p>总共循环t次，所以循环节的长度为t，即<code>n/gcd(k,n)</code>。由于总个数为n，那么循环节的个数为<code>n/n/gcd(k,n) = gcd(k,n)</code>,因此循环k个位置之后的和原来相同的染色方案数为<code>m^gcd(k,n)</code>总的方案数就是循环所有位置的方案数之和，因为都重复了n次，然后除以n。</p><pre><code>{m^gcd(0,n) + m^gcd(1,n) + m^gcd(2,n) + ... + m^gcd(k,n)} / n</code></pre><p>前面是考虑的旋转之后的重复问题，我们再来看一下，翻转重复的问题。翻转重复也就是对称问题。如果两个石头位置对称那么则算他们重复，那么这种就比较简单了，我们很容易知道每次对称的重复个数为2，那么n个石头包含多少个2呢？我们再分奇偶谈论。</p><ol><li>当n为奇数时：<br>对称轴一定是经过一个点和它的对边，共有n个对称轴，假设对称轴是穿过n节点，那么在对称中n+1和n-1互换，n+2和n-2互换，这样共有<code>(n-1)/2+1</code>（对称轴穿过的点本身是一个循环节）个循环节。</li><li>当n为偶数时：<br>分情况讨论对称轴穿过两个点还是两条边。<br>两条边：n/2个置换，每个置换的循环节个数都是<code>n/2</code><br>两个点：n/2个置换，每个置换循环节个数是<code>(n-2)/2+2 = n/2+1</code></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sol</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">res += (ll)<span class="built_in">pow</span>(m, gcd(i,n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">res += n * (ll)<span class="built_in">pow</span>(m,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res += n/<span class="number">2</span> * (ll)<span class="built_in">pow</span>(m,n/<span class="number">2</span>);</span><br><span class="line">res += n/<span class="number">2</span> * (ll)<span class="built_in">pow</span>(m,n/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">res /= <span class="number">2</span>*n;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分段优化"><a href="#分段优化" class="headerlink" title="分段优化"></a>分段优化</h2><p>我们考虑到在枚举循环节的个数时，计算了n次gcd，其中有很多次都是重复的，n的因子的个数远小于n所以，有很多<code>gcd(k,n)</code>是重复的。我们要统计<code>gcd(k,n) = d</code>的k的个数，那么k一定是d的倍数，则有<code>k = d*t</code>,因此<code>d = gcd(k,n) = gcd(d*t,n)</code>,可以得到, <code>gcd(t,n/d) = 1</code>满足条件的t的个数就是欧拉函数<code>ψ(n/d)</code>。</p><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>这题同样可以用莫比乌斯反演来求解。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们遇到一些具有对称性的图形时，我们通常为了保证计数方案的唯一性，需要去掉一些被重复计算的方案数，&lt;code&gt;polya计算定理&lt;/code&gt;就是用来解决这样的问题的，他是先计算出所有重复的方案数，将每个重复的方案计算相同的次数，最后再统一除以重复的次数，最后得到唯一的计数方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算几何</title>
    <link href="http://yoursite.com/2018/08/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <id>http://yoursite.com/2018/08/12/计算几何/</id>
    <published>2018-08-12T07:48:56.000Z</published>
    <updated>2018-08-18T06:21:03.307Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分可谓是纯粹的数学题了，异常的麻烦，变化比较多，而且特殊情况考虑比较多，代码量也很大，这里总结一些常用的模板</p><a id="more"></a><h1 id="判交问题"><a href="#判交问题" class="headerlink" title="判交问题"></a>判交问题</h1><h2 id="判断线段是否相交"><a href="#判断线段是否相交" class="headerlink" title="判断线段是否相交"></a>判断线段是否相交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inter</span><span class="params">(point a, point b, point c, point d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y) &gt; max(c.y, d.y) || min(c.x, d.x) &gt; max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> h, i, j, k;</span><br><span class="line">    h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">    i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x);</span><br><span class="line">    j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x);</span><br><span class="line">    k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x);</span><br><span class="line">    <span class="keyword">return</span> h * i &lt;= eps &amp;&amp; j * k &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断四点是否共面"><a href="#判断四点是否共面" class="headerlink" title="判断四点是否共面"></a>判断四点是否共面</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">    point <span class="keyword">operator</span> - (point &amp;o)</span><br><span class="line">    &#123;</span><br><span class="line">        point  ans;</span><br><span class="line">        ans.x = <span class="keyword">this</span>-&gt;x - o.x;</span><br><span class="line">        ans.y = <span class="keyword">this</span>-&gt;y - o.y;</span><br><span class="line">        ans.z = <span class="keyword">this</span>-&gt;z - o.z;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span>  <span class="title">dot_product</span><span class="params">(<span class="keyword">const</span> point &amp;a, <span class="keyword">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y + a.z * b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">cross_product</span><span class="params">(<span class="keyword">const</span> point &amp;a, <span class="keyword">const</span> point &amp;b)</span></span>&#123;</span><br><span class="line">    point  ans;</span><br><span class="line">    ans.x = a.y * b.z - a.z * b.y;</span><br><span class="line">    ans.y = a.z * b.x - a.x * b.z;</span><br><span class="line">    ans.z = a.x * b.y - a.y * b.x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y, &amp;p[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(dot_product(p[<span class="number">3</span>] - p[<span class="number">0</span>], cross_product(p[<span class="number">2</span>] - p[<span class="number">0</span>], p[<span class="number">1</span>] - p[<span class="number">0</span>])) == <span class="number">0.0</span> ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圆和多边形的面积交"><a href="#圆和多边形的面积交" class="headerlink" title="圆和多边形的面积交"></a>圆和多边形的面积交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">_point (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>):x(x),y(y) &#123;&#125;</span><br><span class="line">&#125;Point,Vector;</span><br><span class="line">Point p[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point c;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">&#125;Circle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Point p;</span><br><span class="line">Vector v;</span><br><span class="line">&#125;Line;</span><br><span class="line"> </span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector a, Vector b) &#123;<span class="keyword">return</span> Vector(a.x + b.x, a.y + b.y);&#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector a, Vector b) &#123;<span class="keyword">return</span> Vector(a.x - b.x, a.y - b.y);&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.x + a.y * b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span> <span class="params">(Vector a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span> (Dot (a, a));&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> a.x * b.y - a.y * b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span> <span class="params">(Point a, Point b)</span> </span>&#123;<span class="keyword">return</span> Length (a - b);&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span> <span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span> (Dot (a, b) / Length (a) / Length (b));&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span> <span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span> (x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineCircleIntersection</span> <span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回线段和圆的交点个数</span></span><br><span class="line"><span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line"><span class="keyword">double</span> e = a * a + c * c, f = <span class="number">2</span> * (a * b + c * d), g = b * b + d * d - C.r * C.r;</span><br><span class="line"><span class="keyword">double</span> delta = f * f - <span class="number">4</span> * e * g;<span class="comment">//判别式</span></span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dcmp (delta) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">t1 = (-f - <span class="built_in">sqrt</span> (delta)) / (<span class="number">2</span> * e);</span><br><span class="line">t2 = (-f + <span class="built_in">sqrt</span> (delta)) / (<span class="number">2</span> * e);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slove</span> <span class="params">(Circle r, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &lt;= <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//两个顶点都在圆内，直接求三角形面积</span></span><br><span class="line">ans += Cross (p[i] - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &lt;= <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//p[i]在圆内，p[i+1]在圆外，求与圆的交点</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line">getLineCircleIntersection (L, r, t1, t2);</span><br><span class="line">t1 = t1 &gt; <span class="number">0</span> ? t1 : t2;</span><br><span class="line">Point inter;</span><br><span class="line">inter.x = L.p.x + L.v.x * t1; inter.y = L.p.y + L.v.y * t1;</span><br><span class="line">ans += Cross (p[i] - r.c, inter - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &gt; <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//p[i]在圆外，p[i+1]在圆内</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line">getLineCircleIntersection (L, r, t1, t2);</span><br><span class="line">t1 = t1 &lt; t2 ? t1 : t2;</span><br><span class="line">Point inter;</span><br><span class="line">inter.x = L.p.x + L.v.x * t1; inter.y = L.p.y + L.v.y * t1;</span><br><span class="line">ans += Cross (inter - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (p[i] - r.c, inter - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, inter - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dcmp(Distance(p[i], r.c) - r.r) &gt; <span class="number">0</span> &amp;&amp; dcmp(Distance(p[(i + <span class="number">1</span>) % n], r.c) - r.r) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//两个点都在圆外</span></span><br><span class="line"><span class="keyword">double</span> t1,t2;</span><br><span class="line">Line L;</span><br><span class="line">L.p = p[i];</span><br><span class="line">L.v = p[(i + <span class="number">1</span>) % n] - p[i];</span><br><span class="line"><span class="keyword">if</span> (getLineCircleIntersection (L, r, t1, t2) &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;<span class="comment">//只有一个或者没有交点</span></span><br><span class="line">x = (Angle (p[(i + <span class="number">1</span>) % n] - r.c, p[i] - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Point inter1,inter2;</span><br><span class="line"><span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">swap (t1,t2);</span><br><span class="line">inter1.x = L.p.x + L.v.x * t1; inter1.y = L.p.y + L.v.y * t1;</span><br><span class="line">inter2.x = L.p.x + L.v.x * t2; inter2.y = L.p.y + L.v.y * t2;</span><br><span class="line">ans += Cross (inter1 - r.c, inter2 - r.c) / <span class="number">2</span>;<span class="comment">//三角形面积</span></span><br><span class="line">x = (Angle (p[i] - r.c, inter1 - r.c) / <span class="number">2.0</span>) * r.r * r.r;<span class="comment">//扇形面积</span></span><br><span class="line"><span class="keyword">if</span> (Cross (p[i] - r.c, inter1 - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">x = (Angle (inter2 - r.c, p[(i + <span class="number">1</span>) % n] - r.c) / <span class="number">2.0</span>) * r.r * r.r;</span><br><span class="line"><span class="keyword">if</span> (Cross (inter2 - r.c, p[(i + <span class="number">1</span>) % n] - r.c) &lt; <span class="number">0</span>)</span><br><span class="line">ans -= x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> h;</span><br><span class="line">Circle c;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%lf%lf%lf"</span>,&amp;c.c.x, &amp;c.c.y, &amp;h) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> x1,y1;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf"</span>,&amp;x1, &amp;y1);</span><br><span class="line"><span class="comment">//求圆心</span></span><br><span class="line"><span class="keyword">double</span> t = <span class="built_in">sqrt</span> (h / <span class="number">5.0</span>);</span><br><span class="line">c.c.x += x1 * t;</span><br><span class="line">c.c.y += y1 * t;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf"</span>,&amp;c.r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%.2lf\n"</span>,<span class="built_in">fabs</span> (slove (c, n)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含问题"><a href="#包含问题" class="headerlink" title="包含问题"></a>包含问题</h1><h2 id="点是否在三角形内"><a href="#点是否在三角形内" class="headerlink" title="点是否在三角形内"></a>点是否在三角形内</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算三角形面积 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(point p1,point p2, point p3)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y)) * <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断面积和是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(point p1,point p2, point p3, point p)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> s1 = calc(p,p1,p2);</span><br><span class="line"><span class="keyword">double</span> s2 = calc(p,p1,p3);</span><br><span class="line"><span class="keyword">double</span> s3 = calc(p,p2,p3);</span><br><span class="line"><span class="keyword">double</span> s  = calc(p1,p2,p3);</span><br><span class="line"><span class="keyword">if</span>(s == (s1+s2+s3))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点是否在多边形内"><a href="#点是否在多边形内" class="headerlink" title="点是否在多边形内"></a>点是否在多边形内</h2><h3 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a>凸多边形</h3><p>一般主要有四种方法：</p><ol><li>射线法</li><li>角度和判断法</li><li>改进弧长法</li><li>二分法</li></ol><p>前三种时间复杂度为<code>O(n)</code>,二分法时间复杂度为<code>O(logn)</code>，这里就记录一下二分法。二分法的思想是将第一个点与其余的所有边相连，得到<code>n-1</code>条射线，然后用二分搜索将点的位置确定在某两条相邻的射线之间。<br>主要有三步：</p><ol><li>判断点是否在最左一条边的左边和最右一条边的右边</li><li>二分枚举每条射线和该点与原点的连线做叉乘判断点相对该条射线的位置，然后继续往该点的方向搜索</li><li>最后把改点锁定在两条射线之间，然后该点是否在两条射线相连的边的内部<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">&#125;a[<span class="number">100005</span>],k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量叉乘 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">judge</span><span class="params">(point p1,point p2, point p3)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k.x &gt;&gt; k.y;</span><br><span class="line"><span class="comment">// 判断点是否在最左一条边的左边和最右一条边的右边 </span></span><br><span class="line"><span class="keyword">if</span>(judge(a[<span class="number">0</span>],a[<span class="number">1</span>],k) &gt; <span class="number">0</span> || judge(a[<span class="number">0</span>],a[n<span class="number">-1</span>],k) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">2</span>, h = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; h)&#123; <span class="comment">// 二分搜索点在那两条边之间 </span></span><br><span class="line"><span class="keyword">int</span> mid = (l+h)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judge(a[<span class="number">0</span>],a[mid],k) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">h = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断该点是否在两条射线相连的边的内部 </span></span><br><span class="line"><span class="keyword">if</span>(judge(a[l],a[l<span class="number">-1</span>],k) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="重心问题"><a href="#重心问题" class="headerlink" title="重心问题"></a>重心问题</h2><h3 id="判断多边形重心"><a href="#判断多边形重心" class="headerlink" title="判断多边形重心"></a>判断多边形重心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">bcenter</span><span class="params">(point pnt[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point p, s;</span><br><span class="line">    <span class="keyword">double</span> tp, area = <span class="number">0</span>, tpx = <span class="number">0</span>, tpy = <span class="number">0</span>;</span><br><span class="line">    p.x = pnt[<span class="number">0</span>].x;</span><br><span class="line">    p.y = pnt[<span class="number">0</span>].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;   </span><br><span class="line">        <span class="comment">//  point:0 ~ n - 1</span></span><br><span class="line">        s.x = pnt[(i == n) ? <span class="number">0</span> : i].x;</span><br><span class="line">        s.y = pnt[(i == n) ? <span class="number">0</span> : i].y;</span><br><span class="line">        tp = (p.x * s.y - s.x * p.y);</span><br><span class="line">        area += tp / <span class="number">2</span>;</span><br><span class="line">        tpx += (p.x + s.x) * tp;</span><br><span class="line">        tpy += (p.y + s.y) * tp;</span><br><span class="line">        p.x = s.x;</span><br><span class="line">        p.y = s.y;</span><br><span class="line">    &#125;</span><br><span class="line">    s.x = tpx / (<span class="number">6</span> * area);</span><br><span class="line">    s.y = tpy / (<span class="number">6</span> * area);</span><br><span class="line">    <span class="comment">//area = fabs(area);</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三角形相关重心"><a href="#三角形相关重心" class="headerlink" title="三角形相关重心"></a>三角形相关重心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">Point()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Point(<span class="keyword">double</span> xx,<span class="keyword">double</span> yy)&#123;</span><br><span class="line">x=xx;</span><br><span class="line">y=yy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point <span class="keyword">operator</span>+(Point a,Point b)&#123;  <span class="comment">//向量加 </span></span><br><span class="line"><span class="keyword">return</span> Point(a.x+b.x,a.y+b.y);  </span><br><span class="line">&#125; </span><br><span class="line">Point <span class="keyword">operator</span>-(Point a,Point b)&#123; <span class="comment">//向量减</span></span><br><span class="line"><span class="keyword">return</span> Point(a.x-b.x,a.y-b.y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Point a,Point b)</span></span>&#123; <span class="comment">//求ab的长度 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(a.x-b.x)+sqr(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">gravity</span><span class="params">(Point a,Point b,Point c)</span></span>&#123; <span class="comment">// 重心  </span></span><br><span class="line"><span class="keyword">double</span> x=(a.x+b.x+c.x)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> y=(a.y+b.y+c.y)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">waixin</span><span class="params">(Point a, Point b, Point c)</span></span>&#123; <span class="comment">//外心 </span></span><br><span class="line">    <span class="keyword">double</span> a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d = a1 * b2 - a2 * b1;</span><br><span class="line">    <span class="keyword">return</span> Point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 -a2 * c1) / d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">Incenter</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;  <span class="comment">//三角形内心 </span></span><br><span class="line">     <span class="keyword">double</span> A=dis(b,c);</span><br><span class="line">     <span class="keyword">double</span> B=dis(a,c);</span><br><span class="line">     <span class="keyword">double</span> C=dis(a,b);</span><br><span class="line">     <span class="keyword">double</span> S=A+B+C; </span><br><span class="line">     <span class="keyword">double</span> x=(A*a.x+B*b.x+C*c.x)/S;</span><br><span class="line">     <span class="keyword">double</span> y=(A*a.y+B*b.y+C*c.y)/S;</span><br><span class="line"> <span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">ortho</span><span class="params">(Point a,Point b,Point c)</span></span>&#123;  <span class="comment">//垂心 </span></span><br><span class="line"><span class="keyword">double</span> A1=b.x-c.x;</span><br><span class="line"><span class="keyword">double</span> B1=b.y-c.y;</span><br><span class="line"><span class="keyword">double</span> C1=A1*a.y-B1*a.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> A2=a.x-c.x;</span><br><span class="line"><span class="keyword">double</span> B2=a.y-c.y;</span><br><span class="line"><span class="keyword">double</span> C2=A2*b.y-B2*b.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x=(A1*C2-A2*C1)/(A2*B1-A1*B2);</span><br><span class="line"><span class="keyword">double</span> y=(B1*C2-B2*C1)/(A2*B1-A1*B2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Point(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p>凸包是指包含点集p中所有的点的最小凸多边形。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安德鲁算法，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(point p1,point p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p1.x == p2.x)<span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line"><span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(point p1,point p2,point p3)</span></span>&#123;<span class="comment">//判断新加入的点是否和最后两个点构成逆时针</span></span><br><span class="line"><span class="keyword">return</span> ((p1.x-p3.x)*(p2.y-p3.y) - (p2.x-p3.x)*(p1.y-p3.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="built_in">vector</span>&lt;point&gt; p,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;point&gt; u,l;</span><br><span class="line"></span><br><span class="line">sort(p,p+n,cmp);<span class="comment">//将集合中的点按照升序排序，x相同的按y坐标升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将x最小的两个点添加至u</span></span><br><span class="line">u.push_back(p[<span class="number">0</span>]);</span><br><span class="line">u.push_back(p[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//将x最大的两个点添加至l</span></span><br><span class="line">l.push_back(p[n<span class="number">-1</span>]);</span><br><span class="line">l.push_back(p[n<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建凸包上部</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = u.size(); j &gt;= <span class="number">2</span> &amp;&amp; judge(u[j<span class="number">-2</span>],u[j<span class="number">-1</span>],p[i]); j--)&#123;</span><br><span class="line">u.pop_back();<span class="comment">//一旦新加入的点和之前的点形成凹边(即为逆时针),就删除前面的边,直到构成凸包</span></span><br><span class="line">&#125;</span><br><span class="line">u.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建凸包下部</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-3</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l.size(); j &gt;= <span class="number">2</span> &amp;&amp; judge(l[j<span class="number">-2</span>],l[j<span class="number">-1</span>],p[i]); j--)&#123;</span><br><span class="line">l.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">l.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按顺时针方向生成凸包的点的序列</span></span><br><span class="line">reverse(l.begin(), l.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = u.size()<span class="number">-2</span>; i &gt;= <span class="number">1</span>; i--)l.push_back(u[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一部分可谓是纯粹的数学题了，异常的麻烦，变化比较多，而且特殊情况考虑比较多，代码量也很大，这里总结一些常用的模板&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="计算几何" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="http://yoursite.com/2018/08/12/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/08/12/莫比乌斯反演/</id>
    <published>2018-08-12T04:38:48.000Z</published>
    <updated>2018-08-21T05:57:46.891Z</updated>
    
    <content type="html"><![CDATA[<p>这个莫比乌斯反演真的是把我折磨得死去活来，前前后后尝试去推导了很多次，但大部分推导都是建立在一些原有的结论和公式至上的，不够直观，加上我数学素养不好，对那些公式毫无感觉，老想找到一些简单明了的陈述，至今仍是稀里糊涂。想来也罢，不会推导就算了，好在它的公式记忆起来比较方便，加上莫比乌斯函数用算法也比较好实现。暂且就把它记下来吧。</p><a id="more"></a><h2 id="线性筛法求莫比乌斯函数"><a href="#线性筛法求莫比乌斯函数" class="headerlink" title="线性筛法求莫比乌斯函数"></a>线性筛法求莫比乌斯函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// d = 1时  mu[d] = 1</span></span><br><span class="line"><span class="comment">// d = p1 * p2 * ... * pk时  mu[d] = (-1)^k</span></span><br><span class="line"><span class="comment">// 其他情况  mu[d] = 0</span></span><br><span class="line"><span class="keyword">int</span> prime[MAXN], mu[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isprime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moblus</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])&#123;</span><br><span class="line">prime[cnt++] = i;</span><br><span class="line">mu[i] = <span class="number">-1</span>; <span class="comment">// d为单个素数时,k=1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i*prime[j] &lt;= n; j++)&#123;</span><br><span class="line">isprime[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j])mu[i*prime[j]] = -mu[i];<span class="comment">//若i为素数则k=2,与mu[i]反号,不为素数时则k=1也会反号</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">mu[i*prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是怎么到合适的反演函数，这里f(k)是我们要求的gcd(x,y) == k的个数，反演函数是F(k)表示gcd(x,y) == k的倍数的个数,F(k) = (b/i)+(d/i) (取整)</span></span><br><span class="line"><span class="comment">// 从两个区间选出两个数x,y,求gcd(x,y) == k的个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAXN], mu[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isprime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moblus</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!isprime[i])&#123;</span><br><span class="line">prime[cnt++] = i;</span><br><span class="line">mu[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; i*prime[j] &lt; n; j++)&#123;</span><br><span class="line">isprime[i*prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j])mu[i*prime[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">mu[i*prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    Moblus(MAXN);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        ll ans1=<span class="number">0</span>;</span><br><span class="line">        b/=k;</span><br><span class="line">        d/=k;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;d)swap(b,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)ans1+=(ll)mu[i]*(b/i)*(d/i);</span><br><span class="line">        ll ans2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b;i++)ans2+=(ll)mu[i]*(b/i)*(b/i);<span class="comment">//重复的部分只取一半</span></span><br><span class="line">        ans2&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans1-ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分段优化"><a href="#分段优化" class="headerlink" title="分段优化"></a>分段优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分段优化，sum是mu的前缀和</span></span><br><span class="line"><span class="comment">// for(int i = 1; i &lt; n; i++)   sum[i] += sum[i-1];</span></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    n /= d, m /= d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last = <span class="number">1</span>; i &lt;= n; i = last + <span class="number">1</span>) &#123;</span><br><span class="line">        last = min(n / (n / i), m / (m / i));</span><br><span class="line">        ans += (ll)(sum[last] - sum[i - <span class="number">1</span>]) * (n / i) * (m / i);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">int</span> mu[maxn];</span><br><span class="line"><span class="keyword">int</span> n,a,b,c,d,k,x;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mobius</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( !vis[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * prime[j] &gt;=maxn) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>( i % prime[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;maxn;i++)</span><br><span class="line">        mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)swap(a,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,nex;i&lt;=a;i=nex+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nex = min(a/(a/i),b/(b/i));</span><br><span class="line">        res += <span class="number">1L</span>L *(mu[nex]-mu[i<span class="number">-1</span>])*(a/i)*(b/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mobius();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        a--;</span><br><span class="line">        c--;</span><br><span class="line">        n = min(b,d);</span><br><span class="line">        ans = solve(b/k,d/k)+solve(a/k,c/k)-solve(a/k,d/k)-solve(c/k,b/k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个莫比乌斯反演真的是把我折磨得死去活来，前前后后尝试去推导了很多次，但大部分推导都是建立在一些原有的结论和公式至上的，不够直观，加上我数学素养不好，对那些公式毫无感觉，老想找到一些简单明了的陈述，至今仍是稀里糊涂。想来也罢，不会推导就算了，好在它的公式记忆起来比较方便，加上莫比乌斯函数用算法也比较好实现。暂且就把它记下来吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C语言知识点</title>
    <link href="http://yoursite.com/2018/08/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/08/11/C语言知识点/</id>
    <published>2018-08-11T04:35:00.000Z</published>
    <updated>2018-08-11T11:46:41.958Z</updated>
    
    <content type="html"><![CDATA[<p>大一开学之前就开始接触C语言，大一上一整学期也打下一些基础，尤其对C的内部原理，内存管理方面有一些兴趣，自己零零散散也学到一些，今天才突然想起来要把这些东西给记录下来，如果后面又遇到相关的问题再来总结。</p><a id="more"></a><h1 id="一、C语言内存管理"><a href="#一、C语言内存管理" class="headerlink" title="一、C语言内存管理"></a>一、C语言内存管理</h1><p>C语言的内存管理这一块虽然我们目前使用不多，但是仍然是C语言的学习中很重要的一部分，我们在接触面向对象的语言时，基本很少看见有人提及内存管理这个词，不是没有，而是他们的内存模型比较复杂，再加上一些封装使我们的分析变得很困难，而C语言相对现在主流的一些面向对象的语言而言，更加偏向底层。同时由于C语言出现较早，应用程度很广泛，在它之后的大多数语言都有借鉴它的内存模型，所以学习C语言的内存管理对我们熟练掌握这门语言并且了解一些语言原理和构建是有很大的借鉴意义的。</p><h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>C语言主要将内存划分为五部分，每部分存放的数据类型和存取规则也有所不同。</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>英文名:<code>Stack</code><br>这里的栈有别与数据结构中的线性存储结构<code>栈</code>，数据结构中的<code>栈</code>是一种先进后出的限定线性存储结构。而这里的<code>栈</code>是一个内存区，是一种<strong>由到高地址向低地址扩展</strong>的数据结构。</p><p>栈区主要用来存放<strong>程序存放临时创建的局部变量</strong>，函数内部创建的局部变量都是存放在栈区里的，包括函数的形参和隐式创建的返回值等等</p><p>既然有存放的问题，那么随之而来的就是顺序问题了，存放总有一个先后顺序吧，谁先进谁后进呢？首先从大的方面来说肯定是，越早出现的肯定越早进栈，拿函数调用过程距离，首先进栈是一个地址，就是下个需要执行的程序段的地址(这个在后面介绍),紧接着是参数，也就是传入的形参，这里的形参也有一个先后顺序，一般来说是从右到左，这个具体有编译器决定，(返回值应该也会创建块内存，具体放在哪里我不清楚),然后是函数内部的局部变量，释放过程中是先释放局部变量，然后形参，最后找到那个地址所在的位置进行跳转。</p><p>栈区是自动回收内存的，所有变量都有生存周期，局部变量的生存周期一般都是在某个程序段或者函数内。随着程序段或者函数的调用结束时结束生存周期，内存也被自动回收，栈具有<strong>小内存，分配回收灵活</strong>的特点，当我们在进行递归操作时，随着递归层数的不断加深，栈区不得不保存每一层的相关信息，直到整个递归过程结束才释放所有空间，然后栈区的分配和释放空间也是需要时间，这也是为什么我们频繁调用函数时，时间开销会变大。递归这种频繁调用函数的操作不仅带来了额外的时间开销，而且可能快速填满栈区的空间，导致栈溢出。</p><p>这里简单谈一下栈区是如何找到一个函数的入口的，就是每次调用函数，栈区就把相应的临时变量分配的空间自上而下的放入到其中，但是在放入这些变量之前，还得存放一个地址，不然怎么回去勒，这个地址就是下次需要跳转的位置，那么这个地址的值是哪里来的呢？</p><p>这里还涉及到操作系统的问题，我们的编译器只是做好翻译的工作，就是把我们的C语言代码翻译成二进制文件，然而这些二进制文件要怎么执行还得交给操作系统去安排，操作系统把这份翻译好的二进制文件放入一个线程中，然后cpu再去运转它，那么什么时候放入呢？在哪里放入呢？这里就存在一个断点的问题，我们不过多讨论，就是操作系统交给cpu运行这份二进制文件时会产生一个断点，这个断点是有位置的，我们的栈区就是保存这个断点来作为函数的入口。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>英文名:<code>Heap</code><br>同样这里的<code>堆</code>也和数据结构里面的堆不同,这里的堆是一种<strong>由低地址向高地址扩展的数据结构，是一块不连续的内存区域</strong></p><p>堆区主要用来存放<strong>程序运行中动态分配</strong>的内存。什么是动态分配的内存呢？这里动态分配的内存主要指由我们程序员灵活分配的内存，是由我们分配并释放的，在<code>C</code>中我们用<code>malloc</code>函数来申请堆中的内存，<code>C++</code>中可以用<code>new</code>来申请。同样对应<code>free</code>和<code>delete</code>来释放部分空间(注意<code>malloc</code>,<code>free</code>是函数,<code>new</code>,<code>delete</code>是关键字)。这部分空间比较大，使用起来也比较灵活，但是管理起来确实很复杂的。</p><p>首先说它为什么是不连续的，我们在数据结构中接触到了链表，这里的堆的空间正是利用的这种不连续的空间，当我们申请内存的时候，我们向操作系统发送指令，然后操作系统有一个管理空余内存空间的链表，这个链表了记录计算机内部空余空间的位置，以节点的形式保存下来，我们申请的时候，操作系统就通过遍历链表的形式去查找合适的空间，如果找到一个合适的节点空间就返回这个空间的地址作为返回值给我们的函数,这个节点的空间可能会有剩余，剩余的空间地址会加入到空闲空间地址表中。</p><p>曾经还有一个问题困扰着我，就是网上的图和别人口中说的堆区和栈区都是一起的，栈由高到低，堆由低到高，那么为什么堆的空间比栈要大呢？</p><p>实际上，堆区和栈区的空间并不是连接在一起的，栈是一块连续的空间，它的大小是固定的。所以相邻变量存放的地址也是相邻的。而堆区是不连续的空间，因为堆是利用的计算机的这种零碎的空间，所以堆的空间比较大，它取决于计算机可利用的虚拟内存，一般来说是很大的。但是他们的存放结构分别是自顶向下和自底向上，这是由他们的存储结构决定的。实际上他们是不相邻的。</p><p>再说一下为什么申请的堆的空间比较慢，而栈空间的分配则要快得多，原因前面已经说过了，栈是一块连续的空间，所有它分配空间时，我可以通过直接跳转移动指针的方式去分配空间的，时间复杂度为<code>O(1)</code>,而堆则需要去查表，搜索节点。除此之外，堆区的内存维护也是一个很复杂的东西，正因为堆区是一块不连续的空间，因此难免会带来很多碎片化的空间，如何去处理这些碎片化的空间是非常复杂的，也苦了那些系统的设计者们。。。但是幸好我们不需要去做这部分工作，但是需要注意的是堆空间的释放问题，试想如果在递归调用的过程中申请了一块堆的空间，然后你又没有及时释放它，那么这个堆区的入口的指针则会一直保存下去，每到一个地方就要多维护一个指针，递归起来是很可怕的，所以及时释放我们申请的空间是很有必要的。</p><h3 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h3><p><code>BSS段</code>是<code>Block Started by Symbol</code>的简称,这一段是专门用来存放未被初始化或者显示初始为零的全局变量的，这一部分是和数据段”相邻的”，未被初始化的全局变量存放在BSS段，而已经初始化的全局变量则是存在数据段中的。有很多博客中这一部分都混淆不清,甚至很多都是错误的。具体的我在下面的<code>DATA段</code>中一并说明。</p><h3 id="DATA段"><a href="#DATA段" class="headerlink" title="DATA段"></a>DATA段</h3><p><code>DATA段</code>是用来存放初始化了的全局变量和静态变量，全局变量就是定义在函数外部全局都可见的变量，而静态变量则是我们人为声明的，通过<code>stastic</code>修饰的变量我们把它称作静态变量。他们是单独存放在一块区域的，他们的内存空间是在编译期间决定的，默认初始化为0。除此之外，<code>DATA段</code>还存放一些字符串常量，如<code>const char *s = &quot;hello&quot;</code>这里的字符串的值是存放在这里的，而指针还是作为一个局部变量存放在栈区中的。</p><p>顺带提一下<code>const int i = 1</code>这里的<code>i</code>是常量还是变量，它又是存放在哪里的，<code>const</code>的实现方法不同的编译器有可能不同，但是大部分编译器<code>const</code>的实现方法还是通过检查语法的形式实现的。也就是当编译器发现我们修改了<code>const</code>修饰的变量时则会报错，但实际上这里的<code>i</code>变量如果是局部变量的话，还是存放在栈区的。你可以通过以下代码验证一下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出的地址应该是连续的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们再来用一段代码看一下<code>BSS</code>中的全局变量,<code>DATA</code>中的全局变量的区别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];            <span class="comment">//BSS段 </span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1000000</span>] = &#123;<span class="number">0</span>&#125;;      <span class="comment">//BSS段 </span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1000000</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//DATA段 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你把这三个数组分别放进三个不同的源程序中运行一下，然后再去看一下他们生成的可执行文件的大小，你会发现数组c的编译成的可执行文件要大很多，而数组a和b是一样的。这就是<code>BSS段</code>和<code>DATA段</code>的一点区别，就是<code>BSS段</code>的数据是不被分配内存的，他只记录数据所需要的内存大小,<code>DATA段</code>的变量是要给数据分配内存的，而且这部分内存是包含进了可执行文件里面，而可执行文件中是不包含<code>BSS段</code>的空间的，只知道保存在它当中的数据块的大小，然后通过链接器将这部分内存连接到<code>DATA段</code>之后，这也是为什么含有数组c的可执行文件会多出那么大一部分内存。至于初始化，<code>BSS</code>的初始化是由操作系统完成的，而<code>DATA段</code>是由程序完成初始化的。</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>通常是指用来存放程序二进制机器码的一块内存区域。这部分区域的大小在程序运行前就已经确定。该部分内容可通过反汇编操作将机器码转换为汇编语言。</p><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>对于C语言这种翻译成机器代码的语言，变量名是不占内存的，他在汇编中的表示都是以(内存区地址+偏移量的形式存储的)。对于JS这种动态类型的语言是存储所有的局部变量名的。但是编译器为我们维护了一个变量表，这些变量名编译器会以字符的形式记录下来，并且记录变量对应的映射在内存中的地址。那些通过变量名的赋值操作都是编译器帮我们完成的。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>对于变量的类型，在C/C++中是通过指令解释的，通过指令来解释某一块内存以怎样的形式执行。对其他语言，一般存在额外的元数据区内。</p><h2 id="…待续"><a href="#…待续" class="headerlink" title="…待续"></a>…待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大一开学之前就开始接触C语言，大一上一整学期也打下一些基础，尤其对C的内部原理，内存管理方面有一些兴趣，自己零零散散也学到一些，今天才突然想起来要把这些东西给记录下来，如果后面又遇到相关的问题再来总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>高斯消元法</title>
    <link href="http://yoursite.com/2018/08/10/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/10/高斯消元法/</id>
    <published>2018-08-10T13:00:58.000Z</published>
    <updated>2018-08-11T04:33:22.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列主元高斯消元法"><a href="#列主元高斯消元法" class="headerlink" title="列主元高斯消元法"></a>列主元高斯消元法</h2><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解Ax=b, 其中A为方阵</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;</span><br><span class="line"></span><br><span class="line"><span class="function">vec <span class="title">gauss</span><span class="params">(<span class="keyword">const</span> mat &amp;A, <span class="keyword">const</span> vec&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = A.size();</span><br><span class="line">mat B(n, vec(n+1));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">B[i][j] = A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形成增广矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">B[i][n] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="comment">// 把正在处理的未知数系数的绝对值最大的式子换到第i行 </span></span><br><span class="line"><span class="keyword">int</span> pivot = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(B[j][i]) &gt; <span class="built_in">fabs</span>(B[pivot][i]))pivot = j;</span><br><span class="line">&#125;</span><br><span class="line">swap(B[i], B[pivot]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在某个未知量系数全为零则无解或者有无穷多解</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(B[i][i]) &lt; eps)<span class="keyword">return</span> vec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把正在处理的未知数系数变为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)B[i][j] /= B[i][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i != j &amp;&amp; B[j][i] != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// 从第j个式子中消去第i个未知数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt;= n; k++)B[j][k] -= B[j][i] * B[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后一列的值就是方程组的唯一解 </span></span><br><span class="line"><span class="function">vec <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)x[i] = B[i][n];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全主元高斯消元法"><a href="#全主元高斯消元法" class="headerlink" title="全主元高斯消元法"></a>全主元高斯消元法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全主元在每次消去后，调整向量的位置时和所有元素进行了一次比较，可以减小误差，但时间复杂度较大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> a[][MAXN], <span class="keyword">double</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, row = <span class="number">0</span>, col = <span class="number">0</span>, index[MAXN];</span><br><span class="line">    <span class="keyword">double</span> MAXP, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)index[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (MAXP = <span class="number">0</span>, i = k; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][j] &gt; <span class="built_in">fabs</span>(MAXP)))&#123;</span><br><span class="line">                    MAXP = a[row = i][col = j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(MAXP) &lt; eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (col != k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                temp = a[i][col];</span><br><span class="line">                a[i][col] = a[i][k];</span><br><span class="line">                a[i][k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            j = index[col];</span><br><span class="line">            index[col] = index[k];</span><br><span class="line">            index[k] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row != k)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = k; j &lt; n; j++)&#123;</span><br><span class="line">                temp = a[k][j];</span><br><span class="line">                a[k][j] = a[row][j];</span><br><span class="line">                a[row][j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = b[k];</span><br><span class="line">            b[k] = b[row];</span><br><span class="line">            b[row] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = k + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            a[k][j] /= MAXP;</span><br><span class="line">            <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                a[i][j] -= a[i][k] * a[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b[k] /= MAXP;</span><br><span class="line">        <span class="keyword">for</span> (i = k + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            b[i] -= b[k] * a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            b[i] -= a[i][j] * b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)a[<span class="number">0</span>][index[k]] = b[k];</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)b[k] = a[<span class="number">0</span>][k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开关类型高斯消元"><a href="#开关类型高斯消元" class="headerlink" title="开关类型高斯消元"></a>开关类型高斯消元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开关类型的高斯消元，即都为01构成的矩阵，在消元的过程中可以直接异或运算</span></span><br><span class="line"><span class="comment">//n,m为矩阵的行和列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, r, u;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">r = i;</span><br><span class="line"><span class="keyword">while</span>(mtx[r][i] == <span class="number">0</span> &amp;&amp; r &lt; n)r++; <span class="comment">//找到首非零元 </span></span><br><span class="line"><span class="keyword">if</span>(mtx[r][i])&#123;</span><br><span class="line"><span class="keyword">if</span>(r != i)swap(mtx[r],mtx[i]);</span><br><span class="line"><span class="keyword">for</span>(u = i+<span class="number">1</span>; u &lt; n; u++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mtx[u][j])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; m; k++)&#123;</span><br><span class="line">mtx[u][k] ^= mtx[i][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回矩阵的秩,自由元个数为(n-i)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列主元高斯消元法&quot;&gt;&lt;a href=&quot;#列主元高斯消元法&quot; class=&quot;headerlink&quot; title=&quot;列主元高斯消元法&quot;&gt;&lt;/a&gt;列主元高斯消元法&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
